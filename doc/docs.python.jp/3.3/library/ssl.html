<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>18.2. ssl — ソケットオブジェクトに対する TLS/SSL ラッパー &mdash; Python 3.3.6 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.3.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.3.6 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.3.6 ドキュメント" href="../contents.html" />
    <link rel="up" title="18. プロセス間通信とネットワーク" href="ipc.html" />
    <link rel="next" title="18.3. asyncore — 非同期ソケットハンドラ" href="asyncore.html" />
    <link rel="prev" title="18.1. socket — 低レベルネットワークインターフェース" href="socket.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="asyncore.html" title="18.3. asyncore — 非同期ソケットハンドラ"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="18.1. socket — 低レベルネットワークインターフェース"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.3.6</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">18. プロセス間通信とネットワーク</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1>18.2. <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal"><span class="pre">ssl</span></code></a> &#8212; ソケットオブジェクトに対する TLS/SSL ラッパー<a class="headerlink" href="#module-ssl" title="このヘッドラインへのパーマリンク">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1"><strong>ソースコード:</strong> <a class="reference external" href="http://hg.python.org/cpython/file/3.3/Lib/ssl.py">Lib/ssl.py</a></p>
<hr class="docutils" />
<p>このモジュールは Transport Layer Security (よく &#8220;Secure Sockets Layer&#8221; という名前で知られています) 暗号化と、クライアントサイド、サーバーサイド両方のネットワークソケットのためのピア認証の仕組みを提供しています。このモジュールはOpenSSLライブラリを利用しています。 OpenSSLは、全てのモダンなUnixシステム、Windows、Mac OS X、その他幾つかの OpenSSLがインストールされているプラットフォームで利用できます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">OSのソケットAPIに対して実装されているので、幾つかの挙動はプラットフォーム依存になるかもしれません。インストールされているOpenSSLのバージョンの違いも挙動の違いの原因になるかもしれません。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last"><a class="reference internal" href="#ssl-security"><span>Security considerations</span></a> を読まずにこのモジュールを使用しないでください。SSL のデフォルト設定はアプリケーションに十分ではないので、読まない場合はセキュリティに誤った意識を持ってしまうかもしれません。</p>
</div>
<p>このセクションでは、 <code class="docutils literal"><span class="pre">ssl</span></code> モジュールのオブジェクトと関数の解説します。 TLS, SSL, certificates に関するより一般的な情報は、末尾にある &#8220;See Also&#8221; のセクションを参照してください。</p>
<p>This module provides a class, <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code>, which is derived from the
<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> type, and provides a socket-like wrapper that also
encrypts and decrypts the data going over the socket with SSL.  It supports
additional methods such as <code class="xref py py-meth docutils literal"><span class="pre">getpeercert()</span></code>, which retrieves the
certificate of the other side of the connection, and <code class="xref py py-meth docutils literal"><span class="pre">cipher()</span></code>,which
retrieves the cipher being used for the secure connection.</p>
<p>For more sophisticated applications, the <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></code></a> class
helps manage settings and certificates, which can then be inherited
by SSL sockets created through the <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a> method.</p>
<div class="section" id="functions-constants-and-exceptions">
<h2>18.2.1. 関数、定数、例外<a class="headerlink" href="#functions-constants-and-exceptions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLError</code><a class="headerlink" href="#ssl.SSLError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Raised to signal an error from the underlying SSL implementation
(currently provided by the OpenSSL library).  This signifies some
problem in the higher-level encryption and authentication layer that&#8217;s
superimposed on the underlying network connection.  This error
is a subtype of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a>.  The error code and message of
<a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> instances are provided by the OpenSSL library.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> used to be a subtype of <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal"><span class="pre">socket.error</span></code></a>.</p>
</div>
<dl class="attribute">
<dt id="ssl.SSLError.library">
<code class="descname">library</code><a class="headerlink" href="#ssl.SSLError.library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A string mnemonic designating the OpenSSL submodule in which the error
occurred, such as <code class="docutils literal"><span class="pre">SSL</span></code>, <code class="docutils literal"><span class="pre">PEM</span></code> or <code class="docutils literal"><span class="pre">X509</span></code>.  The range of possible
values depends on the OpenSSL version.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLError.reason">
<code class="descname">reason</code><a class="headerlink" href="#ssl.SSLError.reason" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A string mnemonic designating the reason this error occurred, for
example <code class="docutils literal"><span class="pre">CERTIFICATE_VERIFY_FAILED</span></code>.  The range of possible
values depends on the OpenSSL version.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ssl.SSLZeroReturnError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLZeroReturnError</code><a class="headerlink" href="#ssl.SSLZeroReturnError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> raised when trying to read or write and
the SSL connection has been closed cleanly.  Note that this doesn&#8217;t
mean that the underlying transport (read TCP) has been closed.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantReadError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantReadError</code><a class="headerlink" href="#ssl.SSLWantReadError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> raised by a <a class="reference internal" href="#ssl-nonblocking"><span>non-blocking SSL socket</span></a> when trying to read or write data, but more data needs
to be received on the underlying TCP transport before the request can be
fulfilled.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLWantWriteError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLWantWriteError</code><a class="headerlink" href="#ssl.SSLWantWriteError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> raised by a <a class="reference internal" href="#ssl-nonblocking"><span>non-blocking SSL socket</span></a> when trying to read or write data, but more data needs
to be sent on the underlying TCP transport before the request can be
fulfilled.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLSyscallError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLSyscallError</code><a class="headerlink" href="#ssl.SSLSyscallError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> raised when a system error was encountered
while trying to fulfill an operation on a SSL socket.  Unfortunately,
there is no easy way to inspect the original errno number.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.SSLEOFError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLEOFError</code><a class="headerlink" href="#ssl.SSLEOFError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a> raised when the SSL connection has been
terminated abruptly.  Generally, you shouldn&#8217;t try to reuse the underlying
transport when this error is encountered.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="ssl.CertificateError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">CertificateError</code><a class="headerlink" href="#ssl.CertificateError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Raised to signal an error with a certificate (such as mismatching
hostname).  Certificate errors detected by OpenSSL, though, raise
an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a>.</p>
</dd></dl>

<div class="section" id="socket-creation">
<h3>18.2.1.1. Socket creation<a class="headerlink" href="#socket-creation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following function allows for standalone socket creation.  Starting from
Python 3.2, it can be more flexible to use <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a>
instead.</p>
<dl class="function">
<dt id="ssl.wrap_socket">
<code class="descclassname">ssl.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version={see docs}</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>ciphers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.wrap_socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Takes an instance <code class="docutils literal"><span class="pre">sock</span></code> of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a>, and returns an instance
of <code class="xref py py-class docutils literal"><span class="pre">ssl.SSLSocket</span></code>, a subtype of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a>, which wraps
the underlying socket in an SSL context.  <code class="docutils literal"><span class="pre">sock</span></code> must be a
<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a> socket; other socket types are unsupported.</p>
<p>For client-side sockets, the context construction is lazy; if the
underlying socket isn&#8217;t connected yet, the context construction will be
performed after <code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code> is called on the socket.  For
server-side sockets, if the socket has no remote peer, it is assumed
to be a listening socket, and the server-side SSL wrapping is
automatically performed on client connections accepted via the
<code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code> method.  <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> may raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal"><span class="pre">SSLError</span></code></a>.</p>
<p>オプションの <code class="docutils literal"><span class="pre">keyfile</span></code> と <code class="docutils literal"><span class="pre">certfile</span></code> 引数は、接続のこちら側を識別するために利用される証明書を含むファイルを指定します。証明書がどのように <code class="docutils literal"><span class="pre">certfile</span></code> に格納されるかについてのより詳しい情報は、 <a class="reference internal" href="#ssl-certificates"><span>証明書</span></a> を参照してください。</p>
<p><code class="docutils literal"><span class="pre">server_side</span></code> 引数は真偽値で、このソケットがサーバーサイドとクライアントサイドのどちらの動作をするのかを指定します。</p>
<p><code class="docutils literal"><span class="pre">cert_reqs</span></code> 引数は、接続の相手側からの証明書を必要とするかどうかと、それを検証(validate)するかどうかを指定します。これは次の3つの定数のどれかで無ければなりません: <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> (証明書は無視されます), <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> (必要としないが、提供された場合は検証する), <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> (証明書を必要とし、検証する)。もしこの引数が <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> 以外だった場合、 <code class="docutils literal"><span class="pre">ca_certs</span></code> 引数はCA証明書ファイルを指定していなければなりません。</p>
<p><code class="docutils literal"><span class="pre">ca_certs</span></code> ファイルは、接続の相手側から渡された証明書を検証するために使う、一連のCA証明書を結合したものを含んでいます。このファイル内にどう証明書を並べるかについての詳しい情報は <a class="reference internal" href="#ssl-certificates"><span>証明書</span></a> を参照してください。</p>
<p><code class="docutils literal"><span class="pre">ssl_version</span></code> 引数は、使用するSSLプロトコルのバージョンを指定します。通常、サーバー側が特定のプロトコルバージョンを選び、クライアント側はサーバーの選んだプロトコルを受け入れなければなりません。ほとんどのバージョンは他のバージョンと互換性がありません。もしこの引数が指定されなかった場合、デフォルトは <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> になります。このバージョンは、できるだけの互換性を確保するように選ばれています。</p>
<p>次のテーブルは、どのクライアント側のバージョンがどのサーバー側のバージョンに接続できるかを示しています:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="15%" />
<col width="15%" />
<col width="16%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>client</em> / <strong>server</strong></td>
<td><strong>SSLv2</strong></td>
<td><strong>SSLv3</strong></td>
<td><strong>SSLv23</strong></td>
<td><strong>TLSv1</strong></td>
</tr>
<tr class="row-even"><td><em>SSLv2</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>SSLv3</em></td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>SSLv23</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>TLSv1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">どの接続が成功するかは、 OpenSSL のバージョンに依存して大きく変わります。例えば、いくつか古めのバージョンの OpenSSL (OS X 10.4 の 0.9.7l など) では、 SSLv2 クライアントは SSLv23 サーバーに接続できませんでした。また、 OpenSSL 1.0.0 の初期では、明示的に SSLv2 cipher を有効にしない限り、実際には SSLv23 クライアントは SSLv2 接続を試みませんでした。このバージョンで SSLv2 を有効にするには、 <em>ciphers</em> 引数に <code class="docutils literal"><span class="pre">&quot;ALL&quot;</span></code> か``&#8221;SSLv2&#8221;`` を指定することができます。</p>
</div>
<p><em>ciphers</em> 引数はこの SSL オブジェクトで利用可能な cipher を指定します。これは、 <a class="reference external" href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">OpenSSL cipher list format</a> にある文字列のどれかでなければなりません。</p>
<p><code class="docutils literal"><span class="pre">do_handshake_on_connect</span></code> 引数は、 <code class="xref py py-meth docutils literal"><span class="pre">socket.connect()</span></code> の後に自動的に SSLハンドシェイクを行うか、それともアプリケーションが明示的に <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></code></a> メソッドを実行するかを指定します。 <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></code></a> を明示的に呼びだすことで、ハンドシェイクによるソケットI/Oのブロッキング動作を制御できます。</p>
<p>The parameter <code class="docutils literal"><span class="pre">suppress_ragged_eofs</span></code> specifies how the
<code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.recv()</span></code> method should signal unexpected EOF from the other end
of the connection.  If specified as <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a> (the default), it returns a
normal EOF (an empty bytes object) in response to unexpected EOF errors
raised from the underlying socket; if <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>, it will raise the
exceptions back to the caller.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>New optional argument <em>ciphers</em>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="random-generation">
<h3>18.2.1.2. Random generation<a class="headerlink" href="#random-generation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="ssl.RAND_bytes">
<code class="descclassname">ssl.</code><code class="descname">RAND_bytes</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns <em>num</em> cryptographically strong pseudo-random bytes. Raises an
<a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> if the PRNG has not been seeded with enough data or if the
operation is not supported by the current RAND method. <a class="reference internal" href="#ssl.RAND_status" title="ssl.RAND_status"><code class="xref py py-func docutils literal"><span class="pre">RAND_status()</span></code></a>
can be used to check the status of the PRNG and <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal"><span class="pre">RAND_add()</span></code></a> can be used
to seed the PRNG.</p>
<p>Read the Wikipedia article, <a class="reference external" href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">Cryptographically secure pseudorandom number
generator (CSPRNG)</a>,
to get the requirements of a cryptographically generator.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_pseudo_bytes">
<code class="descclassname">ssl.</code><code class="descname">RAND_pseudo_bytes</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_pseudo_bytes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns (bytes, is_cryptographic): bytes are <em>num</em> pseudo-random bytes,
is_cryptographic is <code class="docutils literal"><span class="pre">True</span></code> if the bytes generated are cryptographically
strong. Raises an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> if the operation is not supported by the
current RAND method.</p>
<p>Generated pseudo-random byte sequences will be unique if they are of
sufficient length, but are not necessarily unpredictable. They can be used
for non-cryptographic purposes and for certain purposes in cryptographic
protocols, but usually not for key generation etc.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_status">
<code class="descclassname">ssl.</code><code class="descname">RAND_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_status" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if the SSL pseudo-random number generator has been seeded with
&#8216;enough&#8217; randomness, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.  You can use <a class="reference internal" href="#ssl.RAND_egd" title="ssl.RAND_egd"><code class="xref py py-func docutils literal"><span class="pre">ssl.RAND_egd()</span></code></a>
and <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal"><span class="pre">ssl.RAND_add()</span></code></a> to increase the randomness of the pseudo-random
number generator.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_egd">
<code class="descclassname">ssl.</code><code class="descname">RAND_egd</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_egd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If you are running an entropy-gathering daemon (EGD) somewhere, and <em>path</em>
is the pathname of a socket connection open to it, this will read 256 bytes
of randomness from the socket, and add it to the SSL pseudo-random number
generator to increase the security of generated secret keys.  This is
typically only necessary on systems without better sources of randomness.</p>
<p>エントロピー収集デーモンについては、 <a class="reference external" href="http://egd.sourceforge.net/">http://egd.sourceforge.net/</a> や <a class="reference external" href="http://prngd.sourceforge.net/">http://prngd.sourceforge.net/</a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_add">
<code class="descclassname">ssl.</code><code class="descname">RAND_add</code><span class="sig-paren">(</span><em>bytes</em>, <em>entropy</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_add" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた <em>bytes</em> をSSL擬似乱数生成器に混ぜます。 <em>entropy</em> 引数(float値)は、その文字列に含まれるエントロピーの下限(lower bound)です。 (なので、いつでも <code class="xref py py-const docutils literal"><span class="pre">0.0</span></code> を使うことができます。) エントロピーのソースについてのより詳しい情報は、 <span class="target" id="index-16"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1750.html"><strong>RFC 1750</strong></a> を参照してください。</p>
</dd></dl>

</div>
<div class="section" id="certificate-handling">
<h3>18.2.1.3. Certificate handling<a class="headerlink" href="#certificate-handling" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="function">
<dt id="ssl.match_hostname">
<code class="descclassname">ssl.</code><code class="descname">match_hostname</code><span class="sig-paren">(</span><em>cert</em>, <em>hostname</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.match_hostname" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Verify that <em>cert</em> (in decoded format as returned by
<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></code></a>) matches the given <em>hostname</em>.  The rules
applied are those for checking the identity of HTTPS servers as outlined
in <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2818.html"><strong>RFC 2818</strong></a> and <span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6125.html"><strong>RFC 6125</strong></a>, except that IP addresses are not currently
supported. In addition to HTTPS, this function should be suitable for
checking the identity of servers in various SSL-based protocols such as
FTPS, IMAPS, POPS and others.</p>
<p><a class="reference internal" href="#ssl.CertificateError" title="ssl.CertificateError"><code class="xref py py-exc docutils literal"><span class="pre">CertificateError</span></code></a> is raised on failure. On success, the function
returns nothing:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">&#39;example.com&#39;</span><span class="p">),),)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s">&quot;example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s">&quot;example.org&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/py3k/Lib/ssl.py&quot;</span>, line <span class="m">130</span>, in <span class="n">match_hostname</span>
<span class="gr">ssl.CertificateError</span>: <span class="n">hostname &#39;example.org&#39; doesn&#39;t match &#39;example.com&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3.3 で変更: </span>The function now follows <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6125.html"><strong>RFC 6125</strong></a>, section 6.4.3 and does neither
match multiple wildcards (e.g. <code class="docutils literal"><span class="pre">*.*.com</span></code> or <code class="docutils literal"><span class="pre">*a*.example.org</span></code>) nor
a wildcard inside an internationalized domain names (IDN) fragment.
IDN A-labels such as <code class="docutils literal"><span class="pre">www*.xn--pthon-kva.org</span></code> are still supported,
but <code class="docutils literal"><span class="pre">x*.python.org</span></code> no longer matches <code class="docutils literal"><span class="pre">xn--tda.python.org</span></code>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.cert_time_to_seconds">
<code class="descclassname">ssl.</code><code class="descname">cert_time_to_seconds</code><span class="sig-paren">(</span><em>timestring</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.cert_time_to_seconds" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>証明書内の &#8220;notBefore&#8221; や &#8220;notAfter&#8221; で使われている日時の文字列表現 <em>timestring</em> から、通常のエポック秒を含むfloat値にして返します。</p>
<p>以下はこの使用例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">)</span>
<span class="go">1178694000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">))</span>
<span class="go">&#39;Wed May  9 00:00:00 2007&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.get_server_certificate">
<code class="descclassname">ssl.</code><code class="descname">get_server_certificate</code><span class="sig-paren">(</span><em>addr</em>, <em>ssl_version=PROTOCOL_SSLv3</em>, <em>ca_certs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_server_certificate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>SSLで保護されたサーバーのアドレス <code class="docutils literal"><span class="pre">addr</span></code> を (<em>hostname</em>, <em>port-number</em>) の形で受け取り、そのサーバーから証明書を取得し、それを PEMエンコードされた文字列として返します。 <code class="docutils literal"><span class="pre">ssl_version</span></code> が指定された場合は、サーバーに接続を試みるときにそのバージョンのSSLプロトコルを利用します。 <code class="docutils literal"><span class="pre">ca_certs</span></code> が指定された場合、それは <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> の同名の引数と同じフォーマットで、ルート証明書のリストを含むファイルでなければなりません。この関数はサーバー証明書をルート証明書リストに対して認証し、認証が失敗した場合にこの関数も失敗します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>This function is now IPv6-compatible.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.DER_cert_to_PEM_cert">
<code class="descclassname">ssl.</code><code class="descname">DER_cert_to_PEM_cert</code><span class="sig-paren">(</span><em>DER_cert_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.DER_cert_to_PEM_cert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>DERエンコードされたバイト列として与えられた証明書から、 PEMエンコードされたバージョンの同じ証明書を返します。</p>
</dd></dl>

<dl class="function">
<dt id="ssl.PEM_cert_to_DER_cert">
<code class="descclassname">ssl.</code><code class="descname">PEM_cert_to_DER_cert</code><span class="sig-paren">(</span><em>PEM_cert_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.PEM_cert_to_DER_cert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>PEM 形式のASCII文字列として与えられた証明書から、同じ証明書をDERエンコードしたバイト列を返します。</p>
</dd></dl>

</div>
<div class="section" id="constants">
<h3>18.2.1.4. 定数<a class="headerlink" href="#constants" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="data">
<dt id="ssl.CERT_NONE">
<code class="descclassname">ssl.</code><code class="descname">CERT_NONE</code><a class="headerlink" href="#ssl.CERT_NONE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></code></a>, or the <code class="docutils literal"><span class="pre">cert_reqs</span></code>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a>.  In this mode (the default), no
certificates will be required from the other side of the socket connection.
If a certificate is received from the other end, no attempt to validate it
is made.</p>
<p>See the discussion of <a class="reference internal" href="#ssl-security"><span>Security considerations</span></a> below.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_OPTIONAL">
<code class="descclassname">ssl.</code><code class="descname">CERT_OPTIONAL</code><a class="headerlink" href="#ssl.CERT_OPTIONAL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></code></a>, or the <code class="docutils literal"><span class="pre">cert_reqs</span></code>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a>.  In this mode no certificates will be
required from the other side of the socket connection; but if they
are provided, validation will be attempted and an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a>
will be raised on failure.</p>
<p>Use of this setting requires a valid set of CA certificates to
be passed, either to <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_verify_locations()</span></code></a> or as a
value of the <code class="docutils literal"><span class="pre">ca_certs</span></code> parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a>.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_REQUIRED">
<code class="descclassname">ssl.</code><code class="descname">CERT_REQUIRED</code><a class="headerlink" href="#ssl.CERT_REQUIRED" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Possible value for <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal"><span class="pre">SSLContext.verify_mode</span></code></a>, or the <code class="docutils literal"><span class="pre">cert_reqs</span></code>
parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a>.  In this mode, certificates are
required from the other side of the socket connection; an <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a>
will be raised if no certificate is provided, or if its validation fails.</p>
<p>Use of this setting requires a valid set of CA certificates to
be passed, either to <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_verify_locations()</span></code></a> or as a
value of the <code class="docutils literal"><span class="pre">ca_certs</span></code> parameter to <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a>.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv2</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルに SSL バージョン2を選択する。</p>
<p>このプロトコルは、 OpenSSL が OPENSSL_NO_SSL2 フラグが有効な状態でコンパイルされている場合には利用できません。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SSL version 2 は非セキュアです。このプロトコルは強く非推奨です。</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv23">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv23</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv23" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてSSLバージョン2か3を選択します。これはサーバー側が相手側への最大限の互換性を確保するための設定です。しかし、この設定では非常に低い品質の暗号化が選ばれる可能性があります。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv3</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてSSLバージョン3をを選択します。クライアントにとって、これは最大限に互換性の高いSSLの種類です。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>チャンネル暗号化プロトコルとしてTLSバージョン1を選択します。これは最も現代的で、接続の両サイドが利用できる場合は、たぶん最も安全な選択肢です。</p>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_ALL">
<code class="descclassname">ssl.</code><code class="descname">OP_ALL</code><a class="headerlink" href="#ssl.OP_ALL" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Enables workarounds for various bugs present in other SSL implementations.
This option is set by default.  It does not necessarily set the same
flags as OpenSSL&#8217;s <code class="docutils literal"><span class="pre">SSL_OP_ALL</span></code> constant.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv2</code><a class="headerlink" href="#ssl.OP_NO_SSLv2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prevents an SSLv2 connection.  This option is only applicable in
conjunction with <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a>.  It prevents the peers from
choosing SSLv2 as the protocol version.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_SSLv3</code><a class="headerlink" href="#ssl.OP_NO_SSLv3" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prevents an SSLv3 connection.  This option is only applicable in
conjunction with <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a>.  It prevents the peers from
choosing SSLv3 as the protocol version.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_TLSv1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prevents a TLSv1 connection.  This option is only applicable in
conjunction with <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a>.  It prevents the peers from
choosing TLSv1 as the protocol version.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_CIPHER_SERVER_PREFERENCE">
<code class="descclassname">ssl.</code><code class="descname">OP_CIPHER_SERVER_PREFERENCE</code><a class="headerlink" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Use the server&#8217;s cipher ordering preference, rather than the client&#8217;s.
This option has no effect on client sockets and SSLv2 server sockets.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_DH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_DH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_DH_USE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prevents re-use of the same DH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_SINGLE_ECDH_USE">
<code class="descclassname">ssl.</code><code class="descname">OP_SINGLE_ECDH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_ECDH_USE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prevents re-use of the same ECDH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OP_NO_COMPRESSION">
<code class="descclassname">ssl.</code><code class="descname">OP_NO_COMPRESSION</code><a class="headerlink" href="#ssl.OP_NO_COMPRESSION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Disable compression on the SSL channel.  This is useful if the application
protocol supports its own compression scheme.</p>
<p>This option is only available with OpenSSL 1.0.0 and later.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_ECDH">
<code class="descclassname">ssl.</code><code class="descname">HAS_ECDH</code><a class="headerlink" href="#ssl.HAS_ECDH" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for Elliptic Curve-based
Diffie-Hellman key exchange.  This should be true unless the feature was
explicitly disabled by the distributor.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_SNI">
<code class="descclassname">ssl.</code><code class="descname">HAS_SNI</code><a class="headerlink" href="#ssl.HAS_SNI" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for the <em>Server Name
Indication</em> extension to the SSLv3 and TLSv1 protocols (as defined in
<span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4366.html"><strong>RFC 4366</strong></a>).  When true, you can use the <em>server_hostname</em> argument to
<a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.HAS_NPN">
<code class="descclassname">ssl.</code><code class="descname">HAS_NPN</code><a class="headerlink" href="#ssl.HAS_NPN" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether the OpenSSL library has built-in support for <em>Next Protocol
Negotiation</em> as described in the <a class="reference external" href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg">NPN draft specification</a>. When true,
you can use the <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> method to advertise
which protocols you want to support.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.CHANNEL_BINDING_TYPES">
<code class="descclassname">ssl.</code><code class="descname">CHANNEL_BINDING_TYPES</code><a class="headerlink" href="#ssl.CHANNEL_BINDING_TYPES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>List of supported TLS channel binding types.  Strings in this list
can be used as arguments to <a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.get_channel_binding()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION</code><a class="headerlink" href="#ssl.OPENSSL_VERSION" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>インタプリタによってロードされた OpenSSL ライブラリのバージョン文字列:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 0.9.8k 25 Mar 2009&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_INFO">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_INFO</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_INFO" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OpenSSL ライブラリのバージョン情報を表す5つの整数のタプル:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(0, 9, 8, 11, 15)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.OPENSSL_VERSION_NUMBER">
<code class="descclassname">ssl.</code><code class="descname">OPENSSL_VERSION_NUMBER</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_NUMBER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>1つの整数の形式の、 OpenSSL ライブラリの生のバージョン番号:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">9470143</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x9080bf&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="ssl-sockets">
<h2>18.2.2. SSL ソケット<a class="headerlink" href="#ssl-sockets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SSL sockets provide the following methods of <a class="reference internal" href="socket.html#socket-objects"><span>socket オブジェクト</span></a>:</p>
<ul class="simple">
<li><a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal"><span class="pre">bind()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal"><span class="pre">connect()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.detach" title="socket.socket.detach"><code class="xref py py-meth docutils literal"><span class="pre">detach()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal"><span class="pre">fileno()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal"><span class="pre">getpeername()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal"><span class="pre">getsockname()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><code class="xref py py-meth docutils literal"><span class="pre">getsockopt()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><code class="xref py py-meth docutils literal"><span class="pre">setsockopt()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.gettimeout" title="socket.socket.gettimeout"><code class="xref py py-meth docutils literal"><span class="pre">gettimeout()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal"><span class="pre">settimeout()</span></code></a>,
<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal"><span class="pre">setblocking()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal"><span class="pre">makefile()</span></code></a></li>
<li><a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal"><span class="pre">recv()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal"><span class="pre">recv_into()</span></code></a>
(but passing a non-zero <code class="docutils literal"><span class="pre">flags</span></code> argument is not allowed)</li>
<li><a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal"><span class="pre">sendall()</span></code></a> (with
the same limitation)</li>
<li><a class="reference internal" href="socket.html#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">shutdown()</span></code></a></li>
</ul>
<p>However, since the SSL (and TLS) protocol has its own framing atop
of TCP, the SSL sockets abstraction can, in certain respects, diverge from
the specification of normal, OS-level sockets.  See especially the
<a class="reference internal" href="#ssl-nonblocking"><span>notes on non-blocking sockets</span></a>.</p>
<p>SSL sockets also have the following additional methods and attributes:</p>
<dl class="method">
<dt id="ssl.SSLSocket.do_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">do_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.do_handshake" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Perform the SSL setup handshake.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.getpeercert">
<code class="descclassname">SSLSocket.</code><code class="descname">getpeercert</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.getpeercert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>接続先に証明書が無い場合、 <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>If the <code class="docutils literal"><span class="pre">binary_form</span></code> parameter is <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>, and a certificate was
received from the peer, this method returns a <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> instance.  If the
certificate was not validated, the dict is empty.  If the certificate was
validated, it returns a dict with several keys, amongst them <code class="docutils literal"><span class="pre">subject</span></code>
(the principal for which the certificate was issued) and <code class="docutils literal"><span class="pre">issuer</span></code>
(the principal issuing the certificate).  If a certificate contains an
instance of the <em>Subject Alternative Name</em> extension (see <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3280.html"><strong>RFC 3280</strong></a>),
there will also be a <code class="docutils literal"><span class="pre">subjectAltName</span></code> key in the dictionary.</p>
<p>The <code class="docutils literal"><span class="pre">subject</span></code> and <code class="docutils literal"><span class="pre">issuer</span></code> fields are tuples containing the sequence
of relative distinguished names (RDNs) given in the certificate&#8217;s data
structure for the respective fields, and each RDN is a sequence of
name-value pairs.  Here is a real-world example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;issuer&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">&#39;IL&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">&#39;StartCom Ltd.&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
              <span class="s">&#39;Secure Digital Certificate Signing&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span>
              <span class="s">&#39;StartCom Class 2 Primary Intermediate Server CA&#39;</span><span class="p">),)),</span>
 <span class="s">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s">&#39;Nov 22 08:15:19 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;notBefore&#39;</span><span class="p">:</span> <span class="s">&#39;Nov 21 03:09:52 2011 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;serialNumber&#39;</span><span class="p">:</span> <span class="s">&#39;95F0&#39;</span><span class="p">,</span>
 <span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;description&#39;</span><span class="p">,</span> <span class="s">&#39;571208-SLe257oHY9fVQ07Z&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;localityName&#39;</span><span class="p">,</span> <span class="s">&#39;San Francisco&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">&#39;Electronic Frontier Foundation, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">&#39;*.eff.org&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;emailAddress&#39;</span><span class="p">,</span> <span class="s">&#39;hostmaster@eff.org&#39;</span><span class="p">),)),</span>
 <span class="s">&#39;subjectAltName&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;*.eff.org&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;eff.org&#39;</span><span class="p">)),</span>
 <span class="s">&#39;version&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">To validate a certificate for a particular service, you can use the
<a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal"><span class="pre">match_hostname()</span></code></a> function.</p>
</div>
<p>If the <code class="docutils literal"><span class="pre">binary_form</span></code> parameter is <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal"><span class="pre">True</span></code></a>, and a certificate was
provided, this method returns the DER-encoded form of the entire certificate
as a sequence of bytes, or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> if the peer did not provide a
certificate.  Whether the peer provides a certificate depends on the SSL
socket&#8217;s role:</p>
<ul class="simple">
<li>for a client SSL socket, the server will always provide a certificate,
regardless of whether validation was required;</li>
<li>for a server SSL socket, the client will only provide a certificate
when requested by the server; therefore <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">getpeercert()</span></code></a> will return
<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> if you used <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> (rather than
<a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a>).</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>The returned dictionary includes additional items such as <code class="docutils literal"><span class="pre">issuer</span></code>
and <code class="docutils literal"><span class="pre">notBefore</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.cipher">
<code class="descclassname">SSLSocket.</code><code class="descname">cipher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.cipher" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>利用されている暗号の名前、その暗号の利用を定義しているSSLプロトコルのバージョン、利用されている鍵のbit長の3つの値を含むタプルを返します。もし接続が確立されていない場合、 <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.compression">
<code class="descclassname">SSLSocket.</code><code class="descname">compression</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.compression" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return the compression algorithm being used as a string, or <code class="docutils literal"><span class="pre">None</span></code>
if the connection isn&#8217;t compressed.</p>
<p>If the higher-level protocol supports its own compression mechanism,
you can use <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal"><span class="pre">OP_NO_COMPRESSION</span></code></a> to disable SSL-level compression.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.get_channel_binding">
<code class="descclassname">SSLSocket.</code><code class="descname">get_channel_binding</code><span class="sig-paren">(</span><em>cb_type=&quot;tls-unique&quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.get_channel_binding" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Get channel binding data for current connection, as a bytes object.  Returns
<code class="docutils literal"><span class="pre">None</span></code> if not connected or the handshake has not been completed.</p>
<p>The <em>cb_type</em> parameter allow selection of the desired channel binding
type. Valid channel binding types are listed in the
<a class="reference internal" href="#ssl.CHANNEL_BINDING_TYPES" title="ssl.CHANNEL_BINDING_TYPES"><code class="xref py py-data docutils literal"><span class="pre">CHANNEL_BINDING_TYPES</span></code></a> list.  Currently only the &#8216;tls-unique&#8217; channel
binding, defined by <span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5929.html"><strong>RFC 5929</strong></a>, is supported.  <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> will be
raised if an unsupported channel binding type is requested.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.selected_npn_protocol">
<code class="descclassname">SSLSocket.</code><code class="descname">selected_npn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_npn_protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Returns the protocol that was selected during the TLS/SSL handshake. If
<a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> was not called, or if the other party
does not support NPN, or if the handshake has not yet happened, this will
return <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.unwrap">
<code class="descclassname">SSLSocket.</code><code class="descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.unwrap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Performs the SSL shutdown handshake, which removes the TLS layer from the
underlying socket, and returns the underlying socket object.  This can be
used to go from encrypted operation over a connection to unencrypted.  The
returned socket should always be used for further communication with the
other side of the connection, rather than the original socket.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLSocket.context">
<code class="descclassname">SSLSocket.</code><code class="descname">context</code><a class="headerlink" href="#ssl.SSLSocket.context" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> object this SSL socket is tied to.  If the SSL
socket was created using the top-level <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> function
(rather than <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a>), this is a custom context
object created for this SSL socket.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="ssl-contexts">
<h2>18.2.3. SSL Contexts<a class="headerlink" href="#ssl-contexts" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加.</span></p>
</div>
<p>An SSL context holds various data longer-lived than single SSL connections,
such as SSL configuration options, certificate(s) and private key(s).
It also manages a cache of SSL sessions for server-side sockets, in order
to speed up repeated connections from the same clients.</p>
<dl class="class">
<dt id="ssl.SSLContext">
<em class="property">class </em><code class="descclassname">ssl.</code><code class="descname">SSLContext</code><span class="sig-paren">(</span><em>protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Create a new SSL context.  You must pass <em>protocol</em> which must be one
of the <code class="docutils literal"><span class="pre">PROTOCOL_*</span></code> constants defined in this module.
<a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-data docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> is recommended for maximum interoperability.</p>
</dd></dl>

<p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal"><span class="pre">SSLContext</span></code></a> objects have the following methods and attributes:</p>
<dl class="method">
<dt id="ssl.SSLContext.load_cert_chain">
<code class="descclassname">SSLContext.</code><code class="descname">load_cert_chain</code><span class="sig-paren">(</span><em>certfile</em>, <em>keyfile=None</em>, <em>password=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_cert_chain" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Load a private key and the corresponding certificate.  The <em>certfile</em>
string must be the path to a single file in PEM format containing the
certificate as well as any number of CA certificates needed to establish
the certificate&#8217;s authenticity.  The <em>keyfile</em> string, if present, must
point to a file containing the private key in.  Otherwise the private
key will be taken from <em>certfile</em> as well.  See the discussion of
<a class="reference internal" href="#ssl-certificates"><span>証明書</span></a> for more information on how the certificate
is stored in the <em>certfile</em>.</p>
<p>The <em>password</em> argument may be a function to call to get the password for
decrypting the private key.  It will only be called if the private key is
encrypted and a password is necessary.  It will be called with no arguments,
and it should return a string, bytes, or bytearray.  If the return value is
a string it will be encoded as UTF-8 before using it to decrypt the key.
Alternatively a string, bytes, or bytearray value may be supplied directly
as the <em>password</em> argument.  It will be ignored if the private key is not
encrypted and no password is needed.</p>
<p>If the <em>password</em> argument is not specified and a password is required,
OpenSSL&#8217;s built-in password prompting mechanism will be used to
interactively prompt the user for a password.</p>
<p>An <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> is raised if the private key doesn&#8217;t
match with the certificate.</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>New optional argument <em>password</em>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_verify_locations">
<code class="descclassname">SSLContext.</code><code class="descname">load_verify_locations</code><span class="sig-paren">(</span><em>cafile=None</em>, <em>capath=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_verify_locations" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Load a set of &#8220;certification authority&#8221; (CA) certificates used to validate
other peers&#8217; certificates when <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal"><span class="pre">verify_mode</span></code></a> is other than
<a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal"><span class="pre">CERT_NONE</span></code></a>.  At least one of <em>cafile</em> or <em>capath</em> must be specified.</p>
<p>The <em>cafile</em> string, if present, is the path to a file of concatenated
CA certificates in PEM format. See the discussion of
<a class="reference internal" href="#ssl-certificates"><span>証明書</span></a> for more information about how to arrange the
certificates in this file.</p>
<p>The <em>capath</em> string, if present, is
the path to a directory containing several CA certificates in PEM format,
following an <a class="reference external" href="http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html">OpenSSL specific layout</a>.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_default_verify_paths">
<code class="descclassname">SSLContext.</code><code class="descname">set_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_default_verify_paths" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Load a set of default &#8220;certification authority&#8221; (CA) certificates from
a filesystem path defined when building the OpenSSL library.  Unfortunately,
there&#8217;s no easy way to know whether this method succeeds: no error is
returned if no certificates are to be found.  When the OpenSSL library is
provided as part of the operating system, though, it is likely to be
configured properly.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ciphers">
<code class="descclassname">SSLContext.</code><code class="descname">set_ciphers</code><span class="sig-paren">(</span><em>ciphers</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ciphers" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Set the available ciphers for sockets created with this context.
It should be a string in the <a class="reference external" href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">OpenSSL cipher list format</a>.
If no cipher can be selected (because compile-time options or other
configuration forbids use of all the specified ciphers), an
<a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal"><span class="pre">SSLError</span></code></a> will be raised.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">when connected, the <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.cipher()</span></code></a> method of SSL sockets will
give the currently selected cipher.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_npn_protocols">
<code class="descclassname">SSLContext.</code><code class="descname">set_npn_protocols</code><span class="sig-paren">(</span><em>protocols</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_npn_protocols" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Specify which protocols the socket should advertise during the SSL/TLS
handshake. It should be a list of strings, like <code class="docutils literal"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code>,
ordered by preference. The selection of a protocol will happen during the
handshake, and will play out according to the <a class="reference external" href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg">NPN draft specification</a>. After a
successful handshake, the <a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.selected_npn_protocol()</span></code></a> method will
return the agreed-upon protocol.</p>
<p>This method will raise <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> if <a class="reference internal" href="#ssl.HAS_NPN" title="ssl.HAS_NPN"><code class="xref py py-data docutils literal"><span class="pre">HAS_NPN</span></code></a> is
False.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.load_dh_params">
<code class="descclassname">SSLContext.</code><code class="descname">load_dh_params</code><span class="sig-paren">(</span><em>dhfile</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_dh_params" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Load the key generation parameters for Diffie-Helman (DH) key exchange.
Using DH key exchange improves forward secrecy at the expense of
computational resources (both on the server and on the client).
The <em>dhfile</em> parameter should be the path to a file containing DH
parameters in PEM format.</p>
<p>This setting doesn&#8217;t apply to client sockets.  You can also use the
<a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal"><span class="pre">OP_SINGLE_DH_USE</span></code></a> option to further improve security.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.set_ecdh_curve">
<code class="descclassname">SSLContext.</code><code class="descname">set_ecdh_curve</code><span class="sig-paren">(</span><em>curve_name</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ecdh_curve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key
exchange.  ECDH is significantly faster than regular DH while arguably
as secure.  The <em>curve_name</em> parameter should be a string describing
a well-known elliptic curve, for example <code class="docutils literal"><span class="pre">prime256v1</span></code> for a widely
supported curve.</p>
<p>This setting doesn&#8217;t apply to client sockets.  You can also use the
<a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a> option to further improve security.</p>
<p>This method is not available if <a class="reference internal" href="#ssl.HAS_ECDH" title="ssl.HAS_ECDH"><code class="xref py py-data docutils literal"><span class="pre">HAS_ECDH</span></code></a> is False.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">SSL/TLS &amp; Perfect Forward Secrecy</a></dt>
<dd>Vincent Bernat.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.wrap_socket">
<code class="descclassname">SSLContext.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>server_side=False</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>server_hostname=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_socket" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Wrap an existing Python socket <em>sock</em> and return an <code class="xref py py-class docutils literal"><span class="pre">SSLSocket</span></code>
object.  <em>sock</em> must be a <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></code></a> socket; other socket
types are unsupported.</p>
<p>The returned SSL socket is tied to the context, its settings and
certificates.  The parameters <em>server_side</em>, <em>do_handshake_on_connect</em>
and <em>suppress_ragged_eofs</em> have the same meaning as in the top-level
<a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> function.</p>
<p>On client connections, the optional parameter <em>server_hostname</em> specifies
the hostname of the service which we are connecting to.  This allows a
single server to host multiple SSL-based services with distinct certificates,
quite similarly to HTTP virtual hosts.  Specifying <em>server_hostname</em>
will raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> if the OpenSSL library doesn&#8217;t have support
for it (that is, if <a class="reference internal" href="#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal"><span class="pre">HAS_SNI</span></code></a> is <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>).  Specifying
<em>server_hostname</em> will also raise a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> if <em>server_side</em>
is true.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLContext.session_stats">
<code class="descclassname">SSLContext.</code><code class="descname">session_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.session_stats" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Get statistics about the SSL sessions created or managed by this context.
A dictionary is returned which maps the names of each <a class="reference external" href="http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html">piece of information</a> to their
numeric values.  For example, here is the total number of hits and misses
in the session cache since the context was created:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">session_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="p">[</span><span class="s">&#39;hits&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s">&#39;misses&#39;</span><span class="p">]</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.options">
<code class="descclassname">SSLContext.</code><code class="descname">options</code><a class="headerlink" href="#ssl.SSLContext.options" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An integer representing the set of SSL options enabled on this context.
The default value is <a class="reference internal" href="#ssl.OP_ALL" title="ssl.OP_ALL"><code class="xref py py-data docutils literal"><span class="pre">OP_ALL</span></code></a>, but you can specify other options
such as <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal"><span class="pre">OP_NO_SSLv2</span></code></a> by ORing them together.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">With versions of OpenSSL older than 0.9.8m, it is only possible
to set options, not to clear them.  Attempting to clear an option
(by resetting the corresponding bits) will raise a <code class="docutils literal"><span class="pre">ValueError</span></code>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.protocol">
<code class="descclassname">SSLContext.</code><code class="descname">protocol</code><a class="headerlink" href="#ssl.SSLContext.protocol" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The protocol version chosen when constructing the context.  This attribute
is read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="ssl.SSLContext.verify_mode">
<code class="descclassname">SSLContext.</code><code class="descname">verify_mode</code><a class="headerlink" href="#ssl.SSLContext.verify_mode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Whether to try to verify other peers&#8217; certificates and how to behave
if verification fails.  This attribute must be one of
<a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal"><span class="pre">CERT_NONE</span></code></a>, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal"><span class="pre">CERT_REQUIRED</span></code></a>.</p>
</dd></dl>

<span class="target" id="index-9"></span></div>
<div class="section" id="certificates">
<span id="ssl-certificates"></span><span id="index-10"></span><h2>18.2.4. 証明書<a class="headerlink" href="#certificates" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>証明書を大まかに説明すると、公開鍵/秘密鍵システムの一種です。このシステムでは、各 <em>principal</em> (これはマシン、人、組織などです) は、ユニークな2つの暗号鍵を割り当てられます。1つは公開され、 <em>公開鍵(public key)</em> と呼ばれます。もう一方は秘密にされ、 <em>秘密鍵(private key)</em> と呼ばれます。 2つの鍵は関連しており、片方の鍵で暗号化したメッセージは、もう片方の鍵 <strong>のみ</strong> で復号できます。</p>
<p>証明書は2つの principal の情報を含んでいます。証明書は <em>subject</em> 名とその公開鍵を含んでいます。また、もう一つの principal である <em>発行者(issuer)</em> からの、 subject が本人であることと、その公開鍵が正しいことの宣言(statement)を含んでいます。発行者からの宣言は、その発行者の秘密鍵で署名されています。発行者の秘密鍵は発行者しか知りませんが、誰もがその発行者の公開鍵を利用して宣言を復号し、証明書内の別の情報と比較することで認証することができます。証明書はまた、その証明書が有効である期限に関する情報も含んでいます。この期限は &#8220;notBefore&#8221; と &#8220;notAfter&#8221; と呼ばれる2つのフィールドで表現されています。</p>
<p>Python において証明書を利用する場合、クライアントもサーバーも自分を証明するために証明書を利用することができます。ネットワーク接続の相手側に証明書の提示を要求する事ができ、そのクライアントやサーバーが認証を必要とするならその証明書を認証することができます。認証が失敗した場合、接続は例外を発生させます。認証は下位層のOpenSSLフレームワークが自動的に行います。アプリケーションは認証機構について意識する必要はありません。しかし、アプリケーションは認証プロセスのために幾つかの証明書を提供する必要があるかもしれません。</p>
<p>Python は証明書を格納したファイルを利用します。そのファイルは &#8220;PEM&#8221; (<span class="target" id="index-17"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422</strong></a> 参照) フォーマットという、ヘッダー行とフッター行の間にbase-64エンコードされた形をとっている必要があります。</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<div class="section" id="certificate-chains">
<h3>18.2.4.1. Certificate chains<a class="headerlink" href="#certificate-chains" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Pythonが利用する証明書を格納したファイルは、ときには <em>証明書チェイン(certificate chain)</em> と呼ばれる証明書のシーケンスを格納します。このチェインは、まずクライアントやサーバー自体の principal の証明書で始まらなければなりません。それ以降に続く証明書は、手前の証明書の発行者(issuer)の証明書になり、最後にsubject と発行者が同じ <em>自己署名(self-signed)</em> 証明書で終わります。この最後の証明書は <em>ルート証明書(root certificate</em> と呼ばれます。これらの証明書チェインは1つの証明書ファイルに結合されなければなりません。例えば、3つの証明書からなる証明書チェインがあるとします。私たちのサーバーの証明書から、私たちのサーバーに署名した認証局の証明書、そして認証局の証明書を発行した機関のルート証明書です。</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="ca-certificates">
<h3>18.2.4.2. CA certificates<a class="headerlink" href="#ca-certificates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>もし相手から送られてきた証明書の認証をしたい場合、信頼している各発行者の証明書チェインが入った &#8220;CA certs&#8221; ファイルを提供する必要があります。繰り返しますが、このファイルは単純に、各チェインを結合しただけのものです。認証のために、Pythonはそのファイルの中の最初にマッチしたチェインを利用します。幾つかの &#8220;standard&#8221; ルート証明書が、幾つかの認証機関から入手できます: <a class="reference external" href="http://www.cacert.org/index.php?id=3">CACert.org</a>, <a class="reference external" href="http://www.thawte.com/roots/">Thawte</a>, <a class="reference external" href="http://www.verisign.com/support/roots.html">Verisign</a>, <a class="reference external" href="http://www.PositiveSSL.com/ssl-certificate-support/cert_installation/UTN-USERFirst-Hardware.crt">Positive SSL</a> (python.org が利用しています), <a class="reference external" href="http://www.geotrust.com/resources/root_certificates/index.asp">Equifax and GeoTrust</a>.</p>
<p>一般的に、 SSL3 か TLS1 を利用している場合、&#8221;CA certs&#8221; ファイルに全てのチェインを保存する必要はありません。接続先はそれ自身の証明書からルート証明書までの証明書チェインを送ってくるはずで、&#8221;CA certs&#8221; にはルート証明書だけあれば充分なはずです。証明書チェインを組み立てる方法についてのより詳しい情報は、 <span class="target" id="index-18"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4158.html"><strong>RFC 4158</strong></a> を参照してください。</p>
</div>
<div class="section" id="combined-key-and-certificate">
<h3>18.2.4.3. Combined key and certificate<a class="headerlink" href="#combined-key-and-certificate" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Often the private key is stored in the same file as the certificate; in this
case, only the <code class="docutils literal"><span class="pre">certfile</span></code> parameter to <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.load_cert_chain()</span></code></a>
and <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal"><span class="pre">wrap_socket()</span></code></a> needs to be passed.  If the private key is stored
with the certificate, it should come before the first certificate in
the certificate chain:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</div>
<div class="section" id="self-signed-certificates">
<h3>18.2.4.4. Self-signed certificates<a class="headerlink" href="#self-signed-certificates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SSL暗号化接続サービスを提供するサーバーを建てる場合、適切な証明書を取得するには、認証局から買うなどの幾つかの方法があります。また、自己署名証明書を作るケースもあります。 OpenSSLを使って自己署名証明書を作るには、次のようにします。</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>自己署名証明書の欠点は、それ自身がルート証明書であり、他の人はその証明書を持っていない (そして信頼しない)ことです。</p>
</div>
</div>
<div class="section" id="examples">
<h2>18.2.5. 例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="testing-for-ssl-support">
<h3>18.2.5.1. SSLサポートをテストする<a class="headerlink" href="#testing-for-ssl-support" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>インストールされているPythonがSSLをサポートしているかどうかをテストするために、ユーザーコードは次のイディオムを利用することができます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span> <span class="c"># do something that requires SSL support</span>
</pre></div>
</div>
</div>
<div class="section" id="client-side-operation">
<h3>18.2.5.2. クライアントサイドの処理<a class="headerlink" href="#client-side-operation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>This example connects to an SSL server and prints the server&#8217;s certificate:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">pprint</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="c"># require a certificate from the server</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
                           <span class="n">ca_certs</span><span class="o">=</span><span class="s">&quot;/etc/ca_certs_file&quot;</span><span class="p">,</span>
                           <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">)</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>

<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">ssl_sock</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">())</span>
<span class="c"># note that closing the SSLSocket will also close the underlying socket</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>As of January 6, 2012, the certificate printed by this program looks like
this:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="p">{</span><span class="s">&#39;issuer&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">&#39;US&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">&#39;VeriSign, Inc.&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span> <span class="s">&#39;VeriSign Trust Network&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
              <span class="s">&#39;Terms of use at https://www.verisign.com/rpa (c)06&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span>
              <span class="s">&#39;VeriSign Class 3 Extended Validation SSL SGC CA&#39;</span><span class="p">),)),</span>
 <span class="s">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s">&#39;May 25 23:59:59 2012 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;notBefore&#39;</span><span class="p">:</span> <span class="s">&#39;May 26 00:00:00 2010 GMT&#39;</span><span class="p">,</span>
 <span class="s">&#39;serialNumber&#39;</span><span class="p">:</span> <span class="s">&#39;53D2BEF924A7245E83CA01E46CAA2477&#39;</span><span class="p">,</span>
 <span class="s">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s">&#39;1.3.6.1.4.1.311.60.2.1.3&#39;</span><span class="p">,</span> <span class="s">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;1.3.6.1.4.1.311.60.2.1.2&#39;</span><span class="p">,</span> <span class="s">&#39;Delaware&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;businessCategory&#39;</span><span class="p">,</span> <span class="s">&#39;V1.0, Clause 5.(b)&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;serialNumber&#39;</span><span class="p">,</span> <span class="s">&#39;2497886&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;countryName&#39;</span><span class="p">,</span> <span class="s">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;postalCode&#39;</span><span class="p">,</span> <span class="s">&#39;94043&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;localityName&#39;</span><span class="p">,</span> <span class="s">&#39;Mountain View&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;streetAddress&#39;</span><span class="p">,</span> <span class="s">&#39;487 East Middlefield Road&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s">&#39;VeriSign, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;organizationalUnitName&#39;</span><span class="p">,</span> <span class="s">&#39; Production Security Services&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s">&#39;commonName&#39;</span><span class="p">,</span> <span class="s">&#39;www.verisign.com&#39;</span><span class="p">),)),</span>
 <span class="s">&#39;subjectAltName&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;www.verisign.com&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;verisign.com&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;www.verisign.net&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;verisign.net&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;www.verisign.mobi&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;verisign.mobi&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;www.verisign.eu&#39;</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;DNS&#39;</span><span class="p">,</span> <span class="s">&#39;verisign.eu&#39;</span><span class="p">)),</span>
 <span class="s">&#39;version&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<p>This other example first creates an SSL context, instructs it to verify
certificates sent by peers, and feeds it a set of recognized certificate
authorities (CA):</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s">&quot;/etc/ssl/certs/ca-bundle.crt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(it is assumed your operating system places a bundle of all CA certificates
in <code class="docutils literal"><span class="pre">/etc/ssl/certs/ca-bundle.crt</span></code>; if not, you&#8217;ll get an error and have
to adjust the location)</p>
<p>When you use the context to connect to a server, <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a>
validates the server certificate: it ensures that the server certificate
was signed with one of the CA certificates, and checks the signature for
correctness:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&quot;linuxfr.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<p>You should then fetch the certificate and check its fields for conformity:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s">&quot;linuxfr.org&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Visual inspection shows that the certificate does identify the desired service
(that is, the HTTPS host <code class="docutils literal"><span class="pre">linuxfr.org</span></code>):</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">cert</span><span class="p">)</span>
<span class="go">{&#39;issuer&#39;: (((&#39;organizationName&#39;, &#39;CAcert Inc.&#39;),),</span>
<span class="go">            ((&#39;organizationalUnitName&#39;, &#39;http://www.CAcert.org&#39;),),</span>
<span class="go">            ((&#39;commonName&#39;, &#39;CAcert Class 3 Root&#39;),)),</span>
<span class="go"> &#39;notAfter&#39;: &#39;Jun  7 21:02:24 2013 GMT&#39;,</span>
<span class="go"> &#39;notBefore&#39;: &#39;Jun  8 21:02:24 2011 GMT&#39;,</span>
<span class="go"> &#39;serialNumber&#39;: &#39;D3E9&#39;,</span>
<span class="go"> &#39;subject&#39;: (((&#39;commonName&#39;, &#39;linuxfr.org&#39;),),),</span>
<span class="go"> &#39;subjectAltName&#39;: ((&#39;DNS&#39;, &#39;linuxfr.org&#39;),</span>
<span class="go">                    (&#39;othername&#39;, &#39;&lt;unsupported&gt;&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;linuxfr.org&#39;),</span>
<span class="go">                    (&#39;othername&#39;, &#39;&lt;unsupported&gt;&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;dev.linuxfr.org&#39;),</span>
<span class="go">                    (&#39;othername&#39;, &#39;&lt;unsupported&gt;&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;prod.linuxfr.org&#39;),</span>
<span class="go">                    (&#39;othername&#39;, &#39;&lt;unsupported&gt;&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;alpha.linuxfr.org&#39;),</span>
<span class="go">                    (&#39;othername&#39;, &#39;&lt;unsupported&gt;&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;*.linuxfr.org&#39;),</span>
<span class="go">                    (&#39;othername&#39;, &#39;&lt;unsupported&gt;&#39;)),</span>
<span class="go"> &#39;version&#39;: 3}</span>
</pre></div>
</div>
<p>Now that you are assured of its authenticity, you can proceed to talk with
the server:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;HEAD / HTTP/1.0</span><span class="se">\r\n</span><span class="s">Host: linuxfr.org</span><span class="se">\r\n\r\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">))</span>
<span class="go">[b&#39;HTTP/1.1 302 Found&#39;,</span>
<span class="go"> b&#39;Date: Sun, 16 May 2010 13:43:28 GMT&#39;,</span>
<span class="go"> b&#39;Server: Apache/2.2&#39;,</span>
<span class="go"> b&#39;Location: https://linuxfr.org/pub/&#39;,</span>
<span class="go"> b&#39;Vary: Accept-Encoding&#39;,</span>
<span class="go"> b&#39;Connection: close&#39;,</span>
<span class="go"> b&#39;Content-Type: text/html; charset=iso-8859-1&#39;,</span>
<span class="go"> b&#39;&#39;,</span>
<span class="go"> b&#39;&#39;]</span>
</pre></div>
</div>
<p>See the discussion of <a class="reference internal" href="#ssl-security"><span>Security considerations</span></a> below.</p>
</div>
<div class="section" id="server-side-operation">
<h3>18.2.5.3. サーバーサイドの処理<a class="headerlink" href="#server-side-operation" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>For server operation, typically you&#8217;ll need to have a server certificate, and
private key, each in a file.  You&#8217;ll first create a context holding the key
and the certificate, so that clients can check your authenticity.  Then
you&#8217;ll open a socket, bind it to a port, call <code class="xref py py-meth docutils literal"><span class="pre">listen()</span></code> on it, and start
waiting for clients to connect:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="o">=</span><span class="s">&quot;mycertfile&quot;</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="s">&quot;mykeyfile&quot;</span><span class="p">)</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s">&#39;myaddr.mydomain.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>When a client connects, you&#8217;ll call <code class="xref py py-meth docutils literal"><span class="pre">accept()</span></code> on the socket to get the
new socket from the other end, and use the context&#8217;s <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.wrap_socket()</span></code></a>
method to create a server-side SSL socket for the connection:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">while</span> <span class="k">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>そして、 <code class="docutils literal"><span class="pre">connstream</span></code> からデータを読み、クライアントと切断する(あるいはクライアントが切断してくる)まで何か処理をします。</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c"># empty data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c"># we&#39;ll assume do_something returns False</span>
            <span class="c"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c"># finished with client</span>
</pre></div>
</div>
<p>And go back to listening for new client connections (of course, a real server
would probably handle each client connection in a separate thread, or put
the sockets in non-blocking mode and use an event loop).</p>
</div>
</div>
<div class="section" id="notes-on-non-blocking-sockets">
<span id="ssl-nonblocking"></span><h2>18.2.6. Notes on non-blocking sockets<a class="headerlink" href="#notes-on-non-blocking-sockets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>When working with non-blocking sockets, there are several things you need
to be aware of:</p>
<ul>
<li><p class="first">Calling <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> tells you that the OS-level socket can be
read from (or written to), but it does not imply that there is sufficient
data at the upper SSL layer.  For example, only part of an SSL frame might
have arrived.  Therefore, you must be ready to handle <code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.recv()</span></code>
and <code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.send()</span></code> failures, and retry after another call to
<a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a>.</p>
<p>(of course, similar provisions apply when using other primitives such as
<a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal"><span class="pre">poll()</span></code></a>)</p>
</li>
<li><p class="first">The SSL handshake itself will be non-blocking: the
<a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.do_handshake()</span></code></a> method has to be retried until it returns
successfully.  Here is a synopsis using <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal"><span class="pre">select()</span></code></a> to wait for
the socket&#8217;s readiness:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">while</span> <span class="k">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantReadError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantWriteError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="security-considerations">
<span id="ssl-security"></span><h2>18.2.7. Security considerations<a class="headerlink" href="#security-considerations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="verifying-certificates">
<h3>18.2.7.1. Verifying certificates<a class="headerlink" href="#verifying-certificates" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal"><span class="pre">CERT_NONE</span></code></a> is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you&#8217;re talking to.
Therefore, when in client mode, it is highly recommended to use
<a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a>.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
<a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal"><span class="pre">SSLSocket.getpeercert()</span></code></a>, matches the desired service.  For many
protocols and applications, the service can be identified by the hostname;
in this case, the <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal"><span class="pre">match_hostname()</span></code></a> function can be used.</p>
<p>In server mode, if you want to authenticate your clients using the SSL layer
(rather than using a higher-level authentication mechanism), you&#8217;ll also have
to specify <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> and similarly check the client certificate.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">In client mode, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal"><span class="pre">CERT_OPTIONAL</span></code></a> and <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal"><span class="pre">CERT_REQUIRED</span></code></a> are
equivalent unless anonymous ciphers are enabled (they are disabled
by default).</p>
</div>
</div></blockquote>
</div>
<div class="section" id="protocol-versions">
<h3>18.2.7.2. Protocol versions<a class="headerlink" href="#protocol-versions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SSL version 2 is considered insecure and is therefore dangerous to use.  If
you want maximum compatibility between clients and servers, it is recommended
to use <a class="reference internal" href="#ssl.PROTOCOL_SSLv23" title="ssl.PROTOCOL_SSLv23"><code class="xref py py-const docutils literal"><span class="pre">PROTOCOL_SSLv23</span></code></a> as the protocol version and then disable
SSLv2 explicitly using the <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-data docutils literal"><span class="pre">SSLContext.options</span></code></a> attribute:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">options</span> <span class="o">|=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv2</span>
</pre></div>
</div>
<p>The SSL context created above will allow SSLv3 and TLSv1 connections, but
not SSLv2.</p>
</div>
<div class="section" id="cipher-selection">
<h3>18.2.7.3. Cipher selection<a class="headerlink" href="#cipher-selection" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal"><span class="pre">SSLContext.set_ciphers()</span></code></a> method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice.  For example:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">set_ciphers</span><span class="p">(</span><span class="s">&#39;HIGH:!aNULL:!eNULL&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">!aNULL:!eNULL</span></code> part of the cipher spec is necessary to disable ciphers
which don&#8217;t provide both encryption and authentication.  Be sure to read
OpenSSL&#8217;s documentation about the <a class="reference external" href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">cipher list
format</a>.
If you want to check which ciphers are enabled by a given cipher list,
use the <code class="docutils literal"><span class="pre">openssl</span> <span class="pre">ciphers</span></code> command on your system.</p>
</div>
<div class="section" id="multi-processing">
<h3>18.2.7.4. Multi-processing<a class="headerlink" href="#multi-processing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If using this module as part of a multi-processed application (using,
for example the <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> or <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal"><span class="pre">concurrent.futures</span></code></a> modules),
be aware that OpenSSL&#8217;s internal random number generator does not properly
handle forked processes.  Applications must change the PRNG state of the
parent process if they use any SSL feature with <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal"><span class="pre">os.fork()</span></code></a>.  Any
successful call of <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal"><span class="pre">RAND_add()</span></code></a>, <a class="reference internal" href="#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal"><span class="pre">RAND_bytes()</span></code></a> or
<a class="reference internal" href="#ssl.RAND_pseudo_bytes" title="ssl.RAND_pseudo_bytes"><code class="xref py py-func docutils literal"><span class="pre">RAND_pseudo_bytes()</span></code></a> is sufficient.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal"><span class="pre">socket.socket</span></code></a> クラス</dt>
<dd><p class="first last">下位レイヤーの <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> クラスのドキュメント</p>
</dd>
<dt><a class="reference external" href="http://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html">SSL/TLS Strong Encryption: An Introduction</a></dt>
<dd>Intro from the Apache webserver documentation</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1422">RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</a></dt>
<dd>Steve Kent</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1750">RFC 1750: Randomness Recommendations for Security</a></dt>
<dd>D. Eastlake et. al.</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc3280">RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a></dt>
<dd>Housley et. al.</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc4366">RFC 4366: Transport Layer Security (TLS) Extensions</a></dt>
<dd>Blake-Wilson et. al.</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">18.2. <code class="docutils literal"><span class="pre">ssl</span></code> &#8212; ソケットオブジェクトに対する TLS/SSL ラッパー</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">18.2.1. 関数、定数、例外</a><ul>
<li><a class="reference internal" href="#socket-creation">18.2.1.1. Socket creation</a></li>
<li><a class="reference internal" href="#random-generation">18.2.1.2. Random generation</a></li>
<li><a class="reference internal" href="#certificate-handling">18.2.1.3. Certificate handling</a></li>
<li><a class="reference internal" href="#constants">18.2.1.4. 定数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-sockets">18.2.2. SSL ソケット</a></li>
<li><a class="reference internal" href="#ssl-contexts">18.2.3. SSL Contexts</a></li>
<li><a class="reference internal" href="#certificates">18.2.4. 証明書</a><ul>
<li><a class="reference internal" href="#certificate-chains">18.2.4.1. Certificate chains</a></li>
<li><a class="reference internal" href="#ca-certificates">18.2.4.2. CA certificates</a></li>
<li><a class="reference internal" href="#combined-key-and-certificate">18.2.4.3. Combined key and certificate</a></li>
<li><a class="reference internal" href="#self-signed-certificates">18.2.4.4. Self-signed certificates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">18.2.5. 例</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">18.2.5.1. SSLサポートをテストする</a></li>
<li><a class="reference internal" href="#client-side-operation">18.2.5.2. クライアントサイドの処理</a></li>
<li><a class="reference internal" href="#server-side-operation">18.2.5.3. サーバーサイドの処理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-on-non-blocking-sockets">18.2.6. Notes on non-blocking sockets</a></li>
<li><a class="reference internal" href="#security-considerations">18.2.7. Security considerations</a><ul>
<li><a class="reference internal" href="#verifying-certificates">18.2.7.1. Verifying certificates</a></li>
<li><a class="reference internal" href="#protocol-versions">18.2.7.2. Protocol versions</a></li>
<li><a class="reference internal" href="#cipher-selection">18.2.7.3. Cipher selection</a></li>
<li><a class="reference internal" href="#multi-processing">18.2.7.4. Multi-processing</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="socket.html"
                        title="前の章へ">18.1. <code class="docutils literal"><span class="pre">socket</span></code> &#8212; 低レベルネットワークインターフェース</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="asyncore.html"
                        title="次の章へ">18.3. <code class="docutils literal"><span class="pre">asyncore</span></code> &#8212; 非同期ソケットハンドラ</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/ssl.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="asyncore.html" title="18.3. asyncore — 非同期ソケットハンドラ"
             >次へ</a> |</li>
        <li class="right" >
          <a href="socket.html" title="18.1. socket — 低レベルネットワークインターフェース"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.3.6</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >18. プロセス間通信とネットワーク</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>