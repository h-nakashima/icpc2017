<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>31.5. importlib – import の実装 &mdash; Python 3.4.3 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.4.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 ドキュメント" href="../contents.html" />
    <link rel="up" title="31. モジュールのインポート" href="modules.html" />
    <link rel="next" title="32. Python言語サービス" href="language.html" />
    <link rel="prev" title="31.4. runpy — Python モジュールの位置特定と実行" href="runpy.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="language.html" title="32. Python言語サービス"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="31.4. runpy — Python モジュールの位置特定と実行"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">31. モジュールのインポート</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1>31.5. <a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a> &#8211; <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> の実装<a class="headerlink" href="#module-importlib" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加.</span></p>
</div>
<div class="section" id="introduction">
<h2>31.5.1. はじめに<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal"><span class="pre">importlib</span></code></a> パッケージの目的は2つあります。1つ目は Python ソースコード中にある <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文の(そして、拡張として、 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 関数の)実装を提供することです。このパッケージは <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文の、どの Python インタープリターでも動作する実装を提供します。また、 Python 以外の言語で実装されたどの実装よりも把握しやすい実装を提供します。</p>
<p>2つ目の目的は、このパッケージが公開している <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> を実装するための要素を利用して、(<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> として知られる) import プロセスで動作するカスタムのオブジェクトを実装しやすくすることです。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span>import 文</span></a></dt>
<dd><p class="first last"><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文の言語リファレンス。</p>
</dd>
<dt><a class="reference external" href="http://legacy.python.org/doc/essays/packages.html">パッケージ仕様</a></dt>
<dd><p class="first last">パッケージの元の仕様。幾つかの動作はこの仕様が書かれた頃から変更されています (例: <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> で <code class="docutils literal"><span class="pre">None</span></code> に基づくリダイレクト)。</p>
</dd>
<dt><a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 関数</dt>
<dd><p class="first last"><a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文はこの関数のシンタックスシュガーです。</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></dt>
<dd><p class="first last">大文字小文字を区別しないプラットフォームでの import</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></dt>
<dd><p class="first last">Python のソースコードのエンコーディング</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></dt>
<dd><p class="first last">新しい import フック</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a></dt>
<dd><p class="first last">複数行の、および絶対/相対の import</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></dt>
<dd><p class="first last">main モジュールの明示的な相対 import</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a></dt>
<dd>A ModuleSpec Type for the Import System</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></dt>
<dd><p class="first last">デフォルトのソースエンコーディングとして UTF-8 を使用</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></dt>
<dd><p class="first last">PYC リポジトリディレクトリ</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="functions">
<h2>31.5.2. 関数<a class="headerlink" href="#functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="function">
<dt id="importlib.__import__">
<code class="descclassname">importlib.</code><code class="descname">__import__</code><span class="sig-paren">(</span><em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>組み込みの <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> 関数の実装です。</p>
</dd></dl>

<dl class="function">
<dt id="importlib.import_module">
<code class="descclassname">importlib.</code><code class="descname">import_module</code><span class="sig-paren">(</span><em>name</em>, <em>package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールを import します。<em>name</em> 引数は、import するモジュールを絶対または相対表現 (例えば <code class="docutils literal"><span class="pre">pkg.mod</span></code> または <code class="docutils literal"><span class="pre">..mod</span></code>) で指定します。name が相対表現で与えられたら、<em>package</em> 引数を、パッケージ名を解決するためのアンカーとなるパッケージの名前に設定する必要があります (例えば <code class="docutils literal"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code> は <code class="docutils literal"><span class="pre">pkg.mod</span></code> を import します)。</p>
<p><a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code></a> 関数は <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal"><span class="pre">importlib.__import__()</span></code></a> を単純化するラッパーとしてはたらきます。つまり、この関数の全ての意味は <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal"><span class="pre">importlib.__import__()</span></code></a> から受け継いでいます。ですから import が発生するパッケージが前もって import されている必要があります。 (すなわち <em>package</em> は先に import されている必要があります)。最も重要な違いは、 <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code></a> が指定されたパッケージやモジュール (例えば <code class="docutils literal"><span class="pre">pkg.mod</span></code>) を返すのに対し、 <a class="reference internal" href="functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal"><span class="pre">__import__()</span></code></a> はトップレベルのパッケージやモジュール (例えば <code class="docutils literal"><span class="pre">pkg</span></code>) を返すことです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>親パッケージは自動的に import されます。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.find_loader">
<code class="descclassname">importlib.</code><code class="descname">find_loader</code><span class="sig-paren">(</span><em>name</em>, <em>path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.find_loader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールのローダーを、オプションで指定された <em>path</em> 内から、検索します。モジュールが <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal"><span class="pre">sys.modules</span></code></a> にあれば、 <code class="docutils literal"><span class="pre">sys.modules[name].__loader__</span></code> が返されます (ただしローダーが <code class="docutils literal"><span class="pre">None</span></code> であるか設定されていなければ <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます)。なければ、 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal"><span class="pre">sys.meta_path</span></code></a> を使った検索がなされます。ローダーが見つからなければ <code class="docutils literal"><span class="pre">None</span></code> が返ります。</p>
<p>ドットのついた名前表記は、親モジュールのロードが必要なときに暗黙に import しないので、望ましくありません。サブモジュールを適切に import するには、そのサブモジュールの全ての親パッケージを import し、<em>path</em> に正しい引数を使ってください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><code class="docutils literal"><span class="pre">__loader__</span></code> が set でない場合、<code class="docutils literal"><span class="pre">None</span></code> に設定されているときと同様に :<cite>ValueError</cite> を送出します。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.find_spec()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.invalidate_caches">
<code class="descclassname">importlib.</code><code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> に保存されたファインダの内部キャッシュを無効にします。ファインダが <code class="docutils literal"><span class="pre">invalidate_caches()</span></code> を実装していれば、無効化を行うためにそれが呼び出されます。すべてのファインダが新しいモジュールの存在に気づくことを保証しているプログラムの実行中に、モジュールが作成またはインストールされたなら、この関数が呼び出されるべきです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.reload">
<code class="descclassname">importlib.</code><code class="descname">reload</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Reload a previously imported <em>module</em>.  The argument must be a module object,
so it must have been successfully imported before.  This is useful if you
have edited the module source file using an external editor and want to try
out the new version without leaving the Python interpreter.  The return value
is the module object (which can be different if re-importing causes a
different object to be placed in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a>).</p>
<p><a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal"><span class="pre">reload()</span></code></a> が実行された場合:</p>
<ul class="simple">
<li>Python module&#8217;s code is recompiled and the module-level code re-executed,
defining a new set of objects which are bound to names in the module&#8217;s
dictionary by reusing the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> which originally loaded the
module.  The <code class="docutils literal"><span class="pre">init</span></code> function of extension modules is not called a second
time.</li>
<li><p class="first">Python における他のオブジェクトと同様、以前のオブジェクトのメモリ領域は、参照カウントがゼロにならないかぎり再利用されません。</p>
</li>
<li><p class="first">モジュール名前空間内の名前は新しいオブジェクト (または更新されたオブジェクト) を指すよう更新されます。</p>
</li>
<li><p class="first">以前のオブジェクトが (外部の他のモジュールなどからの) 参照を受けている場合、それらを新たなオブジェクトに再束縛し直すことはないので、必要なら自分で名前空間を更新しなければなりません。</p>
</li>
</ul>
<p>いくつか補足説明があります:</p>
<p>モジュールが再ロードされた際、その辞書 (モジュールのグローバル変数を含みます) はそのまま残ります。名前の再定義を行うと、以前の定義を上書きするので、一般的には問題はありません。新たなバージョンのモジュールが古いバージョンで定義された名前を定義していない場合、古い定義がそのまま残ります。辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、この機能をモジュールを有効性を引き出すために使うことができます &#8212; つまり、 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 文を使えば、必要に応じてテーブルがあるかどうかをテストし、その初期化を飛ばすことができます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>It is generally not very useful to reload built-in or dynamically loaded
modules.  Reloading <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a>, <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal"><span class="pre">builtins</span></code></a> and other
key modules is not recommended.  In many cases extension modules are not
designed to be initialized more than once, and may fail in arbitrary ways
when reloaded.</p>
<p>If a module imports objects from another module using <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> ...
<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ..., calling <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal"><span class="pre">reload()</span></code></a> for the other module does not
redefine the objects imported from it &#8212; one way around this is to
re-execute the <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal"><span class="pre">from</span></code></a> statement, another is to use <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a>
and qualified names (<em>module.name</em>) instead.</p>
<p>あるモジュールがクラスのインスタンスを生成している場合、そのクラスを定義しているモジュールの再ロードはそれらインスタンスのメソッド定義に影響しません &#8212; それらは古いクラス定義を使い続けます。これは派生クラスの場合でも同じです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2>31.5.3. <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal"><span class="pre">importlib.abc</span></code></a> &#8211; import に関連する抽象基底クラス<a class="headerlink" href="#module-importlib.abc" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal"><span class="pre">importlib.abc</span></code></a> モジュールは、 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> に使われる全てのコア抽象基底クラス含みます。コア抽象基底クラスの実装を助けるために、コア ABC のサブクラスもいくつか提供されています。</p>
<p>ABC 階層:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">|</span>    <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="class">
<dt id="importlib.abc.Finder">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">Finder</code><a class="headerlink" href="#importlib.abc.Finder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> を表す抽象基底クラスです。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.3 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">MetaPathFinder</span></code></a> または <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal"><span class="pre">PathEntryFinder</span></code></a> を使ってください。</p>
</div>
<dl class="method">
<dt id="importlib.abc.Finder.find_module">
<code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Finder.find_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたモジュールの <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> を検索するための抽象メソッドです。もとは <span class="target" id="index-25"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> で仕様が定められ、このメソッドは <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> の中およびパスに基づく import サブシステムの中で使用することを意図されています。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>呼び出されたときに <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を送出する代わりに <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.MetaPathFinder">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">MetaPathFinder</code><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> を表す抽象基底クラスです。互換性のため、これは <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal"><span class="pre">Finder</span></code></a> のサブクラスです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_spec">
<code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An abstract method for finding a <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for
the specified module.  If this is a top-level import, <em>path</em> will
be <code class="docutils literal"><span class="pre">None</span></code>.  Otherwise, this is a search for a subpackage or
module and <em>path</em> will be the value of <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a> from the
parent package. If a spec cannot be found, <code class="docutils literal"><span class="pre">None</span></code> is returned.
When passed in, <code class="docutils literal"><span class="pre">target</span></code> is a module object that the finder may
use to make a more educated about what spec to return.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.find_module">
<code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたモジュールの <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> を検索するためのレガシーなメソッドです。これはトップレベルの import なら、 <em>path</em> は <code class="docutils literal"><span class="pre">None</span></code> になります。そうでなければ、これはサブパッケージまたはモジュールの検索で、 <em>path</em> は親パッケージの <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a> の値になります。ローダーが見つからなければ、 <code class="docutils literal"><span class="pre">None</span></code> が返されます。</p>
<p><a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> が定義された場合、後方互換な機能が提供されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Returns <code class="docutils literal"><span class="pre">None</span></code> when called instead of raising
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>. Can use <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> to provide
functionality.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.MetaPathFinder.invalidate_caches">
<code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このファインダで使われている内部キャッシュがあれば無効にするオプションのメソッドです。 <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal"><span class="pre">sys.meta_path</span></code></a> 上の全てのファインダのキャッシュを無効化する際、 <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal"><span class="pre">importlib.invalidate_caches()</span></code></a> によって使われます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>呼び出されたときに <code class="docutils literal"><span class="pre">NotImplemented</span></code> を送出する代わりに <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.PathEntryFinder">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">PathEntryFinder</code><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> を表す抽象基底クラスです。 <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">MetaPathFinder</span></code></a> と似ているところがありますが、 <code class="docutils literal"><span class="pre">PathEntryFinder</span></code> は <code class="xref py py-class docutils literal"><span class="pre">PathFinder</span></code> の与えるパスに基づく import サブシステムの中でのみ使うことが意図されています。この ABC は互換性の理由だけのために、 <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal"><span class="pre">Finder</span></code></a> のサブクラスにしてあります。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_spec">
<code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An abstract method for finding a <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for
the specified module.  The finder will search for the module only
within the <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a> to which it is assigned.  If a spec
cannot be found, <code class="docutils literal"><span class="pre">None</span></code> is returned.  When passed in, <code class="docutils literal"><span class="pre">target</span></code>
is a module object that the finder may use to make a more educated
about what spec to return.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_loader">
<code class="descname">find_loader</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_loader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたモジュールの <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> を検索する抽象メソッドです。 <code class="docutils literal"><span class="pre">(loader,</span> <span class="pre">portion)</span></code> の 2-タプルを返します。ただし <code class="docutils literal"><span class="pre">portion</span></code> は名前空間パッケージの部分に寄与するファイルシステム上の場所のシーケンスです。 loader は名前空間パッケージへのファイルシステム上の場所の寄与を表す <code class="docutils literal"><span class="pre">portion</span></code> を明記するとき <code class="docutils literal"><span class="pre">None</span></code> にできます。loader が名前空間パッケージの一部ではないことを明記するとき <code class="docutils literal"><span class="pre">portion</span></code> に空のリストが使えます。 <code class="docutils literal"><span class="pre">loader</span></code> が <code class="docutils literal"><span class="pre">None</span></code> で <code class="docutils literal"><span class="pre">portion</span></code> が空のリストなら、名前空間パッケージのローダーや場所が見つかりませんでした (すなわち、モジュールの何も見つかりませんでした)。</p>
<p><a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> が定義された場合、後方互換な機能が提供されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を送出する代わりに <code class="docutils literal"><span class="pre">(None,</span> <span class="pre">[])</span></code> を返します。機能を提供できる場合 <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> を使用します。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.find_module">
<code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Finder.find_module" title="importlib.abc.Finder.find_module"><code class="xref py py-meth docutils literal"><span class="pre">Finder.find_module()</span></code></a> の具象実装で、 <code class="docutils literal"><span class="pre">self.find_loader(fullname)[0]</span></code> と等価です。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.PathEntryFinder.invalidate_caches">
<code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このファインダで使われている内部キャッシュがあれば無効にするオプションのメソッドです。キャッシュされた全てのファインダの無効化する際、 <code class="xref py py-meth docutils literal"><span class="pre">PathFinder.invalidate_caches()</span></code> によって使われます。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.Loader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">Loader</code><a class="headerlink" href="#importlib.abc.Loader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> の抽象基底クラスです。ローダーの厳密な定義は <span class="target" id="index-26"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> を参照してください。</p>
<dl class="method">
<dt id="importlib.abc.Loader.create_module">
<code class="descname">create_module</code><span class="sig-paren">(</span><em>spec</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An optional method that returns the module object to use when
importing a module.  create_module() may also return <code class="docutils literal"><span class="pre">None</span></code>,
indicating that the default module creation should take place
instead.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.exec_module">
<code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>An abstract method that executes the module in its own namespace
when a module is imported or reloaded.  The module should already
be initialized when exec_module() is called.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールをロードするためのレガシーなメソッドです。モジュールがロードできなければ <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出し、ロードできればロードされたモジュールを返します。</p>
<p>要求されたモジュールが既に <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に存在したなら、そのモジュールが使われリロードされる必要があります。存在しなければ、import からの再帰を防ぐため、ローダーはロードが始まる前に新しいモジュールを作成して <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に挿入する必要があります。ローダーがモジュールを挿入した後にロードが失敗したなら、ローダーはそのモジュールを <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> から削除する必要があります。ローダーが実行を始める前に既に <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> にあったモジュールは、そのままにします (<a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.module_for_loader()</span></code></a> を参照してください)。</p>
<p>ローダーはモジュールにいくつかの属性を設定する必要があります。(なお、これらの属性には、モジュールがリロードされた際に変化するものがあります):</p>
<ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a></dt>
<dd><p class="first last">モジュールの名前。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a></dt>
<dd><p class="first last">モジュールのデータが保存されている場所へのパスです (組み込みモジュールには設定されません)。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="../reference/import.html#__cached__" title="__cached__"><code class="xref py py-attr docutils literal"><span class="pre">__cached__</span></code></a></dt>
<dd><p class="first last">モジュールのコンパイルされた版が保存されている (べき) 場所へのパスです (この属性が適切でないときには設定されません)。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a></dt>
<dd><p class="first last">パッケージ内の検索パスを指定する文字列のリストです。この属性はモジュールには設定されません。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a></dt>
<dd><p class="first last">モジュールやパッケージの親パッケージです。そのモジュールがトップレベルなら、空文字列の値をとります。 <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.module_for_loader()</span></code></a> デコレータで、<a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> の詳細を扱えます。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a></dt>
<dd><p class="first last">The loader used to load the module. The
<a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal"><span class="pre">importlib.util.module_for_loader()</span></code></a> decorator can handle the
details for <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>.</p>
</dd>
</dl>
</li>
</ul>
<p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a> が利用可能な場合、後方互換な機能が提供されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Raise <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> when called instead of
<a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>. Functionality provided when
<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a> is available.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>The recommended API for loading a module is <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a>
(and optionally <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal"><span class="pre">create_module()</span></code></a>).  Loaders should implement
it instead of load_module().  The import machinery takes care of
all the other responsibilities of load_module() when exec_module()
is implemented.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.Loader.module_repr">
<code class="descname">module_repr</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.module_repr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A legacy method which when implemented calculates and returns the
given module&#8217;s repr, as a string. The module type&#8217;s default repr() will
use the result of this method as appropriate.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Made optional instead of an abstractmethod.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>インポート機構はこれを自動的に考慮するようになりました。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ResourceLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">ResourceLoader</code><a class="headerlink" href="#importlib.abc.ResourceLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> の抽象基底クラスで、ストレージバックエンドから任意のリソースをロードするオプションの <span class="target" id="index-27"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> プロトコルを実装します。</p>
<dl class="method">
<dt id="importlib.abc.ResourceLoader.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>path</em> に割り当てられたデータのバイト列を返す抽象メソッドです。任意のデータを保管できるファイル的なストレージバックエンドをもつローダーは、この抽象メソッドを実装して、保管されたデータに直接アクセスさせるようにできます。 <em>path</em> が見つからなければ <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> を送出する必要があります。 <em>path</em> は、モジュールの <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a> 属性を使って、またはパッケージの <a class="reference internal" href="../reference/import.html#__path__" title="__path__"><code class="xref py py-attr docutils literal"><span class="pre">__path__</span></code></a> の要素を使って、構成されることが期待されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> の代わりに <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> を送出します。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.InspectLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">InspectLoader</code><a class="headerlink" href="#importlib.abc.InspectLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> の抽象基底クラスで、ローダーがモジュールを検査するためのオプションの <span class="target" id="index-28"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> プロトコルを実装します。</p>
<dl class="method">
<dt id="importlib.abc.InspectLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールの <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-class docutils literal"><span class="pre">code</span></code></a> オブジェクトを返すか、 (例えば組み込みモジュールの場合に) モジュールがコードオブジェクトを持たなければ <code class="docutils literal"><span class="pre">None</span></code> を返します。ローダーが要求されたモジュールを見つけられなかったなら、 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出します。。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">メソッドにはデフォルトの実装がありますが、可能な場合はパフォーマンスのためにオーバーライドされるかもしれません。</p>
</div>
<div class="versionchanged" id="index-12">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>抽象および具象実装は最早提供されません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールのソースを返す抽象メソッドです。これは認識された全ての行セパレータを <code class="docutils literal"><span class="pre">'\n'</span></code> 文字に変換し、 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> を使ったテキスト文字列として返されます。利用できるソースがなければ (例えば組み込みモジュール)、 <code class="docutils literal"><span class="pre">None</span></code> を返します。指定されたモジュールが見つからなければ、 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出します。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> の代わりに <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールがパッケージであれば True を返し、そうでなければ False を返す抽象メソッドです。 <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> がモジュールを見つけられなかったなら <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> が送出されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> の代わりに <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.source_to_code">
<code class="descname">source_to_code</code><span class="sig-paren">(</span><em>data</em>, <em>path='&lt;string&gt;'</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Python のソースからコードオブジェクトを作ります。</p>
<p><em>data</em> 引数は <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal"><span class="pre">compile()</span></code></a> 関数がサポートするもの (すなわち文字列かバイト) なら何でも構いません。<em>path</em> 引数はソースコードの元々の場所への &#8220;パス&#8221; でなければなりませんが、抽象概念 (例えば zip ファイル内の場所) でも構いません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.exec_module">
<code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code></a> の実装です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.InspectLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.load_module()</span></code></a> の実装です。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.ExecutionLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">ExecutionLoader</code><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal"><span class="pre">InspectLoader</span></code></a> から継承された抽象基底クラスで、実装されていれば、モジュールをスクリプトとして実行する助けになります。この ABC はオプションの <span class="target" id="index-29"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> プロトコルを表します。</p>
<dl class="method">
<dt id="importlib.abc.ExecutionLoader.get_filename">
<code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたモジュールの <a class="reference internal" href="../reference/import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal"><span class="pre">__file__</span></code></a> の値を返す抽象メソッドです。利用できるパスがなければ、 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> が送出されます。</p>
<p>ソースコードが利用できるなら、そのモジュールのロードにバイトコードが使われたかにかかわらず、このメソッドはそのソースファイルへのパスを返す必要があります。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> の代わりに <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を送出します。</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.FileLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">FileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal"><span class="pre">ResourceLoader</span></code></a> と <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal"><span class="pre">ExecutionLoader</span></code></a> から継承された抽象基底クラスで、 <a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal"><span class="pre">ResourceLoader.get_data()</span></code></a> および <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></code></a> の具象実装を提供します。</p>
<p><em>fullname</em> 引数は、ローダーが解決しようとするモジュールの、完全に解決された名前です。<em>path</em> 引数は、モジュールのファイルへのパスです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.abc.FileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.abc.FileLoader.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローダーが扱えるモジュールの名前です。</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.abc.FileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.abc.FileLoader.path" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールのファイルへのパスです。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>親クラスの <code class="docutils literal"><span class="pre">load_module()</span></code> を呼び出します。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_filename">
<code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.FileLoader.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>path</em> をバイナリファイルとして読み込み、そのバイト列を返します。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.abc.SourceLoader">
<em class="property">class </em><code class="descclassname">importlib.abc.</code><code class="descname">SourceLoader</code><a class="headerlink" href="#importlib.abc.SourceLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソース (オプションでバイトコード) ファイルのロードを実装する抽象基底クラスです。このクラスは、 <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal"><span class="pre">ResourceLoader</span></code></a> と <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal"><span class="pre">ExecutionLoader</span></code></a> の両方を継承し、以下の実装が必要です:</p>
<ul>
<li><p class="first"><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal"><span class="pre">ResourceLoader.get_data()</span></code></a></p>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt>
<dd><p class="first last">ソースファイルへのパスのみを返す必要があります。ソースなしのロードはサポートされていません。</p>
</dd>
</dl>
</li>
</ul>
<p>このクラスでこれらの抽象メソッドを定義することで、バイトコードファイルを追加でサポートします。これらのメソッドを定義しなければ (またはそのモジュールが <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を送出すれば)、このローダーはソースコードに対してのみはたらきます。これらのメソッドを実装することで、ローダーはソースとバイトコードファイル <em>の組み合わせ</em> に対して働きます。バイトコードのみを与えた <em>ソースのない</em> ロードは認められません。バイトコードファイルは、 Python コンパイラによる解析の工程をなくして速度を上げる最適化です。ですから、バイトコード特有の API は公開されていません。</p>
<dl class="method">
<dt id="importlib.abc.SourceLoader.path_stats">
<code class="descname">path_stats</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたパスについてのメタデータを含む <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> を返す、オプションの抽象メソッドです。サポートされる辞書のキーは:</p>
<ul class="simple">
<li><p class="first"><code class="docutils literal"><span class="pre">'mtime'</span></code> (必須): ソースコードの更新時刻を表す整数または浮動小数点数です。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">'size'</span></code> (任意): バイト数で表したソースコードのサイズです。</p>
</li>
</ul>
<p>未来の拡張のため、辞書内の他のキーは無視されます。パスが扱えなければ、 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> が送出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> の代わりに <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> を送出します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.path_mtime">
<code class="descname">path_mtime</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>指定されたパスの更新時刻を返す、オプションの抽象メソッドです。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.3 で撤廃: </span>このメソッドは廃止され、 <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal"><span class="pre">path_stats()</span></code></a> が推奨されます。このモジュールを実装する必要はありませんが、互換性のため現在も利用できます。パスが扱えなければ、 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> が送出されます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> の代わりに <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal"><span class="pre">OSError</span></code></a> を送出します。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>path</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルパスに指定されたバイト列を書き込むオプションの抽象メソッドです。存在しない中間ディレクトリがあれば、自動で作成されます。</p>
<p>パスへの書き込みが読み取り専用のために失敗したとき (<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal"><span class="pre">PermissionError</span></code></a>) 、その例外を伝播させません。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>呼ばれたときに <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> を送出することは最早ありません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.get_code()</span></code></a> の具象実装です。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.exec_module">
<code class="descname">exec_module</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><blockquote>
<div><p><a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code></a> の具象実装です。</p>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">Loader.load_module()</span></code></a> の具象実装です。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal"><span class="pre">exec_module()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.get_source()</span></code></a> の具象実装です。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.abc.SourceLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.is_package()</span></code></a> の具象実装です。モジュールは、次の <em>両方</em> を満たすならパッケージであると決定されます。モジュールの (<a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal"><span class="pre">ExecutionLoader.get_filename()</span></code></a> で与えられる) ファイルパスが、ファイル拡張子を除くと <code class="docutils literal"><span class="pre">__init__</span></code> という名のファイルであること。モジュール名自体が <code class="docutils literal"><span class="pre">__init__</span></code> で終わらないこと。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2>31.5.4. <a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal"><span class="pre">importlib.machinery</span></code></a> &#8211; インポータおよびパスフック<a class="headerlink" href="#module-importlib.machinery" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールには、 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> がモジュールを検索してロードするのに役立つ様々なオブジェクトがあります。</p>
<dl class="attribute">
<dt id="importlib.machinery.SOURCE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">SOURCE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認識されているソースモジュールのファイル接尾辞を表す文字列のリストです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">DEBUG_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最適化されていないバイトコードモジュールのファイル接尾辞を表す文字列のリストです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">OPTIMIZED_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>最適化されたバイトコードモジュールのファイル接尾辞を表す文字列のリストです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.BYTECODE_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認識されているバイトコードモジュールのファイル接尾辞を表す文字列のリストです。 <code class="docutils literal"><span class="pre">__debug__</span></code> の真偽に応じて、 <a class="reference internal" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="importlib.machinery.DEBUG_BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal"><span class="pre">DEBUG_BYTECODE_SUFFIXES</span></code></a> と <a class="reference internal" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal"><span class="pre">OPTIMIZED_BYTECODE_SUFFIXES</span></code></a> のいずれかに設定されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.EXTENSION_SUFFIXES">
<code class="descclassname">importlib.machinery.</code><code class="descname">EXTENSION_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>認識されている最適化された拡張モジュールのファイル接尾辞を表す文字列のリストです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.machinery.all_suffixes">
<code class="descclassname">importlib.machinery.</code><code class="descname">all_suffixes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>標準の import 機構によって認識されている全てのファイル接尾辞を表す文字列の組み合わせられたリストを返します。これが役立つのは、あるファイルシステムパスがモジュールを参照する可能性があるかだけを知りたくて、そのモジュールの種類を詳しく知る必要はないコード (例えば <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal"><span class="pre">inspect.getmodulename()</span></code></a>) です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.BuiltinImporter">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">BuiltinImporter</code><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>組み込みモジュールの <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> です。全ての既知のモジュールは <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal"><span class="pre">sys.builtin_module_names</span></code></a> に列挙されています。このクラスは <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> および <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC を実装します。</p>
<p>インスタンス化を容易にするため、クラスメソッドだけがこのクラスによって定義されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">拡張モジュール C-API での実装により、今のところ BuiltinImporter は <code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code> を実装していません。</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FrozenImporter">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">FrozenImporter</code><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フリーズされたモジュールの <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> このクラスは <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> および <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.InspectLoader</span></code></a> ABC を実装します。</p>
<p>インスタンス化を容易にするため、クラスメソッドだけがこのクラスによって定義されます。</p>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.WindowsRegistryFinder">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">WindowsRegistryFinder</code><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Windows レジストリで宣言されたモジュールの <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> です。このクラスは <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.Finder</span></code></a> を実装します。</p>
<p>インスタンス化を容易にするため、クラスメソッドだけがこのクラスによって定義されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.PathFinder">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">PathFinder</code><a class="headerlink" href="#importlib.machinery.PathFinder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> およびパッケージの <code class="docutils literal"><span class="pre">__path__</span></code> 属性の <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> です。このクラスは <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> を実装します。</p>
<p>インスタンス化を容易にするため、クラスメソッドだけがこのクラスによって定義されます。</p>
<dl class="classmethod">
<dt id="importlib.machinery.PathFinder.find_spec">
<em class="property">classmethod </em><code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal"><span class="pre">sys.path</span></code></a> または定義されていれば <em>path</em> から、 <em>fullname</em> で指定されたモジュールの <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> の検索を試みるクラスメソッドです。検索されるそれぞれの path entry に対して <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> が検査されます。非偽のオブジェクトが見つかれば、それが目的のモジュールを検索するための <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> として使われます。 <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> に目的の entry が見つからなければ、path entry finder のファインダが <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> から検索され、見つかれば、それが <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> に保管されるとともに、モジュールについて問い合わせられます。それでも finder が見つからなければ <code class="docutils literal"><span class="pre">None</span></code> が保管され、また返されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="importlib.machinery.PathFinder.find_module">
<em class="property">classmethod </em><code class="descname">find_module</code><span class="sig-paren">(</span><em>fullname</em>, <em>path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> まわりのレガシーなラッパです。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>代わりに <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal"><span class="pre">find_spec()</span></code></a> を使用してください。</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property">classmethod </em><code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-attr docutils literal"><span class="pre">sys.path_importer_cache</span></code></a> に保管されている全てのファインダに対して <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a> を呼び出します。</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Calls objects in <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal"><span class="pre">sys.path_hooks</span></code></a> with the current working
directory for <code class="docutils literal"><span class="pre">''</span></code> (i.e. the empty string).</p>
</div>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.FileFinder">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">FileFinder</code><span class="sig-paren">(</span><em>path</em>, <em>*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファイルシステムからの結果をキャッシュする <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> の具象実装です。</p>
<p><em>path</em> 引数は検索を担当するファインダーのディレクトリです。</p>
<p><em>loader_details</em> 引数は、可変個の 2 要素タプルで、それぞれがローダーとローダーが認識するファイル接尾辞のシーケンスとを含みます。ローダーは、呼び出し可能でモジュール名と見つかったファイルのパスとの 2 引数を受け付けることを期待されます。</p>
<p>ファインダはモジュール検索のたびに stat を呼び出し、必要に応じてディレクトリの内容をキャッシュすることで、コードキャッシュが古くなっていないことを確かめます。キャッシュの古さはオペレーティングシステムのファイルシステムのステート情報の粒度に依存しますから、モジュールを検索し、新しいファイルを作成し、その後に新しいファイルが表すモジュールを検索する、という競合状態の可能性があります。この操作が stat の呼び出しの粒度に収まるほど速く起こると、モジュールの検索が失敗します。これを防ぐためには、モジュールを動的に作成する際に、必ず <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal"><span class="pre">importlib.invalidate_caches()</span></code></a> を呼び出してください。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.FileFinder.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ファインダが検索されるパスです。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_spec">
<code class="descname">find_spec</code><span class="sig-paren">(</span><em>fullname</em>, <em>target=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Attempt to find the spec to handle <em>fullname</em> within <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.find_loader">
<code class="descname">find_loader</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_loader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> 内で <em>fullname</em> を扱うローダーの検索を試みます。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.FileFinder.invalidate_caches">
<code class="descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>内部キャッシュを完全に消去します。</p>
</dd></dl>

<dl class="classmethod">
<dt id="importlib.machinery.FileFinder.path_hook">
<em class="property">classmethod </em><code class="descname">path_hook</code><span class="sig-paren">(</span><em>*loader_details</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal"><span class="pre">sys.path_hooks</span></code></a> で使用するクロージャを返すクラスメソッドです。クロージャに直接渡された path 引数を直接的に、 <em>loader_details</em> を間接的に使って、 <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal"><span class="pre">FileFinder</span></code></a> のインスタンスが返されます。</p>
<p>クロージャへの引数が存在するディレクトリでなければ、 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> が送出されます。</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourceFileLoader">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">SourceFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.FileLoader</span></code></a> を継承し、その他いくつかのメソッドの具象実装を提供する、 <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.SourceLoader</span></code></a> の具象実装です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このローダーが扱うモジュールの名前です。</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourceFileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソースファイルへのパスです。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> がパッケージを表すとき True を返します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.path_stats">
<code class="descname">path_stats</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a> の具象実装です。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>path</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a> の具象実装です。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourceFileLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> where
specifying the name of the module to load is optional.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.SourcelessFileLoader">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">SourcelessFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バイトコード (すなわちソースコードファイルが存在しない) ファイルをimport できる <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.FileLoader</span></code></a> の具象実装です。</p>
<p>注意として、バイトコードを直接使う (つまりソースコードファイルがない) と、そのモジュールは全ての Python 実装では使用できないし、新しいバージョンの Python ではバイトコードフォーマットが変更されていたら使用できません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローダーが扱うモジュールの名前です。</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.SourcelessFileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>バイトコードファイルへのパスです。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>そのモジュールがパッケージであるかを <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> に基づいて決定します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> から作成された <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> のコードオブジェクトを返します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このローダーが使われたとき、バイトコードファイルのソースがなければ <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.SourcelessFileLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>Concrete implementation of <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> where
specifying the name of the module to load is optional.</p>
</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ExtensionFileLoader">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">ExtensionFileLoader</code><span class="sig-paren">(</span><em>fullname</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張モジュールのための <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.ExecutionLoader</span></code></a> の具象実装です。</p>
<p><em>fullname</em> 引数はローダーがサポートするモジュールの名前を指定します。<em>path</em> 引数は拡張モジュールのファイルへのパスです。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ローダーがサポートするモジュールの名前です。</p>
</dd></dl>

<dl class="attribute">
<dt id="importlib.machinery.ExtensionFileLoader.path">
<code class="descname">path</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張モジュールへのパスです。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.load_module">
<code class="descname">load_module</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.load_module" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>fullname</em> が <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.name" title="importlib.machinery.ExtensionFileLoader.name"><code class="xref py py-attr docutils literal"><span class="pre">name</span></code></a> と同じか <code class="docutils literal"><span class="pre">None</span></code> であるときに限り拡張モジュールをロードします。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">拡張モジュール C-API での実装により、今のところ ExtensionFileLoader は <code class="xref py py-meth docutils literal"><span class="pre">Loader.exec_module()</span></code> を実装していません。</p>
</div>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.is_package">
<code class="descname">is_package</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal"><span class="pre">EXTENSION_SUFFIXES</span></code></a> に基づいて、ファイルパスがパッケージの <code class="docutils literal"><span class="pre">__init__</span></code> モジュールを指していれば <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_code">
<code class="descname">get_code</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張モジュールにコードオブジェクトがなければ <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_source">
<code class="descname">get_source</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>拡張モジュールにソースコードがなければ <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="importlib.machinery.ExtensionFileLoader.get_filename">
<code class="descname">get_filename</code><span class="sig-paren">(</span><em>fullname</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal"><span class="pre">path</span></code></a> を返します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="importlib.machinery.ModuleSpec">
<em class="property">class </em><code class="descclassname">importlib.machinery.</code><code class="descname">ModuleSpec</code><span class="sig-paren">(</span><em>name</em>, <em>loader</em>, <em>*</em>, <em>origin=None</em>, <em>loader_state=None</em>, <em>is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>モジュールのインポートシステム関連の状態の仕様です。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.name">
<code class="descname">name</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal"><span class="pre">__name__</span></code>)</p>
<p>モジュールの完全修飾名を表す文字列です。</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader">
<code class="descname">loader</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal"><span class="pre">__loader__</span></code>)</p>
<p>ロードに使うローダです。名前空間パッケージの場合 None に設定しなければなりません。</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.origin">
<code class="descname">origin</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal"><span class="pre">__file__</span></code>)</p>
<p>モジュールがロードされた場所の名前です。例えば組み込みのモジュールでは &#8220;builtin&#8221;、ソースからロードされたモジュールではファイル名です。通常 &#8220;origin&#8221; は設定されるべきですが、未指定を示す None (デフォルト) かもしれません。</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.submodule_search_locations">
<code class="descname">submodule_search_locations</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal"><span class="pre">__path__</span></code>)</p>
<p>パッケージの場合サブモジュールを見付けるべき場所を表す文字列のリスト (そうでない場合は None) です。</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.loader_state">
<code class="descname">loader_state</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>ロード中に使う拡張モジュール指定のデータのコンテナ (または None) です。</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.cached">
<code class="descname">cached</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal"><span class="pre">__cached__</span></code>)</p>
<p>コンパイルされたモジュールを保存すべき場所を表す文字列 (または None) です</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.parent">
<code class="descname">parent</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal"><span class="pre">__package__</span></code>)</p>
<p>(読み込み専用) サブモジュールとしてモジュールが属するパッケージの完全修飾名 (または None) です。</p>
<dl class="attribute">
<dt id="importlib.machinery.ModuleSpec.has_location">
<code class="descname">has_location</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>モジュールの &#8220;origin&#8221; 属性がロード可能な場所を参照しているかどうかを示すブール値です。</p>
</dd></dl>

</div>
<div class="section" id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2>31.5.5. <a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal"><span class="pre">importlib.util</span></code></a> &#8211; インポータのためのユーティリティコード<a class="headerlink" href="#module-importlib.util" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールには、 <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> の構築を助ける様々なオブジェクトがあります。</p>
<dl class="attribute">
<dt id="importlib.util.MAGIC_NUMBER">
<code class="descclassname">importlib.util.</code><code class="descname">MAGIC_NUMBER</code><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The bytes which represent the bytecode version number. If you need help with
loading/writing bytecode then consider <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal"><span class="pre">importlib.abc.SourceLoader</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.cache_from_source">
<code class="descclassname">importlib.util.</code><code class="descname">cache_from_source</code><span class="sig-paren">(</span><em>path</em>, <em>debug_override=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ソース <em>path</em> に関連付けられたバイトコンパイルされたファイルの <span class="target" id="index-30"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> パスを返します。例えば、 <em>path</em> が <code class="docutils literal"><span class="pre">/foo/bar/baz.py</span></code> なら、 Python 3.2 の場合返り値は <code class="docutils literal"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> になります。 <code class="docutils literal"><span class="pre">cpython-32</span></code> という文字列は、現在のマジックタグから得られます (マジックタグについては <code class="xref py py-func docutils literal"><span class="pre">get_tag()</span></code> を参照; <code class="xref py py-attr docutils literal"><span class="pre">sys.implementation.cache_tag</span></code> が未定義なら <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> が送出されます。) <code class="docutils literal"><span class="pre">__debug__</span></code> が <code class="docutils literal"><span class="pre">True</span></code> なら、返されるパスは <code class="docutils literal"><span class="pre">.pyc</span></code> で終わります。また、最適化 Python (つまり <code class="docutils literal"><span class="pre">__debug__</span></code> が <code class="docutils literal"><span class="pre">False</span></code>) の場合は <code class="docutils literal"><span class="pre">.pyo</span></code> になります。 <em>debug_override</em> に <code class="docutils literal"><span class="pre">True</span></code> あるいは <code class="docutils literal"><span class="pre">False</span></code> を渡すことによって、拡張選択用の <code class="docutils literal"><span class="pre">__debug__</span></code> システム値をオーバーライドすることができます。</p>
<p><em>path</em> は存在している必要はありません。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.source_from_cache">
<code class="descclassname">importlib.util.</code><code class="descname">source_from_cache</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><span class="target" id="index-31"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> ファイル名への <em>path</em> が与えられると、関連するソースコードのファイルパスを返します。例えば、 <em>path</em> が <code class="docutils literal"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> なら、返されるパスは <code class="docutils literal"><span class="pre">/foo/bar/baz.py</span></code> になります。 <em>path</em> は存在する必要はありませんが、 <span class="target" id="index-32"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> フォーマットに一致しない場合は <code class="docutils literal"><span class="pre">ValueError</span></code> が送出されます。 <code class="xref py py-attr docutils literal"><span class="pre">sys.implementation.cache_tag</span></code> が定義されていない場合、 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> が送出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.decode_source">
<code class="descclassname">importlib.util.</code><code class="descname">decode_source</code><span class="sig-paren">(</span><em>source_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Decode the given bytes representing source code and return it as a string
with universal newlines (as required by
<a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.resolve_name">
<code class="descclassname">importlib.util.</code><code class="descname">resolve_name</code><span class="sig-paren">(</span><em>name</em>, <em>package</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>相対的なモジュール名を解決して絶対的なものにします。</p>
<p><strong>name</strong> の先頭にドットがなければ、単に <strong>name</strong> が返されます。これにより、例えば <code class="docutils literal"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__package__)</span></code> を使うときに <strong>package</strong> 変数が必要かどうかを確認する必要がなくなります。</p>
<p><strong>name</strong> が相対的なモジュール名であるにもかかわらず package が偽値 (例えば <code class="docutils literal"><span class="pre">None</span></code> や空文字列) ならば、 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。相対的な名前がそれを含むパッケージから抜け出る (例えば <code class="docutils literal"><span class="pre">spam</span></code> パッケージ内から <code class="docutils literal"><span class="pre">..bacon</span></code> を要求する) 場合にも <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> が送出されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.find_spec">
<code class="descclassname">importlib.util.</code><code class="descname">find_spec</code><span class="sig-paren">(</span><em>name</em>, <em>package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Find the <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for a module, optionally relative to
the specified <strong>package</strong> name. If the module is in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal"><span class="pre">sys.modules</span></code></a>,
then <code class="docutils literal"><span class="pre">sys.modules[name].__spec__</span></code> is returned (unless the spec would be
<code class="docutils literal"><span class="pre">None</span></code> or is not set, in which case <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> is raised).
Otherwise a search using <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal"><span class="pre">sys.meta_path</span></code></a> is done. <code class="docutils literal"><span class="pre">None</span></code> is
returned if no spec is found.</p>
<p><strong>name</strong> がサブモジュールを示している  (ドットを含む) 場合、親モジュールは自動的にインポートされます。</p>
<p><strong>name</strong> と <strong>package</strong> は <code class="xref py py-func docutils literal"><span class="pre">import_module()</span></code> に対するものと同じように機能します。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.module_for_loader">
<code class="descclassname">&#64;</code><code class="descclassname">importlib.util.</code><code class="descname">module_for_loader</code><a class="headerlink" href="#importlib.util.module_for_loader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ロードに使う適切なモジュールオブジェクトの選択を扱うための、 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> への <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> です。このデコレータメソッドのシグニチャは、2 つの位置引数をとることを期待されます (例えば <code class="docutils literal"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>) 。第二引数はローダーによって使われるモジュール <strong>object</strong> になります。なお、このデコレータは 2 つの引数を想定するため、静的メソッドにははたらきません。</p>
<p>The decorated method will take in the <strong>name</strong> of the module to be loaded
as expected for a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. If the module is not found in
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> then a new one is constructed. Regardless of where the
module came from, <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a> set to <strong>self</strong> and <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>
is set based on what <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a> returns
(if available). These attributes are set unconditionally to support
reloading.</p>
<p>デコレートされたメソッドによって例外が送出されたとき、モジュールが <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に加えられていたら、部分的に初期化されたモジュールが <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> に残らないよう、そのモジュールは取り除かれます。モジュールが既に <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal"><span class="pre">sys.modules</span></code></a> にあったなら、それは残されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span><a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a> および <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> は (可能なら) 自動的に設定されます。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>リロードをサポートするために <a class="reference internal" href="../reference/import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal"><span class="pre">__name__</span></code></a>、<a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a> <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> を無条件に設定します。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>インポート機構はこの関数が提供する全機能を直接実行するようになりました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_loader">
<code class="descclassname">&#64;</code><code class="descclassname">importlib.util.</code><code class="descname">set_loader</code><a class="headerlink" href="#importlib.util.set_loader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>返されたモジュールの <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a> 属性を設定する、 <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> への <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> です。属性が既に設定されていたら、このデコレータは何もしません。ラップされたメソッド (すなわち <code class="docutils literal"><span class="pre">self</span></code>) への第一位置引数は <a class="reference internal" href="../reference/import.html#__loader__" title="__loader__"><code class="xref py py-attr docutils literal"><span class="pre">__loader__</span></code></a> に設定される値であると仮定されます。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Set <code class="docutils literal"><span class="pre">__loader__</span></code> if set to <code class="docutils literal"><span class="pre">None</span></code>, as if the attribute does not
exist.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>インポート機構はこれを自動的に考慮するようになりました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.set_package">
<code class="descclassname">&#64;</code><code class="descclassname">importlib.util.</code><code class="descname">set_package</code><a class="headerlink" href="#importlib.util.set_package" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> for <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> to set the <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a> attribute on the returned module. If <a class="reference internal" href="../reference/import.html#__package__" title="__package__"><code class="xref py py-attr docutils literal"><span class="pre">__package__</span></code></a>
is set and has a value other than <code class="docutils literal"><span class="pre">None</span></code> it will not be changed.</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4 で撤廃: </span>インポート機構はこれを自動的に考慮するようになりました。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_loader">
<code class="descclassname">importlib.util.</code><code class="descname">spec_from_loader</code><span class="sig-paren">(</span><em>name</em>, <em>loader</em>, <em>*</em>, <em>origin=None</em>, <em>is_package=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A factory function for creating a <code class="xref py py-class docutils literal"><span class="pre">ModuleSpec</span></code> instance based
on a loader.  The parameters have the same meaning as they do for
ModuleSpec.  The function uses available <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> APIs, such as
<code class="xref py py-meth docutils literal"><span class="pre">InspectLoader.is_package()</span></code>, to fill in any missing
information on the spec.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="importlib.util.spec_from_file_location">
<code class="descclassname">importlib.util.</code><code class="descname">spec_from_file_location</code><span class="sig-paren">(</span><em>name</em>, <em>location</em>, <em>*</em>, <em>loader=None</em>, <em>submodule_search_locations=None</em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A factory function for creating a <code class="xref py py-class docutils literal"><span class="pre">ModuleSpec</span></code> instance based
on the path to a file.  Missing information will be filled in on the
spec by making use of loader APIs and by the implication that the
module will be file-based.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">31.5. <code class="docutils literal"><span class="pre">importlib</span></code> &#8211; <code class="docutils literal"><span class="pre">import</span></code> の実装</a><ul>
<li><a class="reference internal" href="#introduction">31.5.1. はじめに</a></li>
<li><a class="reference internal" href="#functions">31.5.2. 関数</a></li>
<li><a class="reference internal" href="#module-importlib.abc">31.5.3. <code class="docutils literal"><span class="pre">importlib.abc</span></code> &#8211; import に関連する抽象基底クラス</a></li>
<li><a class="reference internal" href="#module-importlib.machinery">31.5.4. <code class="docutils literal"><span class="pre">importlib.machinery</span></code> &#8211; インポータおよびパスフック</a></li>
<li><a class="reference internal" href="#module-importlib.util">31.5.5. <code class="docutils literal"><span class="pre">importlib.util</span></code> &#8211; インポータのためのユーティリティコード</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="runpy.html"
                        title="前の章へ">31.4. <code class="docutils literal"><span class="pre">runpy</span></code> &#8212; Python モジュールの位置特定と実行</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="language.html"
                        title="次の章へ">32. Python言語サービス</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/importlib.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="language.html" title="32. Python言語サービス"
             >次へ</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="31.4. runpy — Python モジュールの位置特定と実行"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >31. モジュールのインポート</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>