<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>18.5.3. タスクとコルーチン &mdash; Python 3.4.3 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.4.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 ドキュメント" href="../contents.html" />
    <link rel="up" title="18.5. asyncio – 非同期 I/O、イベントループ、コルーチンおよびタスク" href="asyncio.html" />
    <link rel="next" title="18.5.4. トランスポートとプロトコル (低レベル API)" href="asyncio-protocol.html" />
    <link rel="prev" title="18.5.2. イベントループ" href="asyncio-eventloops.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="asyncio-protocol.html" title="18.5.4. トランスポートとプロトコル (低レベル API)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="18.5.2. イベントループ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >18. プロセス間通信とネットワーク</a> &raquo;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U">18.5. <code class="docutils literal"><span class="pre">asyncio</span></code> &#8211; 非同期 I/O、イベントループ、コルーチンおよびタスク</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tasks-and-coroutines">
<h1>18.5.3. タスクとコルーチン<a class="headerlink" href="#tasks-and-coroutines" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="coroutines">
<span id="coroutine"></span><h2>18.5.3.1. コルーチン<a class="headerlink" href="#coroutines" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>コルーチンは、いくつかの約束事に従うジェネーターです。文書化上、すべてのコルーチンは <code class="docutils literal"><span class="pre">&#64;asyncio.coroutine</span></code> でデコレートされていますが、厳密にはこれは強制ではありません。</p>
<p>コルーチンは <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0380"><strong>PEP 380</strong></a> で導入された <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> 構文を使用しており、オリジナルの <code class="docutils literal"><span class="pre">yield</span></code> 構文は使用しません。</p>
<p>単語 &#8220;コルーチン&#8221; は単語 &#8220;ジェネレーター&#8221; のように、(関連はしていますが) 異なる 2 つの概念で使用されます:</p>
<ul class="simple">
<li><p class="first">コルーチンを定義する関数 (<code class="docutils literal"><span class="pre">&#64;asyncio.coroutine</span></code> でデコレートされた関数定義)。曖昧さの解消が必要な場合はこれを <em>コルーチン関数</em> (<a class="reference internal" href="#asyncio.iscoroutinefunction" title="asyncio.iscoroutinefunction"><code class="xref py py-func docutils literal"><span class="pre">iscoroutinefunction()</span></code></a> が <code class="docutils literal"><span class="pre">True</span></code> を返す) と呼びます。</p>
</li>
<li><p class="first">コルーチン関数の呼び出しによって取得されたオブジェクト。このオブジェクトは、いつかは完了する計算または I/O 操作 (通常はその組み合わせ) を表します。曖昧さの解消が必要な場合はこれを <em>コルーチンオブジェクト</em> (<a class="reference internal" href="#asyncio.iscoroutine" title="asyncio.iscoroutine"><code class="xref py py-func docutils literal"><span class="pre">iscoroutine()</span></code></a> が <code class="docutils literal"><span class="pre">True</span></code> を返す) と呼びます。</p>
</li>
</ul>
<p>コルーチンができること:</p>
<ul class="simple">
<li><p class="first"><code class="docutils literal"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">from</span> <span class="pre">future</span></code> &#8211; フューチャが終了するまでサスペンドし、フューチャ終了後その結果を返すか、伝搬された例外を送出します (フューチャがキャンセルされると <code class="docutils literal"><span class="pre">CancelledError</span></code> 例外が送出されます)。タスクがフューチャにあたり、フューチャと呼ばれるものはすべてタスクです。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">from</span> <span class="pre">coroutine</span></code> &#8211; 他のコルーチンが結果を生成する (または伝搬された例外を送出する) まで待機します。<code class="docutils literal"><span class="pre">coroutine</span></code> 表現は他のコルーチンを <em>呼び出さなくてはなりません</em>。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">return</span> <span class="pre">expression</span></code> &#8211; <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> で待機しているコルーチンに返す結果を生成します。</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">raise</span> <span class="pre">exception</span></code> &#8211; <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> で待機しているコルーチン内で例外を送出します。</p>
</li>
</ul>
<p>コルーチンの呼び出しは、そのコードの実行を開始するわけではありません &#8211; これは単なるジェネレーターであり、実際にコルーチンの呼び出しで返されるのはジェネレーターオブジェクトであり、それをイテレートするまで何も行いません。コルーチンオブジェクトの場合、その実行を開始する方法は 2 つあります: 他のコルーチンからの <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">coroutine</span></code> による呼び出し (その呼び出し側のコルーチンはすでに実行されていることが想定されています)、あるいは <a class="reference internal" href="#asyncio.async" title="asyncio.async"><code class="xref py py-func docutils literal"><span class="pre">async()</span></code></a> 関数や <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.create_task" title="asyncio.BaseEventLoop.create_task"><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_task()</span></code></a> メソッドを使用した自身の実行のスケジュール。</p>
<p>コルーチン (およびタスク) はイベントループが実行中の場合にのみ起動できます。</p>
<dl class="function">
<dt id="asyncio.coroutine">
<code class="descclassname">&#64;</code><code class="descclassname">asyncio.</code><code class="descname">coroutine</code><a class="headerlink" href="#asyncio.coroutine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>コルーチンであることを示すデコレーターです。</p>
<p>コルーチンが yield される前に破棄された場合、エラーメッセージが記録されます。<a class="reference internal" href="asyncio-dev.html#asyncio-coroutine-not-scheduled"><span>決してスケジュールされないコルーチンの検出</span></a> を参照してください。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この文書では、一部のメソッドが、<a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> を返す単純な Python 関数であるにもかかわらずコルーチンとして説明されています。これは、それら関数の将来的な実装の調整に制限がかかることのないよう意図的に行われています。そのような関数でコールバック方式のコードを使用する必要があった場合、その結果は <a class="reference internal" href="#asyncio.async" title="asyncio.async"><code class="xref py py-func docutils literal"><span class="pre">async()</span></code></a> でラップされます。</p>
</div>
<div class="section" id="example-hello-world-coroutine">
<span id="asyncio-hello-world-coroutine"></span><h3>18.5.3.1.1. 例: Hello World コルーチン<a class="headerlink" href="#example-hello-world-coroutine" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> と表示するコルーチンの例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p">)</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="c"># Blocking call which returns when the hello_world() coroutine is done</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">hello_world</span><span class="p">())</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="asyncio-eventloop.html#asyncio-hello-world-callback"><span>call_soon() による Hello World</span></a> の例では <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.call_soon" title="asyncio.BaseEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.call_soon()</span></code></a> メソッドを使ってコールバックをスケジュールしています。</p>
</div>
</div>
<div class="section" id="example-coroutine-displaying-the-current-date">
<span id="asyncio-date-coroutine"></span><h3>18.5.3.1.2. 例: 現在の日時を表示するコルーチン<a class="headerlink" href="#example-coroutine-displaying-the-current-date" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-meth docutils literal"><span class="pre">sleep()</span></code></a> 関数を用いて現在の時刻を5秒間、毎秒表示するコルーチンの例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="c"># Blocking call which returns when the display_date() coroutine is done</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">display_date</span><span class="p">(</span><span class="n">loop</span><span class="p">))</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="asyncio-eventloop.html#asyncio-date-callback"><span>display the current date with call_later()</span></a> の例では <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.call_later" title="asyncio.BaseEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.call_later()</span></code></a> によるコールバックが使われている。</p>
</div>
</div>
<div class="section" id="example-chain-coroutines">
<h3>18.5.3.1.3. 例: コルーチンのチェーン<a class="headerlink" href="#example-chain-coroutines" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>コルーチンをチェーンする例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Compute %s + %s ...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">print_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;%s + %s = %s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">print_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">compute()</span></code> は <code class="docutils literal"><span class="pre">print_sum()</span></code> にチェーンされます: <code class="docutils literal"><span class="pre">print_sum()</span></code> コルーチンは <code class="docutils literal"><span class="pre">compute()</span></code> が完了するまで待ちます。</p>
<p>この例のシーケンス図です:</p>
<img alt="../_images/tulip_coro.png" class="align-center" src="../_images/tulip_coro.png" />
<p>タスクではなくコルーチンオブジェクトが渡されたときに <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.run_until_complete" title="asyncio.BaseEventLoop.run_until_complete"><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.run_until_complete()</span></code></a> メソッドによって &#8220;Task&#8221; が作成されます。</p>
<p>この図では制御フローを表しており、内部で何がどう動いているのかを正確に説明しているわけではありません。例えば、sleep コルーチンは内部で <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.call_later" title="asyncio.BaseEventLoop.call_later"><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.call_later()</span></code></a> を使って 1 秒後にタスクを起動するフューチャを作成しています。</p>
</div>
</div>
<div class="section" id="invalidstateerror">
<h2>18.5.3.2. InvalidStateError<a class="headerlink" href="#invalidstateerror" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="exception">
<dt id="asyncio.InvalidStateError">
<em class="property">exception </em><code class="descclassname">asyncio.</code><code class="descname">InvalidStateError</code><a class="headerlink" href="#asyncio.InvalidStateError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>操作はこの状態では許可されません。</p>
</dd></dl>

</div>
<div class="section" id="timeouterror">
<h2>18.5.3.3. TimeoutError<a class="headerlink" href="#timeouterror" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="exception">
<dt id="asyncio.TimeoutError">
<em class="property">exception </em><code class="descclassname">asyncio.</code><code class="descname">TimeoutError</code><a class="headerlink" href="#asyncio.TimeoutError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>操作は与えられた期限を超えました。</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">この例外は組み込みの <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal"><span class="pre">TimeoutError</span></code></a> 例外とは異なります！</p>
</div>
</div>
<div class="section" id="future">
<h2>18.5.3.4. フューチャ<a class="headerlink" href="#future" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="asyncio.Future">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Future</code><span class="sig-paren">(</span><em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このクラスは <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Future" title="concurrent.futures.Future"><code class="xref py py-class docutils literal"><span class="pre">concurrent.futures.Future</span></code></a> と <em>ほぼ</em> 互換性があります。</p>
<p>相違点:</p>
<ul class="simple">
<li><p class="first"><a class="reference internal" href="#asyncio.Future.result" title="asyncio.Future.result"><code class="xref py py-meth docutils literal"><span class="pre">result()</span></code></a> および <a class="reference internal" href="#asyncio.Future.exception" title="asyncio.Future.exception"><code class="xref py py-meth docutils literal"><span class="pre">exception()</span></code></a> はタイムアウト引数を取らず、フューチャがまだ終了していないとき例外を送出します。</p>
</li>
<li><p class="first"><a class="reference internal" href="#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code class="xref py py-meth docutils literal"><span class="pre">add_done_callback()</span></code></a> で登録されたコールバックは常にイベントループの <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.call_soon_threadsafe" title="asyncio.BaseEventLoop.call_soon_threadsafe"><code class="xref py py-meth docutils literal"><span class="pre">call_soon_threadsafe()</span></code></a> 経由で呼び出されます。</p>
</li>
<li><p class="first">このクラスは <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal"><span class="pre">concurrent.futures</span></code></a> パッケージの <a class="reference internal" href="concurrent.futures.html#concurrent.futures.wait" title="concurrent.futures.wait"><code class="xref py py-func docutils literal"><span class="pre">wait()</span></code></a> および <a class="reference internal" href="concurrent.futures.html#concurrent.futures.as_completed" title="concurrent.futures.as_completed"><code class="xref py py-func docutils literal"><span class="pre">as_completed()</span></code></a> 関数との互換性はありません。</p>
</li>
</ul>
<p>このクラスは <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span>スレッド安全ではありません</span></a>。</p>
<dl class="method">
<dt id="asyncio.Future.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.cancel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フューチャとスケジュールされたコールバックをキャンセルします。</p>
<p>フューチャがすでに終了しているかキャンセルされていた場合 <code class="docutils literal"><span class="pre">False</span></code> を返し、そうでない場合フューチャの状態をキャンセルに変更し、コールバックをスケジュールし、<code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.cancelled">
<code class="descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.cancelled" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フューチャがキャンセルされていた場合 <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.done">
<code class="descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.done" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フューチャが終了していた場合 <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p>終了とは、結果が返された、例外が送出された、あるいはフューチャがキャンセルされたことを意味します。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.result">
<code class="descname">result</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.result" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このフューチャが表す結果を返します。</p>
<p>フューチャがキャンセルされていた場合 <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> が送出されます。フューチャの結果がまだ利用できない場合 <a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal"><span class="pre">InvalidStateError</span></code></a> が送出されます。フューチャが終了し例外の集合を持っていた場合その例外が送出されます。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.exception">
<code class="descname">exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.exception" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このフューチャで設定された例外を返します。</p>
<p>例外 (例外が設定されていない場合は <code class="docutils literal"><span class="pre">None</span></code>) はフューチャが終了した場合のみ返されます。フューチャがキャンセルされていた場合 <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> が送出されます。フューチャがまだ終了していない場合 <a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal"><span class="pre">InvalidStateError</span></code></a> が送出されます。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.add_done_callback">
<code class="descname">add_done_callback</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.add_done_callback" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フューチャが終了したときに実行するコールバックを追加します。</p>
<p>コールバックは 1 個の引数 ― フューチャオブジェクト ― で呼び出されます。呼び出されたときフューチャがすでに終了していた場合、コールバックは <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.call_soon" title="asyncio.BaseEventLoop.call_soon"><code class="xref py py-meth docutils literal"><span class="pre">call_soon()</span></code></a> でスケジュールされます。</p>
<p><a class="reference internal" href="asyncio-eventloop.html#asyncio-pass-keywords"><span>引数をコールバックに渡すには functools.partial を使います</span></a>。例えば <code class="docutils literal"><span class="pre">fut.add_done_callback(functools.partial(print,</span> <span class="pre">&quot;Future:&quot;,</span> <span class="pre">flush=True))</span></code> は <code class="docutils literal"><span class="pre">print(&quot;Future:&quot;,</span> <span class="pre">fut,</span> <span class="pre">flush=True)</span></code> を呼びます。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.remove_done_callback">
<code class="descname">remove_done_callback</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.remove_done_callback" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>&#8220;終了時に呼び出す&#8221; リストからコールバックのすべてのインスタンスを除去します。</p>
<p>除去されたコールバック数を返します。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.set_result">
<code class="descname">set_result</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.set_result" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フューチャの終了をマークしその結果を設定します。</p>
<p>このメソッドが呼ばれたときにフューチャがすでに終了している場合、<a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal"><span class="pre">InvalidStateError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Future.set_exception">
<code class="descname">set_exception</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Future.set_exception" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フューチャの終了をマークし例外を設定します。</p>
<p>このメソッドが呼ばれたときにフューチャがすでに終了している場合、<a class="reference internal" href="#asyncio.InvalidStateError" title="asyncio.InvalidStateError"><code class="xref py py-exc docutils literal"><span class="pre">InvalidStateError</span></code></a> を送出します。</p>
</dd></dl>

</dd></dl>

<div class="section" id="example-future-with-run-until-complete">
<h3>18.5.3.4.1. 例: run_until_complete() を使ったフューチャ<a class="headerlink" href="#example-future-with-run-until-complete" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> と <a class="reference internal" href="#coroutine"><span>コルーチン関数</span></a> を組み合わせた例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">slow_operation</span><span class="p">(</span><span class="n">future</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="s">&#39;Future is done!&#39;</span><span class="p">)</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">slow_operation</span><span class="p">(</span><span class="n">future</span><span class="p">))</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>コルーチン関数は (1秒間かかる) 計算の責任を持ち、結果をフューチャ内に格納します。<a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.run_until_complete" title="asyncio.BaseEventLoop.run_until_complete"><code class="xref py py-meth docutils literal"><span class="pre">run_until_complete()</span></code></a> メソッドはフューチャの計算を待機します。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.run_until_complete" title="asyncio.BaseEventLoop.run_until_complete"><code class="xref py py-meth docutils literal"><span class="pre">run_until_complete()</span></code></a> メソッドはフューチャの終了の通知を受けるため内部で <a class="reference internal" href="#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code class="xref py py-meth docutils literal"><span class="pre">add_done_callback()</span></code></a> メソッドを使用します。</p>
</div>
</div>
<div class="section" id="example-future-with-run-forever">
<h3>18.5.3.4.2. 例: run_forever() を使ったフューチャ<a class="headerlink" href="#example-future-with-run-forever" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上の例を <a class="reference internal" href="#asyncio.Future.add_done_callback" title="asyncio.Future.add_done_callback"><code class="xref py py-meth docutils literal"><span class="pre">Future.add_done_callback()</span></code></a> メソッド使って制御フローを明示して書くこともできます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">slow_operation</span><span class="p">(</span><span class="n">future</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="s">&#39;Future is done!&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">got_result</span><span class="p">(</span><span class="n">future</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">slow_operation</span><span class="p">(</span><span class="n">future</span><span class="p">))</span>
<span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">got_result</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>この例では <code class="docutils literal"><span class="pre">slow_operation()</span></code> を <code class="docutils literal"><span class="pre">got_result()</span></code> にリンクするために future を用いています。<code class="docutils literal"><span class="pre">slow_operation()</span></code> が終了したとき <code class="docutils literal"><span class="pre">got_result()</span></code> が結果と供に呼ばれます。</p>
</div>
</div>
<div class="section" id="task">
<h2>18.5.3.5. タスク<a class="headerlink" href="#task" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="class">
<dt id="asyncio.Task">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">Task</code><span class="sig-paren">(</span><em>coro</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#coroutine"><span>コルーチン</span></a> の実行をスケジュールします: それをフューチャ内にラップします。タスクは <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> のサブクラスです。</p>
<p>タスクはイベントループ内のコルーチンオブジェクトの実行の責任を持ちます。フューチャ内からラップされたコルーチンが yield した場合、タスクはラップされたコルーチンの実行をサスペンドし、フューチャの計算を待機します。フューチャの計算が終了したとき、ラップされたコルーチンはフューチャの結果か例外を取って実行が再開されます。</p>
<p>イベントループは協調スケジューリングを使用します: 1 つのイベントループは同時に 1 つのタスクのみ実行します。その他のタスクは、他のイベントループが異なるメソッドで実行されている場合に並列で実行されるかもしれません。タスクがフューチャの計算を待っている間、イベントループは新しいタスクを実行します。</p>
<p>タスクのキャンセルはフューチャのキャンセルとは異なります。<a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal"><span class="pre">cancel()</span></code></a> はラップされたコルーチンに <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> を送出します。ラップされたコルーチンが <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> 例外を補足しなかった、あるいは <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> 例外を送出しなかった場合、<a class="reference internal" href="#asyncio.Future.cancelled" title="asyncio.Future.cancelled"><code class="xref py py-meth docutils literal"><span class="pre">cancelled()</span></code></a> は常に <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
<p>未完のタスクが破棄された場合、それのラップされた <a class="reference internal" href="#coroutine"><span>コルーチン</span></a> は完了しません。これはおそらくバグであり警告がログに記録されます: <a class="reference internal" href="asyncio-dev.html#asyncio-pending-task-destroyed"><span>未完のタスクの破棄</span></a> を参照してください。</p>
<p><a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> のインスタンスを直接作成しないでください: <a class="reference internal" href="#asyncio.async" title="asyncio.async"><code class="xref py py-func docutils literal"><span class="pre">async()</span></code></a> 関数または <a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.create_task" title="asyncio.BaseEventLoop.create_task"><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_task()</span></code></a> メソッドを使用します。</p>
<p>このクラスは <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span>スレッド安全ではありません</span></a>。</p>
<dl class="classmethod">
<dt id="asyncio.Task.all_tasks">
<em class="property">classmethod </em><code class="descname">all_tasks</code><span class="sig-paren">(</span><em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.all_tasks" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イベントループ <em>loop</em> のすべてのタスクの集合を返します。</p>
<p>デフォルトでは現在のイベントループの全タスクが返されます。</p>
</dd></dl>

<dl class="classmethod">
<dt id="asyncio.Task.current_task">
<em class="property">classmethod </em><code class="descname">current_task</code><span class="sig-paren">(</span><em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.current_task" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>イベントループ内で現在実行中のタスクまたは <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>デフォルトでは現在のイベントループの現在のタスクが返されます。</p>
<p><a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> のコンテキスト内から呼び出されたのではない場合 <code class="docutils literal"><span class="pre">None</span></code> が返されます。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.cancel">
<code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.cancel" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このタスクのキャンセルを自身で要求します。</p>
<p>これは、イベントループを通して次のサイクルにおいてラップされたコルーチンに投入される <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> を準備します。コルーチンにはその後 try/except/finally を使用してクリーンアップするか要求を拒否する機会が与えられます。</p>
<p><a class="reference internal" href="#asyncio.Future.cancel" title="asyncio.Future.cancel"><code class="xref py py-meth docutils literal"><span class="pre">Future.cancel()</span></code></a> と異なり、これはタスクのキャンセルを保証しません: 例外が補足されそれが処理されることで、タスクのキャンセル処理が遅延したりキャンセル処理が完了しない場合があります。また、タスクは戻り値を返すか異なる例外を送出する場合もあります。</p>
<p>このメソッドが呼び出された直後は <a class="reference internal" href="#asyncio.Future.cancelled" title="asyncio.Future.cancelled"><code class="xref py py-meth docutils literal"><span class="pre">cancelled()</span></code></a> は <code class="docutils literal"><span class="pre">True</span></code> を返しません (タスクがすでにキャンセル済みの場合は除く)。ラップされたコルーチンが <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> で中止されたとき、タスクは (<a class="reference internal" href="#asyncio.Task.cancel" title="asyncio.Task.cancel"><code class="xref py py-meth docutils literal"><span class="pre">cancel()</span></code></a> が呼ばれなかった場合でも) キャンセル済みとマークされます。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.get_stack">
<code class="descname">get_stack</code><span class="sig-paren">(</span><em>*</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.get_stack" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このタスクのコルーチンのスタックフレームのリストを返します。</p>
<p>コルーチンが完了していない場合、これはサスペンドされているスタックを返します。コルーチンが正常に処理を完了したか、キャンセルされていた場合は空のリストを返します。コルーチンが例外で中止されていた場合はトレースバックフレームのリストを返します。</p>
<p>フレームは常に古いものから新しい物へ並んでいます。</p>
<p>任意の引数 <em>limit</em> には返すフレームの最大数を指定します; デフォルトでは有効なすべてのフレームが返されます。これは返される値がスタックかトレースバックかによって意味が変わります: スタックでは最新のフレームから返されますが、トレースバックでは最古のものから返されます。 (これは traceback モジュールの振る舞いと一致します。)</p>
<p>いかんともしがたい理由により、サスペンドされているコルーチンの場合スタックフレームが 1 個だけ返されます。</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Task.print_stack">
<code class="descname">print_stack</code><span class="sig-paren">(</span><em>*</em>, <em>limit=None</em>, <em>file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Task.print_stack" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>このタスクのコルーチンのスタックあるいはトレースバックを出力します。</p>
<p>この出力は get_stack() によって回収されたフレームで、traceback モジュールのそれと同じです。引数 <em>limit</em> は get_stack() に渡されます。引数 <em>file</em> は出力を書き込む I/O ストリームです; デフォルトでは <code class="docutils literal"><span class="pre">sys.stderr</span></code> になります。</p>
</dd></dl>

</dd></dl>

<div class="section" id="example-parallel-execution-of-tasks">
<h3>18.5.3.5.1. 例: タスクの並列実行<a class="headerlink" href="#example-parallel-execution-of-tasks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>3 個のタスク (A, B, C) を並列に実行する例です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="nd">@asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Task %s: Compute factorial(%s)...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">*=</span> <span class="n">i</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Task %s: factorial(%s) = %s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>出力:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">Task</span> <span class="n">A</span><span class="p">:</span> <span class="n">Compute</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">...</span>
<span class="n">Task</span> <span class="n">B</span><span class="p">:</span> <span class="n">Compute</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">...</span>
<span class="n">Task</span> <span class="n">C</span><span class="p">:</span> <span class="n">Compute</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">...</span>
<span class="n">Task</span> <span class="n">A</span><span class="p">:</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Task</span> <span class="n">B</span><span class="p">:</span> <span class="n">Compute</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">...</span>
<span class="n">Task</span> <span class="n">C</span><span class="p">:</span> <span class="n">Compute</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">...</span>
<span class="n">Task</span> <span class="n">B</span><span class="p">:</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">Task</span> <span class="n">C</span><span class="p">:</span> <span class="n">Compute</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">...</span>
<span class="n">Task</span> <span class="n">C</span><span class="p">:</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">24</span>
</pre></div>
</div>
<p>タスクは作成されたときに実行を自動的にスケジュールされます。イベントループはすべてのタスクが終了したときに停止します。</p>
</div>
</div>
<div class="section" id="task-functions">
<h2>18.5.3.6. タスク関数<a class="headerlink" href="#task-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">以下の関数では、任意の引数 <em>loop</em> で下層のタスクやコルーチンで使用されるイベントループオブジェクトを設定できます。</p>
</div>
<dl class="function">
<dt id="asyncio.as_completed">
<code class="descclassname">asyncio.</code><code class="descname">as_completed</code><span class="sig-paren">(</span><em>fs</em>, <em>*</em>, <em>loop=None</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.as_completed" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>その値のイテレーターか、待機中のときは <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> インスタンスを返します。</p>
<p>全フューチャが終了する前にタイムアウトが発生した場合 <a class="reference internal" href="#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal"><span class="pre">asyncio.TimeoutError</span></code></a> を送出します。</p>
<p>例:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">f</span>  <span class="c"># The &#39;yield from&#39; may raise</span>
    <span class="c"># Use result</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">フューチャ <code class="docutils literal"><span class="pre">f</span></code> は fs のメンバーである必要はありません。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.ensure_future">
<code class="descclassname">asyncio.</code><code class="descname">ensure_future</code><span class="sig-paren">(</span><em>coro_or_future</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.ensure_future" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#coroutine"><span>コルーチンオブジェクト</span></a> の実行をスケジュールします: このときフューチャにラップします。<a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> オブジェクトを返します。</p>
<p>引数が <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> の場合、それが直接返されます。</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4.4 で追加.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="asyncio-eventloop.html#asyncio.BaseEventLoop.create_task" title="asyncio.BaseEventLoop.create_task"><code class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_task()</span></code></a> メソッド。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.async">
<code class="descclassname">asyncio.</code><code class="descname">async</code><span class="sig-paren">(</span><em>coro_or_future</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.async" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#asyncio.ensure_future" title="asyncio.ensure_future"><code class="xref py py-func docutils literal"><span class="pre">ensure_future()</span></code></a> への非推奨なエイリアスです。</p>
<div class="deprecated">
<p><span class="versionmodified">バージョン 3.4.4 で撤廃.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.gather">
<code class="descclassname">asyncio.</code><code class="descname">gather</code><span class="sig-paren">(</span><em>*coros_or_futures</em>, <em>loop=None</em>, <em>return_exceptions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.gather" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたコルーチンオブジェクトあるいはフューチャからの結果を一つにまとめたフューチャを返します。</p>
<p>すべてのフューチャは同じイベントループを共有しなければなりません。すべてのタスクが正常終了した場合、返されるフューチャの結果は結果のリストになります (並びは、結果が返された順ではなく、オリジナルのシーケンスの順になります)。<em>return_exceptions</em> が真の場合、タスクでの例外は正常終了時の結果と同様に取り扱われ、一緒に結果リスト内に格納されます; 偽の場合、最初に送出された例外が即座に伝搬され、フューチャに返されます。</p>
<p>キャンセル: 外側のフューチャがキャンセルされた場合、すべての (まだ完了していない) 子プロセスもキャンセルされます。いずれかの子プロセスがキャンセルされた場合、これは <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> を送出するように扱います &#8211; この場合外側のフューチャはキャンセル <em>されません</em>。 (This is to prevent the cancellation of one child to cause other children to be cancelled.)</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.iscoroutine">
<code class="descclassname">asyncio.</code><code class="descname">iscoroutine</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.iscoroutine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>obj</em> が <a class="reference internal" href="#coroutine"><span>コルーチンオブジェクト</span></a> であれば <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.iscoroutinefunction">
<code class="descclassname">asyncio.</code><code class="descname">iscoroutinefunction</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.iscoroutinefunction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>func</em> がデコレートされた <a class="reference internal" href="#coroutine"><span>コルーチン関数</span></a> であれば <code class="docutils literal"><span class="pre">True</span></code> を返します。</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.sleep">
<em class="property">coroutine </em><code class="descclassname">asyncio.</code><code class="descname">sleep</code><span class="sig-paren">(</span><em>delay</em>, <em>result=None</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.sleep" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられた時間 (秒) 後に完了する <a class="reference internal" href="#coroutine"><span>コルーチン</span></a> を作成します。<em>result</em> が与えられた場合、コルーチン完了時にそれが呼び出し元に返されます。</p>
<p>スリープの分解能は <a class="reference internal" href="asyncio-eventloop.html#asyncio-delayed-calls"><span>イベントループの粒度</span></a> に依存します。</p>
<p>この関数は <a class="reference internal" href="#coroutine"><span>コルーチン</span></a> です。</p>
</dd></dl>

<dl class="function">
<dt id="asyncio.shield">
<code class="descclassname">asyncio.</code><code class="descname">shield</code><span class="sig-paren">(</span><em>arg</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.shield" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>フューチャを待機しキャンセル処理から保護します。</p>
<p>命令文:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">shield</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
</pre></div>
</div>
<p>上の文は以下と完全に等価です:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">res</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">something</span><span class="p">()</span>
</pre></div>
</div>
<p>それを含むコルーチンがキャンセルされた場合を <em>除き</em>、<code class="docutils literal"><span class="pre">something()</span></code> 内で動作するタスクはキャンセルされません。<code class="docutils literal"><span class="pre">something()</span></code> 側から見るとキャンセル処理は発生しません。ただし、呼び出し元がキャンセルされた場合は、yield-from 表現は <code class="xref py py-exc docutils literal"><span class="pre">CancelledError</span></code> を送出します。注意: <code class="docutils literal"><span class="pre">something()</span></code> が他の理由でキャンセルされた場合は <code class="docutils literal"><span class="pre">shield()</span></code> でも保護できません。</p>
<p>完全にキャンセル処理を無視させたい場合 (推奨はしません) は、以下のように <code class="docutils literal"><span class="pre">shield()</span></code> と try/except 節の組み合わせで行うことができます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">shield</span><span class="p">(</span><span class="n">something</span><span class="p">())</span>
<span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.wait">
<em class="property">coroutine </em><code class="descclassname">asyncio.</code><code class="descname">wait</code><span class="sig-paren">(</span><em>futures</em>, <em>*</em>, <em>loop=None</em>, <em>timeout=None</em>, <em>return_when=ALL_COMPLETED</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.wait" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>シーケンス <em>futures</em> で与えられたフューチャおよびコルーチンオブジェクトが完了するまで待機します。コルーチンはタスクでラップされます。戻り値は (完了した <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>, 未完の <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a>) の 2 個の集合になります。</p>
<p>シーケンス <em>futures</em> は空であってはなりません。</p>
<p><em>timeout</em> で結果を返すまで待機する最大秒数を指定できます。<em>timeout</em> は整数か浮動小数点数をとります。<em>timeout</em> が指定されないか <code class="docutils literal"><span class="pre">None</span></code> の場合、無期限に待機します。</p>
<p><em>return_when</em> でこの関数がいつ結果を返すか指定します。指定できる値は以下の <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal"><span class="pre">concurrent.futures</span></code></a> モジュール定数のどれか一つです:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">定数</p>
</th>
<th class="head"><p class="first last">説明</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">FIRST_COMPLETED</span></code></td>
<td><p class="first last">いずれかのフューチャが終了したかキャンセルされたときに返します。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-const docutils literal"><span class="pre">FIRST_EXCEPTION</span></code></td>
<td><p class="first last">いずれかのフューチャが例外の送出で終了した場合に返します。例外を送出したフューチャがない場合は、<code class="xref py py-const docutils literal"><span class="pre">ALL_COMPLETED</span></code> と等価になります。</p>
</td>
</tr>
<tr class="row-even"><td><code class="xref py py-const docutils literal"><span class="pre">ALL_COMPLETED</span></code></td>
<td><p class="first last">すべてのフューチャが終了したかキャンセルされたときに返します。</p>
</td>
</tr>
</tbody>
</table>
<p>この関数は <a class="reference internal" href="#coroutine"><span>コルーチン</span></a> です。</p>
<p>使用法:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">これは <a class="reference internal" href="#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal"><span class="pre">asyncio.TimeoutError</span></code></a> を送出しません。タイムアウトが発生して完了しなかったフューチャは戻り値の後者の集合に含まれます。</p>
</div>
</dd></dl>

<dl class="function">
<dt id="asyncio.wait_for">
<em class="property">coroutine </em><code class="descclassname">asyncio.</code><code class="descname">wait_for</code><span class="sig-paren">(</span><em>fut</em>, <em>timeout</em>, <em>*</em>, <em>loop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.wait_for" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>単一の <a class="reference internal" href="#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal"><span class="pre">Future</span></code></a> または <a class="reference internal" href="#coroutine"><span>コルーチンオブジェクト</span></a> を期限付きで待機します。<em>timeout</em> が <code class="docutils literal"><span class="pre">None</span></code> の場合、フューチャが完了するまでブロックします。</p>
<p>コルーチンは <a class="reference internal" href="#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> でラップされます。</p>
<p>フューチャあるいはコルーチンの結果を返します。タイムアウトが発生した場合、タスクをキャンセルし <a class="reference internal" href="#asyncio.TimeoutError" title="asyncio.TimeoutError"><code class="xref py py-exc docutils literal"><span class="pre">asyncio.TimeoutError</span></code></a> を送出します。タスクのキャンセルを抑止したい場合は <a class="reference internal" href="#asyncio.shield" title="asyncio.shield"><code class="xref py py-func docutils literal"><span class="pre">shield()</span></code></a> でラップしてください。</p>
<p>待機が中止された場合 <em>fut</em> も中止されます。</p>
<p>この関数は <a class="reference internal" href="#coroutine"><span>コルーチン</span></a> です。使用法:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">fut</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4.3 で変更: </span>待機が中止された場合 <em>fut</em> も中止されます。</p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">18.5.3. タスクとコルーチン</a><ul>
<li><a class="reference internal" href="#coroutines">18.5.3.1. コルーチン</a><ul>
<li><a class="reference internal" href="#example-hello-world-coroutine">18.5.3.1.1. 例: Hello World コルーチン</a></li>
<li><a class="reference internal" href="#example-coroutine-displaying-the-current-date">18.5.3.1.2. 例: 現在の日時を表示するコルーチン</a></li>
<li><a class="reference internal" href="#example-chain-coroutines">18.5.3.1.3. 例: コルーチンのチェーン</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invalidstateerror">18.5.3.2. InvalidStateError</a></li>
<li><a class="reference internal" href="#timeouterror">18.5.3.3. TimeoutError</a></li>
<li><a class="reference internal" href="#future">18.5.3.4. フューチャ</a><ul>
<li><a class="reference internal" href="#example-future-with-run-until-complete">18.5.3.4.1. 例: run_until_complete() を使ったフューチャ</a></li>
<li><a class="reference internal" href="#example-future-with-run-forever">18.5.3.4.2. 例: run_forever() を使ったフューチャ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task">18.5.3.5. タスク</a><ul>
<li><a class="reference internal" href="#example-parallel-execution-of-tasks">18.5.3.5.1. 例: タスクの並列実行</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task-functions">18.5.3.6. タスク関数</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="asyncio-eventloops.html"
                        title="前の章へ">18.5.2. イベントループ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="asyncio-protocol.html"
                        title="次の章へ">18.5.4. トランスポートとプロトコル (低レベル API)</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/asyncio-task.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="asyncio-protocol.html" title="18.5.4. トランスポートとプロトコル (低レベル API)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="18.5.2. イベントループ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >18. プロセス間通信とネットワーク</a> &raquo;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" >18.5. <code class="docutils literal"><span class="pre">asyncio</span></code> &#8211; 非同期 I/O、イベントループ、コルーチンおよびタスク</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>