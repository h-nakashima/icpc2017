<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8.8. weakref — 弱参照 &mdash; Python 3.4.3 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.4.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 ドキュメント" href="../contents.html" />
    <link rel="up" title="8. データ型" href="datatypes.html" />
    <link rel="next" title="8.9. types — 動的な型生成と組み込み型に対する名前" href="types.html" />
    <link rel="prev" title="8.7. array — 効率のよい数値アレイ" href="array.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="types.html" title="8.9. types — 動的な型生成と組み込み型に対する名前"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="array.html" title="8.7. array — 効率のよい数値アレイ"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="datatypes.html" accesskey="U">8. データ型</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-weakref">
<span id="weakref-weak-references"></span><h1>8.8. <a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> &#8212; 弱参照<a class="headerlink" href="#module-weakref" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><strong>ソースコード:</strong> <a class="reference external" href="https://hg.python.org/cpython/file/3.4/Lib/weakref.py">Lib/weakref.py</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールは、Pythonプログラマがオブジェクトへの弱参照 (<em class="dfn">weak refarence</em>)を作成できるようにします。</p>
<p>以下では、用語リファレント(<em class="dfn">referent</em>) は弱参照が参照するオブジェクトを意味します。</p>
<p>オブジェクトへの弱参照は対象オブジェクトを生かしておくのには不十分です: リファレントへの参照が弱参照しか残っていない場合、 <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">garbage collection</span></a> はリファレントを自由に破棄し、他の何かにメモリを再利用することができます。しかし、たとえ強参照で参照されていなくても、オブジェクトが実際に破棄されるまでは弱参照はオブジェクトを返します。</p>
<p>弱参照の主な使用法は、キャッシュや巨大なオブジェクトを保持するマッピングの実装です。ここでの巨大なオブジェクトはキャッシュやマッピングに存在するため、単独では生き続けないことが求められます。</p>
<p>例えば、巨大なバイナリ画像のオブジェクトがたくさんあり、それぞれに名前を関連付けたいとします。 Python の辞書型を使って名前を画像に対応付けたり画像を名前に対応付けたりすると、画像オブジェクトは辞書内のキーや値に使われているため存続しつづけることになります。 <a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールが提供している <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> や <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> クラスはその代用で、対応付けを構築するのに弱参照を使い、キャッシュやマッピングに存在するという理由だけでオブジェクトを存続させないようにします。例えば、もしある画像オブジェクトが <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> の値になっていた場合、最後に残った画像オブジェクトへの参照を弱参照マッピングが保持していれば、ガーベジコレクションはこのオブジェクトを再利用でき、画像オブジェクトに対する弱参照内の対応付けは削除されます。</p>
<p><a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> と <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> はその実装に弱参照を使用しており、キーや値がガーベジコレクションによって回収されたことを弱参照辞書に通知するコールバック関数を設定しています。 <a class="reference internal" href="#weakref.WeakSet" title="weakref.WeakSet"><code class="xref py py-class docutils literal"><span class="pre">WeakSet</span></code></a> は <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal"><span class="pre">set</span></code></a> インターフェースを実装していますが、 <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> のように要素への弱参照を持ちます。</p>
<p><a class="reference internal" href="#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal"><span class="pre">finalize</span></code></a> provides a straight forward way to register a
cleanup function to be called when an object is garbage collected.
This is simpler to use than setting up a callback function on a raw
weak reference, since the module automatically ensures that the finalizer
remains alive until the object is collected.</p>
<p>Most programs should find that using one of these weak container types
or <a class="reference internal" href="#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal"><span class="pre">finalize</span></code></a> is all they need &#8211; it&#8217;s not usually necessary to
create your own weak references directly.  The low-level machinery is
exposed by the <a class="reference internal" href="#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> module for the benefit of advanced uses.</p>
<p>全てのオブジェクトが弱参照で参照できるわけではありません; 弱参照で参照できるのは、クラスインスタンス、(C ではなく) Python で書かれた関数、インスタンスメソッド、set オブジェクト、frozenset オブジェクト、 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file オブジェクト</span></a> 、 <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> 型のオブジェクト、socket オブジェクト、array オジェクト、deque オブジェクト、正規表現パターンオブジェクト、code オブジェクトです。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>thread.lock, threading.Lock, code オブジェクトのサポートが追加されました。</p>
</div>
<p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> や <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal"><span class="pre">dict</span></code></a> など、いくつかの組み込み型は弱参照を直接サポートしませんが、以下のようにサブクラス化を行えばサポートを追加できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">obj</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">(</span><span class="n">red</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">blue</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>   <span class="c"># this object is weak referenceable</span>
</pre></div>
</div>
<p><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a> と <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal"><span class="pre">int</span></code></a> のような他の組み込み型はサブクラス化しても弱参照はサポートしません。(これは実装詳細であり、他の様々な Python 実装では異なる可能性があります。)。</p>
<p>拡張型は、簡単に弱参照をサポートできます。詳細については、 <a class="reference internal" href="../extending/newtypes.html#weakref-support"><span>弱参照(Weak Reference)のサポート</span></a> を参照してください。</p>
<dl class="class">
<dt id="weakref.ref">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">ref</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>callback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.ref" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> への弱参照を返します。リファレントがまだ生きているならば、元のオブジェクトは参照オブジェクトの呼び出しで取り出せす。リファレントがもはや生きていないならば、参照オブジェクトを呼び出したときに <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します。 <em>callback</em> に <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> 以外の値を与えた場合、オブジェクトをまさに後始末処理しようとするときに呼び出します。このとき弱参照オブジェクトは <em>callback</em> の唯一のパラメタとして渡されます。リファレントはもはや利用できません。</p>
<p>同じオブジェクトに対してたくさんの弱参照を作れます。それぞれの弱参照に対して登録されたコールバックは、もっとも新しく登録されたコールバックからもっとも古いものへと呼び出されます。</p>
<p>コールバックが発生させた例外は標準エラー出力に書き込まれますが、伝播されません。それらはオブジェクトの <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> メソッドが発生させる例外と完全に同じ方法で処理されます。</p>
<p><em>object</em> がハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>)ならば、弱参照はハッシュ可能です。それらは <em>object</em> が削除された後でもそれらのハッシュ値を保持します。 <em>object</em> が削除されてから初めて <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-func docutils literal"><span class="pre">hash()</span></code></a> が呼び出された場合に、その呼び出しは <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を発生させます。</p>
<p>弱参照は等価性のテストをサポートしていますが、順序をサポートしていません。参照がまだ生きているならば、<em>callback</em> に関係なく二つの参照はそれらのリファレントと同じ等価関係を持ちます。リファレントのどちらか一方が削除された場合、参照オブジェクトが同一である場合に限り、その参照は等価です。</p>
<p>これはサブクラス化可能な型というよりファクトリ関数です。</p>
<dl class="attribute">
<dt id="weakref.ref.__callback__">
<code class="descname">__callback__</code><a class="headerlink" href="#weakref.ref.__callback__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This read-only attribute returns the callback currently associated to the
weakref.  If there is no callback or if the referent of the weakref is
no longer alive then this attribute will have value <code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Added the <a class="reference internal" href="#weakref.ref.__callback__" title="weakref.ref.__callback__"><code class="xref py py-attr docutils literal"><span class="pre">__callback__</span></code></a> attribute.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="weakref.proxy">
<code class="descclassname">weakref.</code><code class="descname">proxy</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>callback</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.proxy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>弱参照を使う <em>object</em> へのプロキシを返します。弱参照オブジェクトを明示的な参照外しをしながら利用する代わりに、多くのケースでプロキシを利用することができます。返されるオブジェクトは、 <em>object</em> が呼び出し可能かどうかによって、 <code class="docutils literal"><span class="pre">ProxyType</span></code> または <code class="docutils literal"><span class="pre">CallableProxyType</span></code> のどちらかの型を持ちます。プロキシオブジェクトはリファレントに関係なくハッシュ可能(<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>)ではありません。これによって、それらの基本的な変更可能という性質による多くの問題を避けています。そして、辞書のキーとしての利用を妨げます。 <em>callback</em> は <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-func docutils literal"><span class="pre">ref()</span></code></a> 関数の同じ名前のパラメータと同じものです。</p>
</dd></dl>

<dl class="function">
<dt id="weakref.getweakrefcount">
<code class="descclassname">weakref.</code><code class="descname">getweakrefcount</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.getweakrefcount" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> を参照する弱参照とプロキシの数を返します。</p>
</dd></dl>

<dl class="function">
<dt id="weakref.getweakrefs">
<code class="descclassname">weakref.</code><code class="descname">getweakrefs</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.getweakrefs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> を参照するすべての弱参照とプロキシオブジェクトのリストを返します。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakKeyDictionary">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakKeyDictionary</code><span class="sig-paren">(</span><span class="optional">[</span><em>dict</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakKeyDictionary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キーを弱参照するマッピングクラス。キーへの強参照がなくなったときに、辞書のエントリは捨てられます。アプリケーションの他の部分が所有するオブジェクトへ属性を追加することもなく、それらのオブジェクトに追加データを関連づけるために使うことができます。これは属性へのアクセスをオーバーライドするオブジェクトに特に便利です。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">警告: <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> は Python 辞書型の上に作られているので、反復処理を行うときにはサイズ変更してはなりません。 <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> の場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用として) 「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更は困難なのです。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> オブジェクトは、以下の追加のメソッドを持ちます。これらのメソッドは、内部の参照を直接公開します。その参照は、利用される時に生存しているとは限りません。なので、参照を利用する前に、その参照をチェックする必要があります。これにより、必要なくなったキーの参照が残っているために、ガベージコレクタがそのキーを削除できなくなる事態を避ける事ができます。</p>
<dl class="method">
<dt id="weakref.WeakKeyDictionary.keyrefs">
<code class="descclassname">WeakKeyDictionary.</code><code class="descname">keyrefs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakKeyDictionary.keyrefs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>キーへの弱参照を持つ iterable オブジェクトを返します。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakValueDictionary">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakValueDictionary</code><span class="sig-paren">(</span><span class="optional">[</span><em>dict</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakValueDictionary" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値を弱参照するマッピングクラス。値への強参照が存在しなくなったときに、辞書のエントリは捨てられます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">警告: <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> は Python 辞書型の上に作られているので、反復処理を行うときにはサイズ変更してはなりません。 <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> の場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用として) 「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更は困難なのです。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> オブジェクトは、以下の追加のメソッドを持ちます。これらのメソッドは、 <a class="reference internal" href="#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakKeyDictionary</span></code></a> クラスの <code class="xref py py-meth docutils literal"><span class="pre">keyrefs()</span></code> メソッドと同じ目的を持っています。</p>
<dl class="method">
<dt id="weakref.WeakValueDictionary.valuerefs">
<code class="descclassname">WeakValueDictionary.</code><code class="descname">valuerefs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakValueDictionary.valuerefs" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>値への弱参照を持つ iterable オブジェクトを返します。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakSet">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakSet</code><span class="sig-paren">(</span><span class="optional">[</span><em>elements</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakSet" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>要素への弱参照を持つ集合型。要素への強参照が無くなったときに、その要素は削除されます。</p>
</dd></dl>

<dl class="class">
<dt id="weakref.WeakMethod">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">WeakMethod</code><span class="sig-paren">(</span><em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.WeakMethod" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A custom <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-class docutils literal"><span class="pre">ref</span></code></a> subclass which simulates a weak reference to a bound
method (i.e., a method defined on a class and looked up on an instance).
Since a bound method is ephemeral, a standard weak reference cannot keep
hold of it.  <a class="reference internal" href="#weakref.WeakMethod" title="weakref.WeakMethod"><code class="xref py py-class docutils literal"><span class="pre">WeakMethod</span></code></a> has special code to recreate the bound
method until either the object or the original function dies:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s">&quot;method called!&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakMethod</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="go">&lt;bound method C.method of &lt;__main__.C object at 0x7fc859830220&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()()</span>
<span class="go">method called!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="weakref.finalize">
<em class="property">class </em><code class="descclassname">weakref.</code><code class="descname">finalize</code><span class="sig-paren">(</span><em>obj</em>, <em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a callable finalizer object which will be called when <em>obj</em>
is garbage collected. Unlike an ordinary weak reference, a finalizer
will always survive until the reference object is collected, greatly
simplifying lifecycle management.</p>
<p>A finalizer is considered <em>alive</em> until it is called (either explicitly
or at garbage collection), and after that it is <em>dead</em>.  Calling a live
finalizer returns the result of evaluating <code class="docutils literal"><span class="pre">func(*arg,</span> <span class="pre">**kwargs)</span></code>,
whereas calling a dead finalizer returns <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
<p>Exceptions raised by finalizer callbacks during garbage collection
will be shown on the standard error output, but cannot be
propagated.  They are handled in the same way as exceptions raised
from an object&#8217;s <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> method or a weak reference&#8217;s
callback.</p>
<p>When the program exits, each remaining live finalizer is called
unless its <a class="reference internal" href="atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-attr docutils literal"><span class="pre">atexit</span></code></a> attribute has been set to false.  They
are called in reverse order of creation.</p>
<p>A finalizer will never invoke its callback during the later part of
the interpreter shutdown when module globals are liable to have
been replaced by <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
<dl class="method">
<dt id="weakref.finalize.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize.__call__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <em>self</em> is alive then mark it as dead and return the result of
calling <code class="docutils literal"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code>.  If <em>self</em> is dead then return
<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="weakref.finalize.detach">
<code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize.detach" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <em>self</em> is alive then mark it as dead and return the tuple
<code class="docutils literal"><span class="pre">(obj,</span> <span class="pre">func,</span> <span class="pre">args,</span> <span class="pre">kwargs)</span></code>.  If <em>self</em> is dead then return
<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="weakref.finalize.peek">
<code class="descname">peek</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#weakref.finalize.peek" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <em>self</em> is alive then return the tuple <code class="docutils literal"><span class="pre">(obj,</span> <span class="pre">func,</span> <span class="pre">args,</span>
<span class="pre">kwargs)</span></code>.  If <em>self</em> is dead then return <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="weakref.finalize.alive">
<code class="descname">alive</code><a class="headerlink" href="#weakref.finalize.alive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Property which is true if the finalizer is alive, false otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="weakref.finalize.atexit">
<code class="descname">atexit</code><a class="headerlink" href="#weakref.finalize.atexit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A writable boolean property which by default is true.  When the
program exits, it calls all remaining live finalizers for which
<a class="reference internal" href="#weakref.finalize.atexit" title="weakref.finalize.atexit"><code class="xref py py-attr docutils literal"><span class="pre">atexit</span></code></a> is true.  They are called in reverse order of
creation.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">It is important to ensure that <em>func</em>, <em>args</em> and <em>kwargs</em> do
not own any references to <em>obj</em>, either directly or indirectly,
since otherwise <em>obj</em> will never be garbage collected.  In
particular, <em>func</em> should not be a bound method of <em>obj</em>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="weakref.ReferenceType">
<code class="descclassname">weakref.</code><code class="descname">ReferenceType</code><a class="headerlink" href="#weakref.ReferenceType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>弱参照オブジェクトのための型オブジェクト。</p>
</dd></dl>

<dl class="data">
<dt id="weakref.ProxyType">
<code class="descclassname">weakref.</code><code class="descname">ProxyType</code><a class="headerlink" href="#weakref.ProxyType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し可能でないオブジェクトのプロキシのための型オブジェクト。</p>
</dd></dl>

<dl class="data">
<dt id="weakref.CallableProxyType">
<code class="descclassname">weakref.</code><code class="descname">CallableProxyType</code><a class="headerlink" href="#weakref.CallableProxyType" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>呼び出し可能なオブジェクトのプロキシのための型オブジェクト。</p>
</dd></dl>

<dl class="data">
<dt id="weakref.ProxyTypes">
<code class="descclassname">weakref.</code><code class="descname">ProxyTypes</code><a class="headerlink" href="#weakref.ProxyTypes" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシのためのすべての型オブジェクトを含むシーケンス。これは両方のプロキシ型の名前付けに依存しないで、オブジェクトがプロキシかどうかのテストをより簡単にできます。</p>
</dd></dl>

<dl class="exception">
<dt id="weakref.ReferenceError">
<em class="property">exception </em><code class="descclassname">weakref.</code><code class="descname">ReferenceError</code><a class="headerlink" href="#weakref.ReferenceError" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プロキシオブジェクトが使われても、元のオブジェクトがガベージコレクションされてしまっているときに発生する例外。これは標準の <a class="reference internal" href="exceptions.html#ReferenceError" title="ReferenceError"><code class="xref py py-exc docutils literal"><span class="pre">ReferenceError</span></code></a> 例外と同じです。</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0205"><strong>PEP 0205</strong></a> - Weak References</dt>
<dd><p class="first last">この機能の提案と理論的根拠。初期の実装と他の言語における類似の機能についての情報へのリンクを含んでいます。</p>
</dd>
</dl>
</div>
<div class="section" id="weak-reference-objects">
<span id="weakref-objects"></span><h2>8.8.1. 弱参照オブジェクト<a class="headerlink" href="#weak-reference-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Weak reference objects have no methods and no attributes besides
<a class="reference internal" href="#weakref.ref.__callback__" title="weakref.ref.__callback__"><code class="xref py py-attr docutils literal"><span class="pre">ref.__callback__</span></code></a>. A weak reference object allows the referent to be
obtained, if it still exists, by calling it:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weakref</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Object</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o2</span> <span class="o">=</span> <span class="n">r</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="ow">is</span> <span class="n">o2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>リファレントがもはや存在しないならば、参照オブジェクトの呼び出しは <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を返します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">o</span><span class="p">,</span> <span class="n">o2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">r</span><span class="p">())</span>
<span class="go">None</span>
</pre></div>
</div>
<p>弱参照オブジェクトがまだ生きているかどうかのテストは、式 <code class="docutils literal"><span class="pre">ref()</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code> を用いて行われます。通常、参照オブジェクトを使う必要があるアプリケーションコードはこのパターンに従います:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="c"># r is a weak reference object</span>
<span class="n">o</span> <span class="o">=</span> <span class="n">r</span><span class="p">()</span>
<span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
    <span class="c"># referent has been garbage collected</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Object has been deallocated; can&#39;t frobnicate.&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Object is still live!&quot;</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">do_something_useful</span><span class="p">()</span>
</pre></div>
</div>
<p>&#8220;生存性(liveness)&#8221;のテストを分割すると、スレッド化されたアプリケーションにおいて競合状態を作り出します。(訳注: <code class="docutils literal"><span class="pre">if</span> <span class="pre">r()</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None:</span> <span class="pre">r().do_something()</span></code> では、2度目のr()がNoneを返す可能性があります) 弱参照が呼び出される前に、他のスレッドは弱参照が無効になる原因となり得ます。上で示したイディオムは、シングルスレッドのアプリケーションと同じくマルチスレッド化されたアプリケーションにおいても安全です。</p>
<p>サブクラス化を行えば、 <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-class docutils literal"><span class="pre">ref</span></code></a> オブジェクトの特殊なバージョンを作成できます。これは <a class="reference internal" href="#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal"><span class="pre">WeakValueDictionary</span></code></a> の実装で使われており、マップ内の各エントリによるメモリのオーバヘッドを減らしています。こうした実装は、ある参照に追加情報を関連付けたい場合に便利ですし、リファレントを取り出すための呼び出し時に何らかの追加処理を行いたい場合にも使えます。</p>
<p>以下の例では、 <a class="reference internal" href="#weakref.ref" title="weakref.ref"><code class="xref py py-class docutils literal"><span class="pre">ref</span></code></a> のサブクラスを使って、あるオブジェクトに追加情報を保存し、リファレントがアクセスされたときにその値に作用をできるようにするための方法を示しています:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">weakref</span>

<span class="k">class</span> <span class="nc">ExtendedRef</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ob</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="o">**</span><span class="n">annotations</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ExtendedRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a pair containing the referent and the number of</span>
<span class="sd">        times the reference has been called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ExtendedRef</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__call__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="k">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ob</span> <span class="o">=</span> <span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__counter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ob</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<span id="weakref-example"></span><h2>8.8.2. 例<a class="headerlink" href="#example" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この簡単な例では、アプリケーションが以前に参照したオブジェクトを取り出すためにオブジェクトIDを利用する方法を示します。オブジェクトに生きたままであることを強制することなく、オブジェクトの IDを他のデータ構造の中で使うことができ、必要に応じてIDからオブジェクトを取り出せます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">weakref</span>

<span class="n">_id2obj_dict</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">remember</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">oid</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">_id2obj_dict</span><span class="p">[</span><span class="n">oid</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">return</span> <span class="n">oid</span>

<span class="k">def</span> <span class="nf">id2obj</span><span class="p">(</span><span class="n">oid</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_id2obj_dict</span><span class="p">[</span><span class="n">oid</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="finalizer-objects">
<span id="finalize-examples"></span><h2>8.8.3. Finalizer Objects<a class="headerlink" href="#finalizer-objects" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The main benefit of using <a class="reference internal" href="#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal"><span class="pre">finalize</span></code></a> is that it makes it simple
to register a callback without needing to preserve the returned finalizer
object.  For instance</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">weakref</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Object</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kenny</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">kenny</span><span class="p">,</span> <span class="nb">print</span><span class="p">,</span> <span class="s">&quot;You killed Kenny!&quot;</span><span class="p">)</span>  
<span class="go">&lt;finalize object at ...; for &#39;Object&#39; at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">kenny</span>
<span class="go">You killed Kenny!</span>
</pre></div>
</div>
<p>The finalizer can be called directly as well.  However the finalizer
will invoke the callback at most once.</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;CALLBACK&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">alive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">f</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">CALLBACK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">alive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>                     <span class="c"># callback not called because finalizer dead</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">obj</span>                 <span class="c"># callback not called because finalizer dead</span>
</pre></div>
</div>
<p>You can unregister a finalizer using its <a class="reference internal" href="#weakref.finalize.detach" title="weakref.finalize.detach"><code class="xref py py-meth docutils literal"><span class="pre">detach()</span></code></a>
method.  This kills the finalizer and returns the arguments passed to
the constructor when it was created.</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>                                           
<span class="go">(&lt;__main__.Object object ...&gt;, &lt;function callback ...&gt;, (1, 2), {&#39;z&#39;: 3})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">newobj</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">alive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">newobj</span> <span class="ow">is</span> <span class="n">obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
<span class="go">CALLBACK</span>
</pre></div>
</div>
<p>Unless you set the <a class="reference internal" href="#weakref.finalize.atexit" title="weakref.finalize.atexit"><code class="xref py py-attr docutils literal"><span class="pre">atexit</span></code></a> attribute to
<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal"><span class="pre">False</span></code></a>, a finalizer will be called when the program exits if it
is still alive.  For instance</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">Object</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">print</span><span class="p">,</span> <span class="s">&quot;obj dead or exiting&quot;</span><span class="p">)</span>  
<span class="go">&lt;finalize object at ...; for &#39;Object&#39; at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exit</span><span class="p">()</span>                                               
<span class="go">obj dead or exiting</span>
</pre></div>
</div>
</div>
<div class="section" id="comparing-finalizers-with-del-methods">
<h2>8.8.4. Comparing finalizers with <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> methods<a class="headerlink" href="#comparing-finalizers-with-del-methods" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Suppose we want to create a class whose instances represent temporary
directories.  The directories should be deleted with their contents
when the first of the following events occurs:</p>
<ul class="simple">
<li>the object is garbage collected,</li>
<li>the object&#8217;s <code class="xref py py-meth docutils literal"><span class="pre">remove()</span></code> method is called, or</li>
<li>the program exits.</li>
</ul>
<p>We might try to implement the class using a <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> method as
follows:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TempDir</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="k">None</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="k">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="k">None</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</pre></div>
</div>
<p>Starting with Python 3.4, <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> methods no longer prevent
reference cycles from being garbage collected, and module globals are
no longer forced to <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> during interpreter shutdown. So this
code should work without any issues on CPython.</p>
<p>However, handling of <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal"><span class="pre">__del__()</span></code></a> methods is notoriously implementation
specific, since it depends on internal details of the interpreter&#8217;s garbage
collector implementation.</p>
<p>A more robust alternative can be to define a finalizer which only references
the specific functions and objects that it needs, rather than having access
to the full state of the object:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TempDir</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalizer</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalizer</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalizer</span><span class="o">.</span><span class="n">alive</span>
</pre></div>
</div>
<p>Defined like this, our finalizer only receives a reference to the details
it needs to clean up the directory appropriately. If the object never gets
garbage collected the finalizer will still be called at exit.</p>
<p>The other advantage of weakref based finalizers is that they can be used to
register finalizers for classes where the definition is controlled by a
third party, such as running code when a module is unloaded:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">weakref</span><span class="o">,</span> <span class="nn">sys</span>
<span class="k">def</span> <span class="nf">unloading_module</span><span class="p">():</span>
    <span class="c"># implicit reference to the module globals from the function body</span>
<span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">__name__</span><span class="p">],</span> <span class="n">unloading_module</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If you create a finalizer object in a daemonic thread just as the program
exits then there is the possibility that the finalizer
does not get called at exit.  However, in a daemonic thread
<a class="reference internal" href="atexit.html#atexit.register" title="atexit.register"><code class="xref py py-func docutils literal"><span class="pre">atexit.register()</span></code></a>, <code class="docutils literal"><span class="pre">try:</span> <span class="pre">...</span> <span class="pre">finally:</span> <span class="pre">...</span></code> and <code class="docutils literal"><span class="pre">with:</span> <span class="pre">...</span></code>
do not guarantee that cleanup occurs either.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">8.8. <code class="docutils literal"><span class="pre">weakref</span></code> &#8212; 弱参照</a><ul>
<li><a class="reference internal" href="#weak-reference-objects">8.8.1. 弱参照オブジェクト</a></li>
<li><a class="reference internal" href="#example">8.8.2. 例</a></li>
<li><a class="reference internal" href="#finalizer-objects">8.8.3. Finalizer Objects</a></li>
<li><a class="reference internal" href="#comparing-finalizers-with-del-methods">8.8.4. Comparing finalizers with <code class="docutils literal"><span class="pre">__del__()</span></code> methods</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="array.html"
                        title="前の章へ">8.7. <code class="docutils literal"><span class="pre">array</span></code> &#8212; 効率のよい数値アレイ</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="types.html"
                        title="次の章へ">8.9. <code class="docutils literal"><span class="pre">types</span></code> &#8212; 動的な型生成と組み込み型に対する名前</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/weakref.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="types.html" title="8.9. types — 動的な型生成と組み込み型に対する名前"
             >次へ</a> |</li>
        <li class="right" >
          <a href="array.html" title="8.7. array — 効率のよい数値アレイ"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="datatypes.html" >8. データ型</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>