<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.2. codecs — codec レジストリと基底クラス &mdash; Python 3.4.3 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.4.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 ドキュメント" href="../contents.html" />
    <link rel="up" title="7. バイナリデータ処理" href="binary.html" />
    <link rel="next" title="8. データ型" href="datatypes.html" />
    <link rel="prev" title="7.1. struct — バイト列をパックされたバイナリデータとして解釈する" href="struct.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="8. データ型"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="struct.html" title="7.1. struct — バイト列をパックされたバイナリデータとして解釈する"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" accesskey="U">7. バイナリデータ処理</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-codecs">
<span id="codecs-codec-registry-and-base-classes"></span><h1>7.2. <a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> &#8212; codec レジストリと基底クラス<a class="headerlink" href="#module-codecs" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">This module defines base classes for standard Python codecs (encoders and
decoders) and provides access to the internal Python codec registry, which
manages the codec and error handling lookup process. Most standard codecs
are <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>, which encode text to bytes,
but there are also codecs provided that encode text to text, and bytes to
bytes. Custom codecs may encode and decode between arbitrary types, but some
module features are restricted to use specifically with
<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>, or with codecs that encode to
<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>.</p>
<p>The module defines the following functions for encoding and decoding with
any codec:</p>
<dl class="function">
<dt id="codecs.encode">
<code class="descclassname">codecs.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.encode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>encoding</em> に記載された codec を使用して <em>obj</em> をエンコードします。デフォルトのエンコーディングは <code class="docutils literal"><span class="pre">utf-8</span></code> です。</p>
<p>希望のエラー処理スキームを <em>errors</em> に設定することができます。デフォルトのエラーハンドラは <code class="docutils literal"><span class="pre">'strict'</span></code> です。これはエンコードエラーは <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> (もしくは <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a> のような、より codec に固有のサブクラス) を送出することを意味します。codec エラー処理についてのより詳しい情報は <a class="reference internal" href="#codec-base-classes"><span>Codec 基底クラス</span></a> を参照してください。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.decode">
<code class="descclassname">codecs.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>obj</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.decode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>encoding</em> に記載された codec を使用して <em>obj</em> をデコードします。デフォルトのエンコーディングは <code class="docutils literal"><span class="pre">utf-8</span></code> です。</p>
<p>希望のエラー処理スキームを <em>errors</em> に設定することができます。デフォルトのエラーハンドラは <code class="docutils literal"><span class="pre">'strict'</span></code> です。これはデコードエラーは <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> (もしくは <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> のような、より codec に固有のサブクラス) を送出することを意味します。codec エラー処理についてのより詳しい情報は <a class="reference internal" href="#codec-base-classes"><span>Codec 基底クラス</span></a> を参照してください。</p>
</dd></dl>

<p>The full details for each codec can also be looked up directly:</p>
<dl class="function">
<dt id="codecs.lookup">
<code class="descclassname">codecs.</code><code class="descname">lookup</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Looks up the codec info in the Python codec registry and returns a
<a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a> object as defined below.</p>
<p>エンコーディングの検索は、まずレジストリのキャッシュから行います。見つからなければ、登録されている検索関数のリストから探します。 <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a> オブジェクトが一つも見つからなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。見つかったら、その <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a> オブジェクトはキャッシュに保存され、呼び出し側に返されます。</p>
</dd></dl>

<dl class="class">
<dt id="codecs.CodecInfo">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">CodecInfo</code><span class="sig-paren">(</span><em>encode</em>, <em>decode</em>, <em>streamreader=None</em>, <em>streamwriter=None</em>, <em>incrementalencoder=None</em>, <em>incrementaldecoder=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.CodecInfo" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Codec details when looking up the codec registry. The constructor
arguments are stored in attributes of the same name:</p>
<dl class="attribute">
<dt id="codecs.CodecInfo.name">
<code class="descname">name</code><a class="headerlink" href="#codecs.CodecInfo.name" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The name of the encoding.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.encode">
<code class="descname">encode</code><a class="headerlink" href="#codecs.CodecInfo.encode" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.CodecInfo.decode">
<code class="descname">decode</code><a class="headerlink" href="#codecs.CodecInfo.decode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The stateless encoding and decoding functions. These must be
functions or methods which have the same interface as
the <a class="reference internal" href="#codecs.Codec.encode" title="codecs.Codec.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a> and <a class="reference internal" href="#codecs.Codec.decode" title="codecs.Codec.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a> methods of Codec
instances (see <a class="reference internal" href="#codec-objects"><span>Codec Interface</span></a>).
The functions or methods are expected to work in a stateless mode.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.incrementalencoder">
<code class="descname">incrementalencoder</code><a class="headerlink" href="#codecs.CodecInfo.incrementalencoder" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.CodecInfo.incrementaldecoder">
<code class="descname">incrementaldecoder</code><a class="headerlink" href="#codecs.CodecInfo.incrementaldecoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Incremental encoder and decoder classes or factory functions.
These have to provide the interface defined by the base classes
<a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a> and <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a>,
respectively. Incremental codecs can maintain state.</p>
</dd></dl>

<dl class="attribute">
<dt id="codecs.CodecInfo.streamwriter">
<code class="descname">streamwriter</code><a class="headerlink" href="#codecs.CodecInfo.streamwriter" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.CodecInfo.streamreader">
<code class="descname">streamreader</code><a class="headerlink" href="#codecs.CodecInfo.streamreader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Stream writer and reader classes or factory functions. These have to
provide the interface defined by the base classes
<a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a>, respectively.
Stream codecs can maintain state.</p>
</dd></dl>

</dd></dl>

<p>さまざまな codec 構成要素へのアクセスを簡便化するために、このモジュールは以下のような関数を提供しています。これらの関数は、 codec の検索に <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal"><span class="pre">lookup()</span></code></a> を使います:</p>
<dl class="function">
<dt id="codecs.getencoder">
<code class="descclassname">codecs.</code><code class="descname">getencoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getencoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたエンコーディングに対する codec を検索し、エンコーダ関数を返します。</p>
<p>エンコーディングが見つからなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getdecoder">
<code class="descclassname">codecs.</code><code class="descname">getdecoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getdecoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたエンコーディングに対する codec を検索し、デコーダ関数を返します。</p>
<p>エンコーディングが見つからなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementalencoder">
<code class="descclassname">codecs.</code><code class="descname">getincrementalencoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementalencoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたエンコーディングに対する codec を検索し、漸増的エンコーダクラスまたはファクトリ関数を返します。</p>
<p>エンコーディングが見つからないか、 codec が漸増的エンコーダをサポートしなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementaldecoder">
<code class="descclassname">codecs.</code><code class="descname">getincrementaldecoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementaldecoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたエンコーディングに対する codec を検索し、漸増的デコーダクラスまたはファクトリ関数を返します。</p>
<p>エンコーディングが見つからないか、 codec が漸増的デコーダをサポートしなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getreader">
<code class="descclassname">codecs.</code><code class="descname">getreader</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getreader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたエンコーディングに対する codec を検索し、StreamReader クラスまたはファクトリ関数を返します。</p>
<p>エンコーディングが見つからなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getwriter">
<code class="descclassname">codecs.</code><code class="descname">getwriter</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getwriter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>与えられたエンコーディングに対する codec を検索し、StreamWriter クラスまたはファクトリ関数を返します。</p>
<p>エンコーディングが見つからなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。</p>
</dd></dl>

<p>Custom codecs are made available by registering a suitable codec search
function:</p>
<dl class="function">
<dt id="codecs.register">
<code class="descclassname">codecs.</code><code class="descname">register</code><span class="sig-paren">(</span><em>search_function</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Register a codec search function. Search functions are expected to take one
argument, being the encoding name in all lower case letters, and return a
<a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal"><span class="pre">CodecInfo</span></code></a> object. In case a search function cannot find
a given encoding, it should return <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Search function registration is not currently reversible,
which may cause problems in some cases, such as unit testing or
module reloading.</p>
</div>
</dd></dl>

<p>While the builtin <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> and the associated <a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal"><span class="pre">io</span></code></a> module are the
recommended approach for working with encoded text files, this module
provides additional utility functions and classes that allow the use of a
wider range of codecs when working with binary files:</p>
<dl class="function">
<dt id="codecs.open">
<code class="descclassname">codecs.</code><code class="descname">open</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='r'</em>, <em>encoding=None</em>, <em>errors='strict'</em>, <em>buffering=1</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.open" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エンコードされたファイルを <em>mode</em> を使って開き、透過的なエンコード/デコードを提供する <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a> のインスタンスを返します。デフォルトのファイルモードは <code class="docutils literal"><span class="pre">'r'</span></code> 、つまり、読み出しモードでファイルを開きます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Underlying encoded files are always opened in binary mode.
No automatic conversion of <code class="docutils literal"><span class="pre">'\n'</span></code> is done on reading and writing.
The <em>mode</em> argument may be any binary mode acceptable to the built-in
<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> function; the <code class="docutils literal"><span class="pre">'b'</span></code> is automatically added.</p>
</div>
<p><em>encoding</em> specifies the encoding which is to be used for the file.
Any encoding that encodes to and decodes from bytes is allowed, and
the data types supported by the file methods depend on the codec used.</p>
<p>エラーハンドリングのために <em>errors</em> を渡すことができます。これはデフォルトでは <code class="docutils literal"><span class="pre">'strict'</span></code> で、エンコード時にエラーがあれば <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
<p><em>buffering</em> は組み込み関数 <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> の場合と同じ意味を持ちます。デフォルトでは行バッファリングです。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.EncodedFile">
<code class="descclassname">codecs.</code><code class="descname">EncodedFile</code><span class="sig-paren">(</span><em>file</em>, <em>data_encoding</em>, <em>file_encoding=None</em>, <em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.EncodedFile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> instance, a wrapped version of <em>file</em>
which provides transparent transcoding. The original file is closed
when the wrapped version is closed.</p>
<p>Data written to the wrapped file is decoded according to the given
<em>data_encoding</em> and then written to the original file as bytes using
<em>file_encoding</em>. Bytes read from the original file are decoded
according to <em>file_encoding</em>, and the result is encoded
using <em>data_encoding</em>.</p>
<p><em>file_encoding</em> が与えられなければ、<em>data_encoding</em> がデフォルトになります。</p>
<p>エラーハンドリングのために <em>errors</em> を渡すことができます。これはデフォルトでは <code class="docutils literal"><span class="pre">'strict'</span></code> で、エンコード時にエラーがあれば <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出します。</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterencode">
<code class="descclassname">codecs.</code><code class="descname">iterencode</code><span class="sig-paren">(</span><em>iterator</em>, <em>encoding</em>, <em>errors='strict'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterencode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Uses an incremental encoder to iteratively encode the input provided by
<em>iterator</em>. This function is a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.
The <em>errors</em> argument (as well as any
other keyword argument) is passed through to the incremental encoder.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterdecode">
<code class="descclassname">codecs.</code><code class="descname">iterdecode</code><span class="sig-paren">(</span><em>iterator</em>, <em>encoding</em>, <em>errors='strict'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterdecode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Uses an incremental decoder to iteratively decode the input provided by
<em>iterator</em>. This function is a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.
The <em>errors</em> argument (as well as any
other keyword argument) is passed through to the incremental decoder.</p>
</dd></dl>

<p>このモジュールは以下のような定数も定義しています。プラットフォーム依存なファイルを読み書きするのに役立ちます:</p>
<dl class="data">
<dt id="codecs.BOM">
<code class="descclassname">codecs.</code><code class="descname">BOM</code><a class="headerlink" href="#codecs.BOM" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_BE">
<code class="descclassname">codecs.</code><code class="descname">BOM_BE</code><a class="headerlink" href="#codecs.BOM_BE" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_LE">
<code class="descclassname">codecs.</code><code class="descname">BOM_LE</code><a class="headerlink" href="#codecs.BOM_LE" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_UTF8">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF8</code><a class="headerlink" href="#codecs.BOM_UTF8" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_UTF16">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF16</code><a class="headerlink" href="#codecs.BOM_UTF16" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_UTF16_BE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF16_BE</code><a class="headerlink" href="#codecs.BOM_UTF16_BE" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_UTF16_LE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF16_LE</code><a class="headerlink" href="#codecs.BOM_UTF16_LE" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_UTF32">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF32</code><a class="headerlink" href="#codecs.BOM_UTF32" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_UTF32_BE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF32_BE</code><a class="headerlink" href="#codecs.BOM_UTF32_BE" title="この定義へのパーマリンク">¶</a></dt>
<dt id="codecs.BOM_UTF32_LE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF32_LE</code><a class="headerlink" href="#codecs.BOM_UTF32_LE" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These constants define various byte sequences,
being Unicode byte order marks (BOMs) for several encodings. They are
used in UTF-16 and UTF-32 data streams to indicate the byte order used,
and in UTF-8 as a Unicode signature. <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16</span></code></a> is either
<a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_BE</span></code></a> or <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_LE</span></code></a> depending on the platform&#8217;s
native byte order, <a class="reference internal" href="#codecs.BOM" title="codecs.BOM"><code class="xref py py-const docutils literal"><span class="pre">BOM</span></code></a> is an alias for <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16</span></code></a>,
<a class="reference internal" href="#codecs.BOM_LE" title="codecs.BOM_LE"><code class="xref py py-const docutils literal"><span class="pre">BOM_LE</span></code></a> for <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_LE</span></code></a> and <a class="reference internal" href="#codecs.BOM_BE" title="codecs.BOM_BE"><code class="xref py py-const docutils literal"><span class="pre">BOM_BE</span></code></a> for
<a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal"><span class="pre">BOM_UTF16_BE</span></code></a>. The others represent the BOM in UTF-8 and UTF-32
encodings.</p>
</dd></dl>

<div class="section" id="codec-base-classes">
<span id="id1"></span><h2>7.2.1. Codec 基底クラス<a class="headerlink" href="#codec-base-classes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The <a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal"><span class="pre">codecs</span></code></a> module defines a set of base classes which define the
interfaces for working with codec objects, and can also be used as the basis
for custom codec implementations.</p>
<p>Each codec has to define four interfaces to make it usable as codec in Python:
stateless encoder, stateless decoder, stream reader and stream writer. The
stream reader and writers typically reuse the stateless encoder/decoder to
implement the file protocols. Codec authors also need to define how the
codec will handle encoding and decoding errors.</p>
<div class="section" id="error-handlers">
<span id="id2"></span><h3>7.2.1.1. Error Handlers<a class="headerlink" href="#error-handlers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>エラー処理の簡便化と標準化のため、コーデックは、<em>errors</em> 文字列引数を指定した場合に別のエラー処理を行うような仕組みを実装してもかまいません。全ての標準 Python codec では以下の文字列が定義され、実装されています:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last"><code class="docutils literal"><span class="pre">値</span></code></p>
</th>
<th class="head"><p class="first last">意味</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'strict'</span></code></td>
<td><p class="first last"><a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a> (または、そのサブクラス) を送出します &#8211; デフォルトの動作です。 <a class="reference internal" href="#codecs.strict_errors" title="codecs.strict_errors"><code class="xref py py-func docutils literal"><span class="pre">strict_errors()</span></code></a> で実装されています。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'ignore'</span></code></td>
<td>Ignore the malformed data and continue
without further notice.  Implemented in
<a class="reference internal" href="#codecs.ignore_errors" title="codecs.ignore_errors"><code class="xref py py-func docutils literal"><span class="pre">ignore_errors()</span></code></a>.</td>
</tr>
</tbody>
</table>
<p>The following error handlers are only applicable to
<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last"><code class="docutils literal"><span class="pre">値</span></code></p>
</th>
<th class="head"><p class="first last">意味</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'replace'</span></code></td>
<td><p class="first last">適当な置換マーカーで置換します &#8211; Python の組み込み Unicode codec のデコード時には公式の <code class="docutils literal"><span class="pre">U+FFFD</span></code> REPLACEMENT CHARACTER を、エンコード時には &#8216;?&#8217; を使います。 <a class="reference internal" href="#codecs.replace_errors" title="codecs.replace_errors"><code class="xref py py-func docutils literal"><span class="pre">replace_errors()</span></code></a> で実装されています。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code></td>
<td><p class="first last">適切な XML 文字参照で置換します (エンコードのみ)。 <a class="reference internal" href="#codecs.xmlcharrefreplace_errors" title="codecs.xmlcharrefreplace_errors"><code class="xref py py-func docutils literal"><span class="pre">xmlcharrefreplace_errors()</span></code></a> で実装されています。</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'backslashreplace'</span></code></td>
<td><p class="first last">バックスラッシュつきのエスケープシーケンスで置換します (エンコードのみ)。 <a class="reference internal" href="#codecs.backslashreplace_errors" title="codecs.backslashreplace_errors"><code class="xref py py-func docutils literal"><span class="pre">backslashreplace_errors()</span></code></a> で実装されています。</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'surrogateescape'</span></code></td>
<td>On decoding, replace byte with individual
surrogate code ranging from <code class="docutils literal"><span class="pre">U+DC80</span></code> to
<code class="docutils literal"><span class="pre">U+DCFF</span></code>.  This code will then be turned
back into the same byte when the
<code class="docutils literal"><span class="pre">'surrogateescape'</span></code> error handler is used
when encoding the data.  (See <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383"><strong>PEP 383</strong></a> for
more.)</td>
</tr>
</tbody>
</table>
<p>さらに、次のエラーハンドラは与えられた codec に特有です:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="28%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last"><code class="docutils literal"><span class="pre">値</span></code></p>
</th>
<th class="head">Codecs</th>
<th class="head"><p class="first last">意味</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'surrogatepass'</span></code></td>
<td>utf-8, utf-16, utf-32,
utf-16-be, utf-16-le,
utf-32-be, utf-32-le</td>
<td>Allow encoding and decoding of surrogate
codes.  These codecs normally treat the
presence of surrogates as an error.</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.1 で追加: </span><code class="docutils literal"><span class="pre">'surrogateescape'</span></code> および <code class="docutils literal"><span class="pre">'surrogatepass'</span></code> エラーハンドラ。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span><code class="docutils literal"><span class="pre">'surrogatepass'</span></code> エラーハンドラは utf-16* コーデックと utf-32* コーデックで動作するようになりました。</p>
</div>
<p>The set of allowed values can be extended by registering a new named error
handler:</p>
<dl class="function">
<dt id="codecs.register_error">
<code class="descclassname">codecs.</code><code class="descname">register_error</code><span class="sig-paren">(</span><em>name</em>, <em>error_handler</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Register the error handling function <em>error_handler</em> under the name <em>name</em>.
The <em>error_handler</em> argument will be called during encoding and decoding
in case of an error, when <em>name</em> is specified as the errors parameter.</p>
<p>For encoding, <em>error_handler</em> will be called with a <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a>
instance, which contains information about the location of the error. The
error handler must either raise this or a different exception, or return a
tuple with a replacement for the unencodable part of the input and a position
where encoding should continue. The replacement may be either <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> or
<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a>.  If the replacement is bytes, the encoder will simply copy
them into the output buffer. If the replacement is a string, the encoder will
encode the replacement.  Encoding continues on original input at the
specified position. Negative position values will be treated as being
relative to the end of the input string. If the resulting position is out of
bound an <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> will be raised.</p>
<p>Decoding and translating works similarly, except <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeDecodeError</span></code></a> or
<a class="reference internal" href="exceptions.html#UnicodeTranslateError" title="UnicodeTranslateError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeTranslateError</span></code></a> will be passed to the handler and that the
replacement from the error handler will be put into the output directly.</p>
</dd></dl>

<p>Previously registered error handlers (including the standard error handlers)
can be looked up by name:</p>
<dl class="function">
<dt id="codecs.lookup_error">
<code class="descclassname">codecs.</code><code class="descname">lookup_error</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup_error" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>名前 <em>name</em> で登録済みのエラー処理関数を返します。</p>
<p>エラー処理関数が見つからなければ <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal"><span class="pre">LookupError</span></code></a> を送出します。</p>
</dd></dl>

<p>The following standard error handlers are also made available as module level
functions:</p>
<dl class="function">
<dt id="codecs.strict_errors">
<code class="descclassname">codecs.</code><code class="descname">strict_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.strict_errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Implements the <code class="docutils literal"><span class="pre">'strict'</span></code> error handling: each encoding or
decoding error raises a <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.replace_errors">
<code class="descclassname">codecs.</code><code class="descname">replace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.replace_errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Implements the <code class="docutils literal"><span class="pre">'replace'</span></code> error handling (for <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> only): substitutes <code class="docutils literal"><span class="pre">'?'</span></code> for encoding errors
(to be encoded by the codec), and <code class="docutils literal"><span class="pre">'\ufffd'</span></code> (the Unicode replacement
character) for decoding errors.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.ignore_errors">
<code class="descclassname">codecs.</code><code class="descname">ignore_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.ignore_errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Implements the <code class="docutils literal"><span class="pre">'ignore'</span></code> error handling: malformed data is ignored and
encoding or decoding is continued without further notice.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.xmlcharrefreplace_errors">
<code class="descclassname">codecs.</code><code class="descname">xmlcharrefreplace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.xmlcharrefreplace_errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Implements the <code class="docutils literal"><span class="pre">'xmlcharrefreplace'</span></code> error handling (for encoding with
<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> only): the
unencodable character is replaced by an appropriate XML character reference.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.backslashreplace_errors">
<code class="descclassname">codecs.</code><code class="descname">backslashreplace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.backslashreplace_errors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Implements the <code class="docutils literal"><span class="pre">'backslashreplace'</span></code> error handling (for encoding with
<a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> only): the
unencodable character is replaced by a backslashed escape sequence.</p>
</dd></dl>

</div>
<div class="section" id="stateless-encoding-and-decoding">
<span id="codec-objects"></span><h3>7.2.1.2. Stateless Encoding and Decoding<a class="headerlink" href="#stateless-encoding-and-decoding" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>基底の <code class="xref py py-class docutils literal"><span class="pre">Codec</span></code> クラスは以下のメソッドを定義します。これらのメソッドは、内部状態を持たないエンコーダ／デコーダ関数のインタフェースを定義します:</p>
<dl class="method">
<dt id="codecs.Codec.encode">
<code class="descclassname">Codec.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.encode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクト <em>input</em> エンコードし、(出力オブジェクト, 消費した長さ) のタプルを返します。例えば、 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> は文字列オブジェクトを特有の文字セット (例えば <code class="docutils literal"><span class="pre">cp1252</span></code> や <code class="docutils literal"><span class="pre">iso-8859-1</span></code>) を用いてバイト列オブジェクトに変換します。</p>
<p><em>errors</em> 引数は適用するエラー処理を定義します。<code class="docutils literal"><span class="pre">'strict'</span></code> 処理がデフォルトです。</p>
<p>このメソッドは <code class="xref py py-class docutils literal"><span class="pre">Codec</span></code> に内部状態を保存してはなりません。効率よくエンコードするために状態を保持しなければならないような codecs には <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> を使ってください。</p>
<p>エンコーダは長さが 0 の入力を処理できなければなりません。この場合、空のオブジェクトを出力オブジェクトとして返さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.Codec.decode">
<code class="descclassname">Codec.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.decode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>オブジェクト <em>input</em> をデコードし、(出力オブジェクト, 消費した長さ) のタプルを返します。例えば、 <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> は、は特定の文字集合エンコーディングでエンコードされたバイト列オブジェクトを文字列オブジェクトに変換します。</p>
<p>For text encodings and bytes-to-bytes codecs,
<em>input</em> must be a bytes object or one which provides the read-only
buffer interface &#8211; for example, buffer objects and memory mapped files.</p>
<p><em>errors</em> 引数は適用するエラー処理を定義します。<code class="docutils literal"><span class="pre">'strict'</span></code> 処理がデフォルトです。</p>
<p>The method may not store state in the <code class="xref py py-class docutils literal"><span class="pre">Codec</span></code> instance. Use
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> for codecs which have to keep state in order to make
decoding efficient.</p>
<p>デコーダは長さが 0 の入力を処理できなければなりません。この場合、空のオブジェクトを出力オブジェクトとして返さなければなりません。</p>
</dd></dl>

</div>
<div class="section" id="incremental-encoding-and-decoding">
<h3>7.2.1.3. Incremental Encoding and Decoding<a class="headerlink" href="#incremental-encoding-and-decoding" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a> クラスおよび <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a> クラスはそれぞれ漸増的エンコーディングおよびデコーディングのための基本的なインタフェースを提供します。エンコーディング／デコーディングは内部状態を持たないエンコーダ／デコーダを一度呼び出すことで行なわれるのではなく、漸増的エンコーダ／デコーダの <a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a> メソッドを複数回呼び出すことで行なわれます。漸増的エンコーダ／デコーダはメソッド呼び出しの間エンコーディング／デコーディング処理の進行を管理します。</p>
<p><a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a> メソッド呼び出しの出力結果をまとめたものは、入力をひとまとめにして内部状態を持たないエンコーダ／デコーダでエンコード／デコードしたものと同じになります。</p>
<div class="section" id="incrementalencoder-objects">
<span id="incremental-encoder-objects"></span><h4>7.2.1.3.1. IncrementalEncoder オブジェクト<a class="headerlink" href="#incrementalencoder-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a> クラスは入力を複数ステップでエンコードするのに使われます。全ての漸増的エンコーダが Python codec レジストリと互換性を持つために定義すべきメソッドとして、このクラスには以下のメソッドが定義されています。</p>
<dl class="class">
<dt id="codecs.IncrementalEncoder">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">IncrementalEncoder</code><span class="sig-paren">(</span><em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a> インスタンスのコンストラクタ。</p>
<p>全ての漸増的エンコーダはこのコンストラクタインタフェースを提供しなければなりません。さらにキーワード引数を付け加えるのは構いませんが、Python codec レジストリで利用されるのはここで定義されているものだけです。</p>
<p><a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a> は <em>errors</em> キーワード引数を提供して異なったエラー取扱方法を実装することもできます。可能な値は <a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a> を参照してください。</p>
<p>引数 <em>errors</em> は同名の属性に割り当てられます。属性に割り当てることで <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalEncoder</span></code></a> オブジェクトが生きている間にエラー取扱戦略を違うものに切り替えることができるようになります。</p>
<dl class="method">
<dt id="codecs.IncrementalEncoder.encode">
<code class="descname">encode</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.encode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> を(エンコーダの現在の状態を考慮に入れて)エンコードし、得られたエンコードされたオブジェクトを返します。 <a class="reference internal" href="#codecs.encode" title="codecs.encode"><code class="xref py py-meth docutils literal"><span class="pre">encode()</span></code></a> 呼び出しがこれで最後という時には <em>final</em> は真でなければなりません(デフォルトは偽です)。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.reset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Reset the encoder to the initial state. The output is discarded: call
<code class="docutils literal"><span class="pre">.encode(object,</span> <span class="pre">final=True)</span></code>, passing an empty byte or text string
if necessary, to reset the encoder and to get the output.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.getstate">
<code class="descclassname">IncrementalEncoder.</code><code class="descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.getstate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エンコーダの現在の状態を返します。それは必ず整数でなければなりません。実装は、<code class="docutils literal"><span class="pre">0</span></code> が最も一般的な状態であることを保証すべきです (整数より複雑な状態は、状態を marshal/pickle して生じた文字列のバイトを整数にコード化することによって整数に変換することができます)。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.setstate">
<code class="descclassname">IncrementalEncoder.</code><code class="descname">setstate</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.setstate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エンコーダの状態を <em>state</em> にセットします。 <em>state</em> は <a class="reference internal" href="#codecs.IncrementalEncoder.getstate" title="codecs.IncrementalEncoder.getstate"><code class="xref py py-meth docutils literal"><span class="pre">getstate()</span></code></a> によって返されたエンコーダ状態でなければなりません。</p>
</dd></dl>

</div>
<div class="section" id="incrementaldecoder-objects">
<span id="incremental-decoder-objects"></span><h4>7.2.1.3.2. IncrementalDecoder オブジェクト<a class="headerlink" href="#incrementaldecoder-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a> クラスは入力を複数ステップでデコードするのに使われます。全ての漸増的デコーダが Python codec レジストリと互換性を持つために定義すべきメソッドとして、このクラスには以下のメソッドが定義されています。</p>
<dl class="class">
<dt id="codecs.IncrementalDecoder">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">IncrementalDecoder</code><span class="sig-paren">(</span><em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a> インスタンスのコンストラクタ。</p>
<p>全ての漸増的デコーダはこのコンストラクタインタフェースを提供しなければなりません。さらにキーワード引数を付け加えるのは構いませんが、Python codec レジストリで利用されるのはここで定義されているものだけです。</p>
<p><a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a> は <em>errors</em> キーワード引数を提供して異なったエラー取扱方法を実装することもできます。可能な値は <a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a> を参照してください。</p>
<p>引数 <em>errors</em> は同名の属性に割り当てられます。属性に割り当てることで <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal"><span class="pre">IncrementalDecoder</span></code></a> オブジェクトが生きている間にエラー取扱戦略を違うものに切り替えることができるようになります。</p>
<dl class="method">
<dt id="codecs.IncrementalDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.decode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> を(デコーダの現在の状態を考慮に入れて)デコードし、得られたデコードされたオブジェクトを返します。 <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal"><span class="pre">decode()</span></code></a> 呼び出しがこれで最後という時には <em>final</em> は真でなければなりません(デフォルトは偽です)。もし <em>final</em> が真ならばデコーダは入力をデコードし切り全てのバッファをフラッシュしなければなりません。そうできない場合(たとえば入力の最後に不完全なバイト列があるから)、デコーダは内部状態を持たない場合と同じようにエラーの取り扱いを開始しなければなりません(例外を送出するかもしれません)。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.reset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デコーダを初期状態にリセットします。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.getstate">
<code class="descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.getstate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デコーダの現在の状態を返します。これは2要素を含むタプルでなければなりません。1番目はまだデコードされていない入力を含むバッファです。2番目は整数で、付加的な状態情報です (実装は <code class="docutils literal"><span class="pre">0</span></code> が最も一般的な付加的な状態情報であることを保証すべきです)。この付加的な状態情報が <code class="docutils literal"><span class="pre">0</span></code> である場合、デコーダを入力がバッファされていない状態に戻して、付加的な状態情報を <code class="docutils literal"><span class="pre">0</span></code> にセットすることが可能でなければなりません。その結果、以前バッファされた入力をデコーダに与えることで、何の出力もせずにデコーダを前の状態に戻します。 (整数より複雑な付加的な状態情報は、情報を marshal/pickle して、結果として生じる文字列のバイト列を整数にエンコードすることで、整数に変換することができます。)</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.setstate">
<code class="descname">setstate</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.setstate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>エンコーダ (訳注: デコーダの間違い?) の状態を <em>state</em> にセットします。 <em>state</em> は <a class="reference internal" href="#codecs.IncrementalDecoder.getstate" title="codecs.IncrementalDecoder.getstate"><code class="xref py py-meth docutils literal"><span class="pre">getstate()</span></code></a> によって返されたデコーダ状態でなければなりません。</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="stream-encoding-and-decoding">
<h3>7.2.1.4. Stream Encoding and Decoding<a class="headerlink" href="#stream-encoding-and-decoding" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> と <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> クラスは、新しいエンコーディングモジュールを、非常に簡単に実装するのに使用できる、一般的なインターフェイス提供します。実装例は <code class="xref py py-mod docutils literal"><span class="pre">encodings.utf_8</span></code> をご覧ください。</p>
<div class="section" id="streamwriter-objects">
<span id="stream-writer-objects"></span><h4>7.2.1.4.1. StreamWriter オブジェクト<a class="headerlink" href="#streamwriter-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> クラスは <code class="xref py py-class docutils literal"><span class="pre">Codec</span></code> のサブクラスで、以下のメソッドを定義しています。全てのストリームライタは、 Python の codec レジストリとの互換性を保つために、これらのメソッドを定義する必要があります。</p>
<dl class="class">
<dt id="codecs.StreamWriter">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamWriter</code><span class="sig-paren">(</span><em>stream</em>, <em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> インスタンスのコンストラクタです。</p>
<p>全てのストリームライタはコンストラクタとしてこのインタフェースを提供しなければなりません。キーワード引数を追加しても構いませんが、Python の codec レジストリはここで定義されている引数だけを使います。</p>
<p>The <em>stream</em> argument must be a file-like object open for writing
text or binary data, as appropriate for the specific codec.</p>
<p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> may implement different error handling schemes by
providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a> for
the standard error handlers the underlying stream codec may support.</p>
<p><em>errors</em> 引数は、同名の属性に代入されます。この属性を変更すると、 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> オブジェクトが生きている間に、異なるエラー処理に変更できます。</p>
<dl class="method">
<dt id="codecs.StreamWriter.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.write" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>object</em> の内容をエンコードしてストリームに書き出します。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.writelines">
<code class="descname">writelines</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.writelines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Writes the concatenated list of strings to the stream (possibly by reusing
the <a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a> method). The standard bytes-to-bytes codecs
do not support this method.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.reset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>状態保持に使われていた codec のバッファを強制的に出力してリセットします。</p>
<p>このメソッドが呼び出された場合、出力先データをきれいな状態にし、わざわざストリーム全体を再スキャンして状態を元に戻さなくても新しくデータを追加できるようにしなければなりません。</p>
</dd></dl>

</dd></dl>

<p>ここまでで挙げたメソッドの他にも、 <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> では背後にあるストリームの他の全てのメソッドや属性を継承しなければなりません。</p>
</div>
<div class="section" id="streamreader-objects">
<span id="stream-reader-objects"></span><h4>7.2.1.4.2. StreamReader オブジェクト<a class="headerlink" href="#streamreader-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> クラスは <code class="xref py py-class docutils literal"><span class="pre">Codec</span></code> のサブクラスで、以下のメソッドを定義しています。全てのストリームリーダは、 Python の codec レジストリとの互換性を保つために、これらのメソッドを定義する必要があります。</p>
<dl class="class">
<dt id="codecs.StreamReader">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamReader</code><span class="sig-paren">(</span><em>stream</em>, <em>errors='strict'</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> インスタンスのコンストラクタです。</p>
<p>全てのストリームリーダはコンストラクタとしてこのインタフェースを提供しなければなりません。キーワード引数を追加しても構いませんが、Python の codec レジストリはここで定義されている引数だけを使います。</p>
<p>The <em>stream</em> argument must be a file-like object open for reading
text or binary data, as appropriate for the specific codec.</p>
<p>The <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> may implement different error handling schemes by
providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span>Error Handlers</span></a> for
the standard error handlers the underlying stream codec may support.</p>
<p><em>errors</em> 引数は、同名の属性に代入されます。この属性を変更すると、 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> オブジェクトが生きている間に、異なるエラー処理に変更できます。</p>
<p><em>errors</em> 引数に許される値の集合は <a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal"><span class="pre">register_error()</span></code></a> で拡張できます。</p>
<dl class="method">
<dt id="codecs.StreamReader.read">
<code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">[</span>, <em>chars</em><span class="optional">[</span>, <em>firstline</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.read" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ストリームからのデータをデコードし、デコード済のオブジェクトを返します。</p>
<p>The <em>chars</em> argument indicates the number of decoded
code points or bytes to return. The <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-func docutils literal"><span class="pre">read()</span></code></a> method will
never return more data than requested, but it might return less,
if there is not enough available.</p>
<p>The <em>size</em> argument indicates the approximate maximum
number of encoded bytes or code points to read
for decoding. The decoder can modify this setting as
appropriate. The default value -1 indicates to read and decode as much as
possible.  This parameter is intended to
prevent having to decode huge files in one step.</p>
<p><em>firstline</em> フラグは、1行目さえ返せばその後の行でデコードエラーがあっても無視して十分だ、ということを示します。</p>
<p>このメソッドは貪欲な読み込み戦略を取るべきです。すなわち、エンコーディング定義と size の値が許す範囲で、できるだけ多くのデータを読むべきだということです。たとえば、ストリーム上にエンコーディングの終端や状態の目印があれば、それも読み込みます。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readline">
<code class="descname">readline</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">[</span>, <em>keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>入力ストリームから1行読み込み、デコード済みのデータを返します。</p>
<p><em>size</em> が与えられた場合、ストリームの <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a> メソッドに size 引数として渡されます。</p>
<p><em>keepends</em> が偽の場合には行末の改行が削除された行が返ります。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readlines">
<code class="descname">readlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>sizehint</em><span class="optional">[</span>, <em>keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readlines" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>入力ストリームから全ての行を読み込み、行のリストとして返します。</p>
<p><em>keepends</em> が真なら、改行は、codec のデコーダメソッドを使って実装され、リスト要素の中に含まれます。</p>
<p><em>sizehint</em> が与えられた場合、ストリームの <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a> メソッドに <em>size</em> 引数として渡されます。</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.reset" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>状態保持に使われた codec のバッファをリセットします。</p>
<p>ストリームの読み位置を再設定してはならないので注意してください。このメソッドはデコードの際にエラーから復帰できるようにするためのものです。</p>
</dd></dl>

</dd></dl>

<p>ここまでで挙げたメソッドの他にも、 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> では背後にあるストリームの他の全てのメソッドや属性を継承しなければなりません。</p>
</div>
<div class="section" id="streamreaderwriter-objects">
<span id="stream-reader-writer"></span><h4>7.2.1.4.3. StreamReaderWriter オブジェクト<a class="headerlink" href="#streamreaderwriter-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a> は、読み書き両方に使えるストリームをラップできる便利なクラスです。</p>
<p><a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal"><span class="pre">lookup()</span></code></a> 関数が返すファクトリ関数を使って、インスタンスを生成するという設計です。</p>
<dl class="class">
<dt id="codecs.StreamReaderWriter">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamReaderWriter</code><span class="sig-paren">(</span><em>stream</em>, <em>Reader</em>, <em>Writer</em>, <em>errors</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReaderWriter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a> インスタンスを生成します。 <em>stream</em> はファイル類似のオブジェクトです。 <em>Reader</em> と <em>Writer</em> は、それぞれ <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> と <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> インタフェースを提供するファクトリ関数かファクトリクラスでなければなりません。エラー処理は、ストリームリーダとライタで定義したものと同じように行われます。</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamReaderWriter</span></code></a> インスタンスは、 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> クラスと <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> クラスを合わせたインタフェースを継承します。元になるストリームからは、他のメソッドや属性を継承します。</p>
</div>
<div class="section" id="streamrecoder-objects">
<span id="stream-recoder-objects"></span><h4>7.2.1.4.4. StreamRecoder オブジェクト<a class="headerlink" href="#streamrecoder-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> はデータをあるエンコーディングから別のエンコーディングに変換します。異なるエンコーディング環境を扱うとき、便利な場合があります。</p>
<p><a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal"><span class="pre">lookup()</span></code></a> 関数が返すファクトリ関数を使って、インスタンスを生成するという設計です。</p>
<dl class="class">
<dt id="codecs.StreamRecoder">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamRecoder</code><span class="sig-paren">(</span><em>stream</em>, <em>encode</em>, <em>decode</em>, <em>Reader</em>, <em>Writer</em>, <em>errors</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamRecoder" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>双方向変換を実装する <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> インスタンスを生成します。 <em>encode</em> と <em>decode</em> はフロントエンド (<code class="xref py py-meth docutils literal"><span class="pre">read()</span></code> および <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> を呼び出すコードから見えるデータ) ではたらき、 <em>Reader</em> と <em>Writer</em> はバックエンド (<em>stream</em> 内のデータ) ではたらきます。</p>
<p>You can use these objects to do transparent transcodings from e.g. Latin-1
to UTF-8 and back.</p>
<p>The <em>stream</em> argument must be a file-like object.</p>
<p>The <em>encode</em> and <em>decode</em> arguments must
adhere to the <code class="xref py py-class docutils literal"><span class="pre">Codec</span></code> interface. <em>Reader</em> and
<em>Writer</em> must be factory functions or classes providing objects of the
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> interface respectively.</p>
<p>エラー処理はストリーム・リーダやライタで定義されている方法と同じように行われます。</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal"><span class="pre">StreamRecoder</span></code></a> インスタンスは、 <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal"><span class="pre">StreamReader</span></code></a> と <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></code></a> クラスを合わせたインタフェースを定義します。また、元のストリームのメソッドと属性も継承します。</p>
</div>
</div>
</div>
<div class="section" id="encodings-and-unicode">
<span id="encodings-overview"></span><h2>7.2.2. エンコーディングと Unicode<a class="headerlink" href="#encodings-and-unicode" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Strings are stored internally as sequences of code points in
range <code class="docutils literal"><span class="pre">0x0</span></code>-<code class="docutils literal"><span class="pre">0x10FFFF</span></code>.  (See <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a> for
more details about the implementation.)
Once a string object is used outside of CPU and memory, endianness
and how these arrays are stored as bytes become an issue.  As with other
codecs, serialising a string into a sequence of bytes is known as <em>encoding</em>,
and recreating the string from the sequence of bytes is known as <em>decoding</em>.
There are a variety of different text serialisation codecs, which are
collectivity referred to as <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>.</p>
<p>The simplest text encoding (called <code class="docutils literal"><span class="pre">'latin-1'</span></code> or <code class="docutils literal"><span class="pre">'iso-8859-1'</span></code>) maps
the code points 0-255 to the bytes <code class="docutils literal"><span class="pre">0x0</span></code>-<code class="docutils literal"><span class="pre">0xff</span></code>, which means that a string
object that contains code points above <code class="docutils literal"><span class="pre">U+00FF</span></code> can&#8217;t be encoded with this
codec. Doing so will raise a <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal"><span class="pre">UnicodeEncodeError</span></code></a> that looks
like the following (although the details of the error message may differ):
<code class="docutils literal"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'latin-1'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">'\u1234'</span> <span class="pre">in</span>
<span class="pre">position</span> <span class="pre">3:</span> <span class="pre">ordinal</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">range(256)</span></code>.</p>
<p>他のエンコーディングの一群 (charmap エンコーディングと呼ばれます)がありますが、 Unicode コードポイントの別の部分集合とこれらがどのように <code class="docutils literal"><span class="pre">0x0</span></code>-<code class="docutils literal"><span class="pre">0xff</span></code> のバイトに写されるかを選んだものです。これがどのように行なわれるかを知るには、単にたとえば <code class="file docutils literal"><span class="pre">encodings/cp1252.py</span></code> (主に Windows で使われるエンコーディングです) を開いてみてください。256 文字のひとつの文字列定数がありどの文字がどのバイト値に写されるかを示しています。</p>
<p>これらのエンコーディングはすべて、ユニコードに定義された 1114112 のコードポイントのうちの 256 だけをエンコードすることができます。ユニコードのすべてのコードポイントを格納するための単純で直接的な方法は、各コードポイントを連続する4バイトとして格納することです。これには2つの可能性があります: ビッグエンディアンまたはリトルエンディアンの順にバイトを格納することです。これら2つのエンコーディングはそれぞれ <code class="docutils literal"><span class="pre">UTF-32-BE</span></code> および <code class="docutils literal"><span class="pre">UTF-32-LE</span></code> と呼ばれます。それらのデメリットは、例えばリトルエンディアンのマシン上で <code class="docutils literal"><span class="pre">UTF-32-BE</span></code> を使用すると、エンコードとデコードの際に常にバイトを交換する必要があることです。<code class="docutils literal"><span class="pre">UTF-32</span></code> はこの問題を回避します: バイトは、常に自然なエンディアン性に置かれます。しかし、これらのバイトが異なるエンディアン性を持つ CPU によって読まれる場合、結局バイトを交換しなければなりません。<code class="docutils literal"><span class="pre">UTF-16</span></code> あるいは <code class="docutils literal"><span class="pre">UTF-32</span></code> バイト列のエンディアン性を検出する目的で、いわゆる BOM (「バイト・オーダー・マーク」) があります。これはユニコード文字 <code class="docutils literal"><span class="pre">U+FEFF</span></code> です。この文字はすべての <code class="docutils literal"><span class="pre">UTF-16</span></code> あるいは <code class="docutils literal"><span class="pre">UTF-32</span></code> バイト列の前に置くことができます。この文字のバイトが交換されたバージョン (<code class="docutils literal"><span class="pre">0xFFFE</span></code>) は、ユニコードテキストに現われてはならない不正な文字です。したがって、<code class="docutils literal"><span class="pre">UTF-16</span></code> あるいは <code class="docutils literal"><span class="pre">UTF-32</span></code> バイト列中の最初の文字が <code class="docutils literal"><span class="pre">U+FFFE</span></code> であるように見える場合、デコードの際にバイトを交換しなければなりません。不運にも文字 <code class="docutils literal"><span class="pre">U+FEFF</span></code> は <code class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> として別の目的を持っていました: 幅を持たず、単語を分割することを許容しない文字。それは、例えばリガチャアルゴリズムにヒントを与えるために使用することができます。ユニコード 4.0 で、<code class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> としての <code class="docutils literal"><span class="pre">U+FEFF</span></code> の使用は廃止予定になりました (この役割は <code class="docutils literal"><span class="pre">U+2060</span></code> (<code class="docutils literal"><span class="pre">WORD</span> <span class="pre">JOINER</span></code>) によって引き継がれました)。しかしながら、ユニコードソフトウェアは、依然として両方の役割の <code class="docutils literal"><span class="pre">U+FEFF</span></code> を扱うことができなければなりません: BOM として、エンコードされたバイトのメモリレイアウトを決定する手段であり、一旦バイト列が文字列にデコードされたならば消えます; <code class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> として、他の任意の文字のようにデコードされる通常の文字です。</p>
<p>さらにもう一つ Unicode 文字全てをエンコードできるエンコーディングがあり、UTF-8 と呼ばれています。UTF-8 は8ビットエンコーディングで、したがって UTF-8 にはバイト順の問題はありません。UTF-8 バイト列の各バイトは二つのパートから成ります。二つはマーカ(上位数ビット)とペイロードです。マーカは0ビットから4ビットの <code class="docutils literal"><span class="pre">1</span></code> の列に <code class="docutils literal"><span class="pre">0</span></code> のビットが一つ続いたものです。Unicode 文字は次のようにエンコードされます (x はペイロードを表わし、連結されると一つの Unicode 文字を表わします):</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">範囲</p>
</th>
<th class="head"><p class="first last">エンコーディング</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">U-00000000</span></code> ... <code class="docutils literal"><span class="pre">U-0000007F</span></code></td>
<td>0xxxxxxx</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">U-00000080</span></code> ... <code class="docutils literal"><span class="pre">U-000007FF</span></code></td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">U-00000800</span></code> ... <code class="docutils literal"><span class="pre">U-0000FFFF</span></code></td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">U-00010000</span></code> ... <code class="docutils literal"><span class="pre">U-0010FFFF</span></code></td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>Unicode 文字の最下位ビットとは最も右にある x のビットです。</p>
<p>UTF-8 は8ビットエンコーディングなので BOM は必要とせず、デコードされた文字列中の <code class="docutils literal"><span class="pre">U+FEFF</span></code> は(たとえ最初の文字であったとしても) <code class="docutils literal"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> として扱われます。</p>
<p>外部からの情報無しには、文字列のエンコーディングにどのエンコーディングが使われたのか信頼できる形で決定することは不可能です。どの charmap エンコーディングもどんなランダムなバイト列でもデコードできます。しかし UTF-8 ではそれは可能ではありません。任意のバイト列を許さないような構造を持っているからです。UTF-8 エンコーディングであることを検知する信頼性を向上させるために、Microsoft は Notepad プログラム用に UTF-8 の変種 (Python 2.5 では <code class="docutils literal"><span class="pre">&quot;utf-8-sig&quot;</span></code> と呼んでいます) を考案しました。Unicode 文字がファイルに書き込まれる前に UTF-8 でエンコードした BOM (バイト列では <code class="docutils literal"><span class="pre">0xef</span></code>, <code class="docutils literal"><span class="pre">0xbb</span></code>, <code class="docutils literal"><span class="pre">0xbf</span></code> のように見えます) が書き込まれます。このようなバイト値で charmap エンコードされたファイルが始まることはほとんどあり得ない (たとえば iso-8859-1 では</p>
<blockquote>
<div><div class="line-block">
<div class="line">LATIN SMALL LETTER I WITH DIAERESIS</div>
<div class="line">RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</div>
<div class="line">INVERTED QUESTION MARK</div>
</div>
</div></blockquote>
<p>のようになる)ので、<code class="docutils literal"><span class="pre">utf-8-sig</span></code> エンコーディングがバイト列から正しく推測される確率を高めます。つまりここでは BOM はバイト列を生成する際のバイト順を決定できるように使われているのではなく、エンコーディングを推測する助けになる印として使われているのです。<code class="docutils literal"><span class="pre">utf-8-sig</span></code> codec はエンコーディングの際ファイルに最初の3文字として <code class="docutils literal"><span class="pre">0xef</span></code>, <code class="docutils literal"><span class="pre">0xbb</span></code>, <code class="docutils literal"><span class="pre">0xbf</span></code> を書き込みます。デコーディングの際はファイルの先頭に現れたこれら3バイトはスキップします。</p>
</div>
<div class="section" id="standard-encodings">
<span id="id3"></span><h2>7.2.3. 標準エンコーディング<a class="headerlink" href="#standard-encodings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python には数多くの codec が組み込みで付属します。これらは C 言語の関数、対応付けを行うテーブルの両方で提供されています。以下のテーブルでは codec と、いくつかの良く知られている別名と、エンコーディングが使われる言語を列挙します。別名のリスト、言語のリストともしらみつぶしに網羅されているわけではありません。大文字と小文字、またはアンダースコアの代りにハイフンにしただけの綴りも有効な別名です; そのため、例えば <code class="docutils literal"><span class="pre">'utf-8'</span></code> は <code class="docutils literal"><span class="pre">'utf_8'</span></code> codec の正当な別名です。</p>
<div class="impl-detail compound">
<p>いくつかの一般的なエンコーディングは、パフォーマンスを改善するために codec の検索機構を回避することがあります。これらの最適化の機会は、制限された別名のセットに対して CPython でのみ認識されます: utf-8, utf8, latin-1, latin1, iso-8859-1, mbcs (Windows のみ), ascii, utf-16, utf-32。これらのエンコーディングに対する別名を使用することは、実行時間の低下を招くかもしれません。</p>
</div>
<p>多くの文字セットは同じ言語をサポートしています。これらの文字セットは個々の文字 (例えば、EURO SIGN がサポートされているかどうか) や、文字のコード部分への割り付けが異なります。特に欧州言語では、典型的に以下の変種が存在します:</p>
<ul class="simple">
<li><p class="first">ISO 8859 コードセット</p>
</li>
<li><p class="first">Microsoft Windows コードページで、8859 コード形式から導出されているが、制御文字を追加のグラフィック文字と置き換えたもの</p>
</li>
<li><p class="first">IBM EBCDIC コードページ</p>
</li>
<li><p class="first">ASCII 互換の IBM PC コードページ</p>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="40%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Codec</th>
<th class="head"><p class="first last">別名</p>
</th>
<th class="head"><p class="first last">言語</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ascii</td>
<td>646, us-ascii</td>
<td><p class="first last">英語</p>
</td>
</tr>
<tr class="row-odd"><td>big5</td>
<td>big5-tw, csbig5</td>
<td><p class="first last">繁体字中国語</p>
</td>
</tr>
<tr class="row-even"><td>big5hkscs</td>
<td>big5-hkscs, hkscs</td>
<td><p class="first last">繁体字中国語</p>
</td>
</tr>
<tr class="row-odd"><td>cp037</td>
<td>IBM037, IBM039</td>
<td><p class="first last">英語</p>
</td>
</tr>
<tr class="row-even"><td>cp273</td>
<td>273, IBM273, csIBM273</td>
<td><p class="first">ドイツ語</p>
<div class="last versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td>cp424</td>
<td>EBCDIC-CP-HE, IBM424</td>
<td><p class="first last">ヘブライ語</p>
</td>
</tr>
<tr class="row-even"><td>cp437</td>
<td>437, IBM437</td>
<td><p class="first last">英語</p>
</td>
</tr>
<tr class="row-odd"><td>cp500</td>
<td>EBCDIC-CP-BE, EBCDIC-CP-CH,
IBM500</td>
<td><p class="first last">西ヨーロッパ言語</p>
</td>
</tr>
<tr class="row-even"><td>cp720</td>
<td>&nbsp;</td>
<td><p class="first last">アラビア語</p>
</td>
</tr>
<tr class="row-odd"><td>cp737</td>
<td>&nbsp;</td>
<td><p class="first last">ギリシャ語</p>
</td>
</tr>
<tr class="row-even"><td>cp775</td>
<td>IBM775</td>
<td><p class="first last">バルト沿岸国</p>
</td>
</tr>
<tr class="row-odd"><td>cp850</td>
<td>850, IBM850</td>
<td><p class="first last">西ヨーロッパ言語</p>
</td>
</tr>
<tr class="row-even"><td>cp852</td>
<td>852, IBM852</td>
<td><p class="first last">中央および東ヨーロッパ</p>
</td>
</tr>
<tr class="row-odd"><td>cp855</td>
<td>855, IBM855</td>
<td><p class="first last">ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア</p>
</td>
</tr>
<tr class="row-even"><td>cp856</td>
<td>&nbsp;</td>
<td><p class="first last">ヘブライ語</p>
</td>
</tr>
<tr class="row-odd"><td>cp857</td>
<td>857, IBM857</td>
<td><p class="first last">トルコ語</p>
</td>
</tr>
<tr class="row-even"><td>cp858</td>
<td>858, IBM858</td>
<td><p class="first last">西ヨーロッパ言語</p>
</td>
</tr>
<tr class="row-odd"><td>cp860</td>
<td>860, IBM860</td>
<td><p class="first last">ポルトガル語</p>
</td>
</tr>
<tr class="row-even"><td>cp861</td>
<td>861, CP-IS, IBM861</td>
<td><p class="first last">アイスランド語</p>
</td>
</tr>
<tr class="row-odd"><td>cp862</td>
<td>862, IBM862</td>
<td><p class="first last">ヘブライ語</p>
</td>
</tr>
<tr class="row-even"><td>cp863</td>
<td>863, IBM863</td>
<td><p class="first last">カナダ</p>
</td>
</tr>
<tr class="row-odd"><td>cp864</td>
<td>IBM864</td>
<td><p class="first last">アラビア語</p>
</td>
</tr>
<tr class="row-even"><td>cp865</td>
<td>865, IBM865</td>
<td><p class="first last">デンマーク、ノルウェー</p>
</td>
</tr>
<tr class="row-odd"><td>cp866</td>
<td>866, IBM866</td>
<td><p class="first last">ロシア語</p>
</td>
</tr>
<tr class="row-even"><td>cp869</td>
<td>869, CP-GR, IBM869</td>
<td><p class="first last">ギリシャ語</p>
</td>
</tr>
<tr class="row-odd"><td>cp874</td>
<td>&nbsp;</td>
<td><p class="first last">タイ語</p>
</td>
</tr>
<tr class="row-even"><td>cp875</td>
<td>&nbsp;</td>
<td><p class="first last">ギリシャ語</p>
</td>
</tr>
<tr class="row-odd"><td>cp932</td>
<td>932, ms932, mskanji, ms-kanji</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-even"><td>cp949</td>
<td>949, ms949, uhc</td>
<td><p class="first last">韓国語</p>
</td>
</tr>
<tr class="row-odd"><td>cp950</td>
<td>950, ms950</td>
<td><p class="first last">繁体字中国語</p>
</td>
</tr>
<tr class="row-even"><td>cp1006</td>
<td>&nbsp;</td>
<td>Urdu</td>
</tr>
<tr class="row-odd"><td>cp1026</td>
<td>ibm1026</td>
<td><p class="first last">トルコ語</p>
</td>
</tr>
<tr class="row-even"><td>cp1125</td>
<td>1125, ibm1125, cp866u, ruscii</td>
<td><p class="first">ウクライナ語</p>
<div class="last versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td>cp1140</td>
<td>ibm1140</td>
<td><p class="first last">西ヨーロッパ言語</p>
</td>
</tr>
<tr class="row-even"><td>cp1250</td>
<td>windows-1250</td>
<td><p class="first last">中央および東ヨーロッパ</p>
</td>
</tr>
<tr class="row-odd"><td>cp1251</td>
<td>windows-1251</td>
<td><p class="first last">ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア</p>
</td>
</tr>
<tr class="row-even"><td>cp1252</td>
<td>windows-1252</td>
<td><p class="first last">西ヨーロッパ言語</p>
</td>
</tr>
<tr class="row-odd"><td>cp1253</td>
<td>windows-1253</td>
<td><p class="first last">ギリシャ語</p>
</td>
</tr>
<tr class="row-even"><td>cp1254</td>
<td>windows-1254</td>
<td><p class="first last">トルコ語</p>
</td>
</tr>
<tr class="row-odd"><td>cp1255</td>
<td>windows-1255</td>
<td><p class="first last">ヘブライ語</p>
</td>
</tr>
<tr class="row-even"><td>cp1256</td>
<td>windows-1256</td>
<td><p class="first last">アラビア語</p>
</td>
</tr>
<tr class="row-odd"><td>cp1257</td>
<td>windows-1257</td>
<td><p class="first last">バルト沿岸国</p>
</td>
</tr>
<tr class="row-even"><td>cp1258</td>
<td>windows-1258</td>
<td><p class="first last">ベトナム</p>
</td>
</tr>
<tr class="row-odd"><td>cp65001</td>
<td>&nbsp;</td>
<td><p class="first">Windows のみ: Windows UTF-8 (<code class="docutils literal"><span class="pre">CP_UTF8</span></code>)</p>
<div class="last versionadded">
<p><span class="versionmodified">バージョン 3.3 で追加.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td>euc_jp</td>
<td>eucjp, ujis, u-jis</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-odd"><td>euc_jis_2004</td>
<td>jisx0213, eucjis2004</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-even"><td>euc_jisx0213</td>
<td>eucjisx0213</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-odd"><td>euc_kr</td>
<td>euckr, korean, ksc5601,
ks_c-5601, ks_c-5601-1987,
ksx1001, ks_x-1001</td>
<td><p class="first last">韓国語</p>
</td>
</tr>
<tr class="row-even"><td>gb2312</td>
<td>chinese, csiso58gb231280, euc-
cn, euccn, eucgb2312-cn,
gb2312-1980, gb2312-80, iso-
ir-58</td>
<td><p class="first last">簡体字中国語</p>
</td>
</tr>
<tr class="row-odd"><td>gbk</td>
<td>936, cp936, ms936</td>
<td>Unified Chinese</td>
</tr>
<tr class="row-even"><td>gb18030</td>
<td>gb18030-2000</td>
<td>Unified Chinese</td>
</tr>
<tr class="row-odd"><td>hz</td>
<td>hzgb, hz-gb, hz-gb-2312</td>
<td><p class="first last">簡体字中国語</p>
</td>
</tr>
<tr class="row-even"><td>iso2022_jp</td>
<td>csiso2022jp, iso2022jp,
iso-2022-jp</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-odd"><td>iso2022_jp_1</td>
<td>iso2022jp-1, iso-2022-jp-1</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-even"><td>iso2022_jp_2</td>
<td>iso2022jp-2, iso-2022-jp-2</td>
<td><p class="first last">日本語, 韓国語, 簡体字中国語, 西欧, ギリシャ語</p>
</td>
</tr>
<tr class="row-odd"><td>iso2022_jp_2004</td>
<td>iso2022jp-2004,
iso-2022-jp-2004</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-even"><td>iso2022_jp_3</td>
<td>iso2022jp-3, iso-2022-jp-3</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-odd"><td>iso2022_jp_ext</td>
<td>iso2022jp-ext, iso-2022-jp-ext</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-even"><td>iso2022_kr</td>
<td>csiso2022kr, iso2022kr,
iso-2022-kr</td>
<td><p class="first last">韓国語</p>
</td>
</tr>
<tr class="row-odd"><td>latin_1</td>
<td>iso-8859-1, iso8859-1, 8859,
cp819, latin, latin1, L1</td>
<td><p class="first last">西ヨーロッパ</p>
</td>
</tr>
<tr class="row-even"><td>iso8859_2</td>
<td>iso-8859-2, latin2, L2</td>
<td><p class="first last">中央および東ヨーロッパ</p>
</td>
</tr>
<tr class="row-odd"><td>iso8859_3</td>
<td>iso-8859-3, latin3, L3</td>
<td><p class="first last">エスペラント、マルタ</p>
</td>
</tr>
<tr class="row-even"><td>iso8859_4</td>
<td>iso-8859-4, latin4, L4</td>
<td><p class="first last">バルト沿岸国</p>
</td>
</tr>
<tr class="row-odd"><td>iso8859_5</td>
<td>iso-8859-5, cyrillic</td>
<td><p class="first last">ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア</p>
</td>
</tr>
<tr class="row-even"><td>iso8859_6</td>
<td>iso-8859-6, arabic</td>
<td><p class="first last">アラビア語</p>
</td>
</tr>
<tr class="row-odd"><td>iso8859_7</td>
<td>iso-8859-7, greek, greek8</td>
<td><p class="first last">ギリシャ語</p>
</td>
</tr>
<tr class="row-even"><td>iso8859_8</td>
<td>iso-8859-8, hebrew</td>
<td><p class="first last">ヘブライ語</p>
</td>
</tr>
<tr class="row-odd"><td>iso8859_9</td>
<td>iso-8859-9, latin5, L5</td>
<td><p class="first last">トルコ語</p>
</td>
</tr>
<tr class="row-even"><td>iso8859_10</td>
<td>iso-8859-10, latin6, L6</td>
<td><p class="first last">北欧語</p>
</td>
</tr>
<tr class="row-odd"><td>iso8859_13</td>
<td>iso-8859-13, latin7, L7</td>
<td><p class="first last">バルト沿岸国</p>
</td>
</tr>
<tr class="row-even"><td>iso8859_14</td>
<td>iso-8859-14, latin8, L8</td>
<td><p class="first last">ケルト語</p>
</td>
</tr>
<tr class="row-odd"><td>iso8859_15</td>
<td>iso-8859-15, latin9, L9</td>
<td><p class="first last">西ヨーロッパ言語</p>
</td>
</tr>
<tr class="row-even"><td>iso8859_16</td>
<td>iso-8859-16, latin10, L10</td>
<td><p class="first last">南東ヨーロッパ</p>
</td>
</tr>
<tr class="row-odd"><td>johab</td>
<td>cp1361, ms1361</td>
<td><p class="first last">韓国語</p>
</td>
</tr>
<tr class="row-even"><td>koi8_r</td>
<td>&nbsp;</td>
<td><p class="first last">ロシア語</p>
</td>
</tr>
<tr class="row-odd"><td>koi8_u</td>
<td>&nbsp;</td>
<td><p class="first last">ウクライナ語</p>
</td>
</tr>
<tr class="row-even"><td>mac_cyrillic</td>
<td>maccyrillic</td>
<td><p class="first last">ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア</p>
</td>
</tr>
<tr class="row-odd"><td>mac_greek</td>
<td>macgreek</td>
<td><p class="first last">ギリシャ語</p>
</td>
</tr>
<tr class="row-even"><td>mac_iceland</td>
<td>maciceland</td>
<td><p class="first last">アイスランド語</p>
</td>
</tr>
<tr class="row-odd"><td>mac_latin2</td>
<td>maclatin2, maccentraleurope</td>
<td><p class="first last">中央および東ヨーロッパ</p>
</td>
</tr>
<tr class="row-even"><td>mac_roman</td>
<td>macroman, macintosh</td>
<td><p class="first last">西ヨーロッパ言語</p>
</td>
</tr>
<tr class="row-odd"><td>mac_turkish</td>
<td>macturkish</td>
<td><p class="first last">トルコ語</p>
</td>
</tr>
<tr class="row-even"><td>ptcp154</td>
<td>csptcp154, pt154, cp154,
cyrillic-asian</td>
<td><p class="first last">カザフ</p>
</td>
</tr>
<tr class="row-odd"><td>shift_jis</td>
<td>csshiftjis, shiftjis, sjis,
s_jis</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-even"><td>shift_jis_2004</td>
<td>shiftjis2004, sjis_2004,
sjis2004</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-odd"><td>shift_jisx0213</td>
<td>shiftjisx0213, sjisx0213,
s_jisx0213</td>
<td><p class="first last">日本語</p>
</td>
</tr>
<tr class="row-even"><td>utf_32</td>
<td>U32, utf32</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-odd"><td>utf_32_be</td>
<td>UTF-32BE</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-even"><td>utf_32_le</td>
<td>UTF-32LE</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-odd"><td>utf_16</td>
<td>U16, utf16</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-even"><td>utf_16_be</td>
<td>UTF-16BE</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-odd"><td>utf_16_le</td>
<td>UTF-16LE</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-even"><td>utf_7</td>
<td>U7, unicode-1-1-utf-7</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-odd"><td>utf_8</td>
<td>U8, UTF, utf8</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
<tr class="row-even"><td>utf_8_sig</td>
<td>&nbsp;</td>
<td><p class="first last">全ての言語</p>
</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>The utf-16* and utf-32* encoders no longer allow surrogate code points
(<code class="docutils literal"><span class="pre">U+D800</span></code>&#8211;<code class="docutils literal"><span class="pre">U+DFFF</span></code>) to be encoded.
The utf-32* decoders no longer decode
byte sequences that correspond to surrogate code points.</p>
</div>
</div>
<div class="section" id="python-specific-encodings">
<h2>7.2.4. Python 特有のエンコーディング<a class="headerlink" href="#python-specific-encodings" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>予め定義された codec のいくつかは Python 特有のものなので、それらの codec 名は Python の外では無意味なものとなります。以下に、想定されている入出力のタイプに基づいて、それらを表にしました（テキストエンコーディングは codec の最も一般的な使用例ですが、その根底にある codec 基盤は、ただのテキストエンコーディングというよりも、任意のデータの変換をサポートしていることに注意してください）。非対称的な codec については、その目的がエンコーディングの方向を説明しています。</p>
<div class="section" id="text-encodings">
<h3>7.2.4.1. テキストエンコーディング<a class="headerlink" href="#text-encodings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>次の codec では、ユニコードにおけるテキストエンコーディングと同様に、<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> から <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> へのエンコードと、<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> から <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> へのデコードを提供します。</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="16%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Codec</th>
<th class="head"><p class="first last">別名</p>
</th>
<th class="head"><p class="first last">目的</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>idna</td>
<td>&nbsp;</td>
<td><p class="first last"><span class="target" id="index-17"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> の実装です。 <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal"><span class="pre">encodings.idna</span></code></a> も参照してください。 <code class="docutils literal"><span class="pre">errors='strict'</span></code> のみがサポートされています。</p>
</td>
</tr>
<tr class="row-odd"><td>mbcs</td>
<td>dbcs</td>
<td><p class="first last">Windows のみ: 被演算子を ANSI コードページ (CP_ACP) に従ってエンコードします</p>
</td>
</tr>
<tr class="row-even"><td>palmos</td>
<td>&nbsp;</td>
<td><p class="first last">PalmOS 3.5 のエンコーディングです</p>
</td>
</tr>
<tr class="row-odd"><td>punycode</td>
<td>&nbsp;</td>
<td>Implements <span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a>.
Stateful codecs are not
supported.</td>
</tr>
<tr class="row-even"><td>raw_unicode_escape</td>
<td>&nbsp;</td>
<td>Latin-1 encoding with
<code class="docutils literal"><span class="pre">\uXXXX</span></code> and
<code class="docutils literal"><span class="pre">\UXXXXXXXX</span></code> for other
code points. Existing
backslashes are not
escaped in any way.
It is used in the Python
pickle protocol.</td>
</tr>
<tr class="row-odd"><td>undefined</td>
<td>&nbsp;</td>
<td><p class="first last">空文字列を含む全ての変換に対して例外を送出します。エラーハンドラは無視されます。</p>
</td>
</tr>
<tr class="row-even"><td>unicode_escape</td>
<td>&nbsp;</td>
<td>Encoding suitable as the
contents of a Unicode
literal in ASCII-encoded
Python source code,
except that quotes are
not escaped. Decodes from
Latin-1 source code.
Beware that Python source
code actually uses UTF-8
by default.</td>
</tr>
<tr class="row-odd"><td>unicode_internal</td>
<td>&nbsp;</td>
<td><p class="first">Return the internal
representation of the
operand. Stateful codecs
are not supported.</p>
<div class="last deprecated">
<p><span class="versionmodified">バージョン 3.3 で撤廃: </span>This representation is
obsoleted by
<span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393"><strong>PEP 393</strong></a>.</p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="binary-transforms">
<span id="id4"></span><h3>7.2.4.2. Binary Transforms<a class="headerlink" href="#binary-transforms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following codecs provide binary transforms: <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>
to <a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> mappings.  They are not supported by <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal"><span class="pre">bytes.decode()</span></code></a>
(which only produces <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> output).</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="18%" />
<col width="30%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Codec</th>
<th class="head"><p class="first last">別名</p>
</th>
<th class="head"><p class="first last">目的</p>
</th>
<th class="head"><p class="first last">エンコーダ / デコーダ</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>base64_codec <a class="footnote-reference" href="#b64" id="id5">[1]</a></td>
<td>base64, base_64</td>
<td><p class="first">被演算子を MIME base64 に変換します（結果は常に末尾の <code class="docutils literal"><span class="pre">'\n'</span></code> を含みます）</p>
<div class="last versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>accepts any
<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>
as input for encoding and
decoding</p>
</div>
</td>
<td><a class="reference internal" href="base64.html#base64.b64encode" title="base64.b64encode"><code class="xref py py-meth docutils literal"><span class="pre">base64.b64encode()</span></code></a> /
<a class="reference internal" href="base64.html#base64.b64decode" title="base64.b64decode"><code class="xref py py-meth docutils literal"><span class="pre">base64.b64decode()</span></code></a></td>
</tr>
<tr class="row-odd"><td>bz2_codec</td>
<td>bz2</td>
<td><p class="first last">被演算子をbz2を使って圧縮します</p>
</td>
<td><a class="reference internal" href="bz2.html#bz2.compress" title="bz2.compress"><code class="xref py py-meth docutils literal"><span class="pre">bz2.compress()</span></code></a> /
<a class="reference internal" href="bz2.html#bz2.decompress" title="bz2.decompress"><code class="xref py py-meth docutils literal"><span class="pre">bz2.decompress()</span></code></a></td>
</tr>
<tr class="row-even"><td>hex_codec</td>
<td>hex</td>
<td><p class="first last">被演算子をバイトあたり 2 桁の 16 進数の表現に変換します</p>
</td>
<td><a class="reference internal" href="base64.html#base64.b16encode" title="base64.b16encode"><code class="xref py py-meth docutils literal"><span class="pre">base64.b16encode()</span></code></a> /
<a class="reference internal" href="base64.html#base64.b16decode" title="base64.b16decode"><code class="xref py py-meth docutils literal"><span class="pre">base64.b16decode()</span></code></a></td>
</tr>
<tr class="row-odd"><td>quopri_codec</td>
<td>quopri,
quotedprintable,
quoted_printable</td>
<td><p class="first last">被演算子を MIME quoted printable 形式に変換します</p>
</td>
<td><a class="reference internal" href="quopri.html#quopri.encodestring" title="quopri.encodestring"><code class="xref py py-meth docutils literal"><span class="pre">quopri.encodestring()</span></code></a> /
<a class="reference internal" href="quopri.html#quopri.decodestring" title="quopri.decodestring"><code class="xref py py-meth docutils literal"><span class="pre">quopri.decodestring()</span></code></a></td>
</tr>
<tr class="row-even"><td>uu_codec</td>
<td>uu</td>
<td><p class="first last">被演算子を uuencode を用いて変換します</p>
</td>
<td><a class="reference internal" href="uu.html#uu.encode" title="uu.encode"><code class="xref py py-meth docutils literal"><span class="pre">uu.encode()</span></code></a> /
<a class="reference internal" href="uu.html#uu.decode" title="uu.decode"><code class="xref py py-meth docutils literal"><span class="pre">uu.decode()</span></code></a></td>
</tr>
<tr class="row-odd"><td>zlib_codec</td>
<td>zip, zlib</td>
<td><p class="first last">被演算子を gzip を用いて圧縮します</p>
</td>
<td><a class="reference internal" href="zlib.html#zlib.compress" title="zlib.compress"><code class="xref py py-meth docutils literal"><span class="pre">zlib.compress()</span></code></a> /
<a class="reference internal" href="zlib.html#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal"><span class="pre">zlib.decompress()</span></code></a></td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="b64" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>In addition to <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>,
<code class="docutils literal"><span class="pre">'base64_codec'</span></code> also accepts ASCII-only instances of <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> for
decoding</td></tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span>Restoration of the binary transforms.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Restoration of the aliases for the binary transforms.</p>
</div>
</div>
<div class="section" id="text-transforms">
<span id="id6"></span><h3>7.2.4.3. Text Transforms<a class="headerlink" href="#text-transforms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following codec provides a text transform: a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> to <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a>
mapping.  It is not supported by <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal"><span class="pre">str.encode()</span></code></a> (which only produces
<a class="reference internal" href="functions.html#bytes" title="bytes"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> output).</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="16%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Codec</th>
<th class="head"><p class="first last">別名</p>
</th>
<th class="head"><p class="first last">目的</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rot_13</td>
<td>rot13</td>
<td><p class="first last">被演算子のシーザー暗号 (Caesar-cypher) を返します</p>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.2 で追加: </span>Restoration of the <code class="docutils literal"><span class="pre">rot_13</span></code> text transform.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.4 で変更: </span>Restoration of the <code class="docutils literal"><span class="pre">rot13</span></code> alias.</p>
</div>
</div>
</div>
<div class="section" id="module-encodings.idna">
<span id="encodings-idna-internationalized-domain-names-in-applications"></span><h2>7.2.5. <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal"><span class="pre">encodings.idna</span></code></a> &#8212; アプリケーションにおける国際化ドメイン名 (IDNA)<a class="headerlink" href="#module-encodings.idna" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールでは <span class="target" id="index-18"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> (アプリケーションにおける国際化ドメイン名、 IDNA: Internationalized Domain Names in Applications) および <span class="target" id="index-19"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a> (Nameprep: 国際化ドメイン名 (IDN) のための stringprep プロファイル) を実装しています。このモジュールは <code class="docutils literal"><span class="pre">punycode</span></code> エンコーディングおよび <a class="reference internal" href="stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal"><span class="pre">stringprep</span></code></a> の上に構築されています。</p>
<p>これらの RFC はともに、非 ASCII 文字の入ったドメイン名をサポートするためのプロトコルを定義しています。 (<code class="docutils literal"><span class="pre">www.Alliancefrançaise.nu</span></code> のような) 非 ASCII 文字を含むドメイン名は、 ASCII と互換性のあるエンコーディング (ACE、 <code class="docutils literal"><span class="pre">www.xn--alliancefranaise-npb.nu</span></code> のような形式) に変換されます。ドメイン名の ACE 形式は、 DNS クエリ、 HTTP <em class="mailheader">Host</em> フィールドなどといった、プロトコル中で任意の文字を使えないような全ての局面で用いられます。この変換はアプリケーション内で行われます; 可能ならユーザからは不可視となります: アプリケーションは Unicode ドメインラベルをネットワークに載せる際に IDNA に、 ACE ドメインラベルをユーザに提供する前に Unicode に、それぞれ透過的に変換しなければなりません。</p>
<p>Python ではこの変換をいくつかの方法でサポートします: <code class="docutils literal"><span class="pre">idna</span></code> codec は Unicode と ACE 間の変換を行い、入力文字列を <span class="target" id="index-20"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> の <a class="reference external" href="http://tools.ietf.org/html/rfc3490#section-3.1">section 3.1</a> (1) で定義されている区切り文字に基づいてラベルに分解し、各ラベルを要求通りに ACE に変換します。逆に、入力のバイト文字列を <code class="docutils literal"><span class="pre">.</span></code> 区切り文字でラベルに分解し、 ACE ラベルを Unicode に変換します。さらに、 <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールは Unicode ホスト名を ACE に透過的に変換するため、アプリケーションはホスト名を <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> モジュールに渡す際にホスト名の変換に煩わされることがありません。その上で、ホスト名を関数パラメタとして持つ、 <a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">http.client</span></code></a> や <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">ftplib</span></code></a> のようなモジュールでは Unicode ホスト名を受理します (<a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">http.client</span></code></a> でもまた、 <em class="mailheader">Host</em> フィールドにある IDNA ホスト名を、フィールド全体を送信する場合に透過的に送信します)。</p>
<p>(逆引きなどによって) ネットワーク越しにホスト名を受信する際、Unicode への自動変換は行われません: こうしたホスト名をユーザに提供したいアプリケーションでは、Unicode にデコードしてやる必要があります。</p>
<p><a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal"><span class="pre">encodings.idna</span></code></a> ではまた、 nameprep 手続きを実装しています。 nameprep はホスト名に対してある正規化を行って、国際化ドメイン名で大小文字を区別しないようにするとともに、類似の文字を一元化します。 nameprep 関数は必要なら直接使うこともできます。</p>
<dl class="function">
<dt id="encodings.idna.nameprep">
<code class="descclassname">encodings.idna.</code><code class="descname">nameprep</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.nameprep" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>label</em> を nameprep したバージョンを返します。現在の実装ではクエリ文字列を仮定しているので、<code class="docutils literal"><span class="pre">AllowUnassigned</span></code> は真です。</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToASCII">
<code class="descclassname">encodings.idna.</code><code class="descname">ToASCII</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToASCII" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><span class="target" id="index-21"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> 仕様に従ってラベルを ASCIIに変換します。 <code class="docutils literal"><span class="pre">UseSTD3ASCIIRules</span></code> は偽であると仮定します。</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToUnicode">
<code class="descclassname">encodings.idna.</code><code class="descname">ToUnicode</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToUnicode" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><span class="target" id="index-22"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> 仕様に従ってラベルを Unicode に変換します。</p>
</dd></dl>

</div>
<div class="section" id="module-encodings.mbcs">
<span id="encodings-mbcs-windows-ansi-codepage"></span><h2>7.2.6. <a class="reference internal" href="#module-encodings.mbcs" title="encodings.mbcs: Windows ANSI codepage"><code class="xref py py-mod docutils literal"><span class="pre">encodings.mbcs</span></code></a> &#8212; Windows ANSI コードページ<a class="headerlink" href="#module-encodings.mbcs" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ANSI コードページ (CP_ACP) に対応するエンコードオペランド。</p>
<p>利用可能な環境: Windows のみ。</p>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>任意のエラーハンドラのサポート。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">バージョン 3.2 で変更: </span>3.2 以前は <em>errors</em> 引数は無視されました; エンコードには常に <code class="docutils literal"><span class="pre">'replace'</span></code> が、デコードには <code class="docutils literal"><span class="pre">'ignore'</span></code> が使われました。</p>
</div>
</div>
<div class="section" id="module-encodings.utf_8_sig">
<span id="encodings-utf-8-sig-utf-8-codec-with-bom-signature"></span><h2>7.2.7. <a class="reference internal" href="#module-encodings.utf_8_sig" title="encodings.utf_8_sig: UTF-8 codec with BOM signature"><code class="xref py py-mod docutils literal"><span class="pre">encodings.utf_8_sig</span></code></a> &#8212; BOM 印付き UTF-8<a class="headerlink" href="#module-encodings.utf_8_sig" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このモジュールは UTF-8 codec の変種を実装します。エンコーディング時は、UTF-8 でエンコードしたバイト列の前に UTF-8 でエンコードした BOM を追加します。これは内部状態を持つエンコーダで、この動作は (バイトストリームの最初の書き込み時に) 一度だけ行なわれます。デコーディング時は、データの最初に UTF-8 でエンコードされた BOM があれば、それをスキップします。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.2. <code class="docutils literal"><span class="pre">codecs</span></code> &#8212; codec レジストリと基底クラス</a><ul>
<li><a class="reference internal" href="#codec-base-classes">7.2.1. Codec 基底クラス</a><ul>
<li><a class="reference internal" href="#error-handlers">7.2.1.1. Error Handlers</a></li>
<li><a class="reference internal" href="#stateless-encoding-and-decoding">7.2.1.2. Stateless Encoding and Decoding</a></li>
<li><a class="reference internal" href="#incremental-encoding-and-decoding">7.2.1.3. Incremental Encoding and Decoding</a><ul>
<li><a class="reference internal" href="#incrementalencoder-objects">7.2.1.3.1. IncrementalEncoder オブジェクト</a></li>
<li><a class="reference internal" href="#incrementaldecoder-objects">7.2.1.3.2. IncrementalDecoder オブジェクト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-encoding-and-decoding">7.2.1.4. Stream Encoding and Decoding</a><ul>
<li><a class="reference internal" href="#streamwriter-objects">7.2.1.4.1. StreamWriter オブジェクト</a></li>
<li><a class="reference internal" href="#streamreader-objects">7.2.1.4.2. StreamReader オブジェクト</a></li>
<li><a class="reference internal" href="#streamreaderwriter-objects">7.2.1.4.3. StreamReaderWriter オブジェクト</a></li>
<li><a class="reference internal" href="#streamrecoder-objects">7.2.1.4.4. StreamRecoder オブジェクト</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#encodings-and-unicode">7.2.2. エンコーディングと Unicode</a></li>
<li><a class="reference internal" href="#standard-encodings">7.2.3. 標準エンコーディング</a></li>
<li><a class="reference internal" href="#python-specific-encodings">7.2.4. Python 特有のエンコーディング</a><ul>
<li><a class="reference internal" href="#text-encodings">7.2.4.1. テキストエンコーディング</a></li>
<li><a class="reference internal" href="#binary-transforms">7.2.4.2. Binary Transforms</a></li>
<li><a class="reference internal" href="#text-transforms">7.2.4.3. Text Transforms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-encodings.idna">7.2.5. <code class="docutils literal"><span class="pre">encodings.idna</span></code> &#8212; アプリケーションにおける国際化ドメイン名 (IDNA)</a></li>
<li><a class="reference internal" href="#module-encodings.mbcs">7.2.6. <code class="docutils literal"><span class="pre">encodings.mbcs</span></code> &#8212; Windows ANSI コードページ</a></li>
<li><a class="reference internal" href="#module-encodings.utf_8_sig">7.2.7. <code class="docutils literal"><span class="pre">encodings.utf_8_sig</span></code> &#8212; BOM 印付き UTF-8</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="struct.html"
                        title="前の章へ">7.1. <code class="docutils literal"><span class="pre">struct</span></code> &#8212; バイト列をパックされたバイナリデータとして解釈する</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="datatypes.html"
                        title="次の章へ">8. データ型</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/codecs.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="8. データ型"
             >次へ</a> |</li>
        <li class="right" >
          <a href="struct.html" title="7.1. struct — バイト列をパックされたバイナリデータとして解釈する"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準ライブラリ</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" >7. バイナリデータ処理</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>