<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>メモリ管理 &mdash; Python 3.4.3 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.4.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python/C API リファレンスマニュアル" href="index.html" />
    <link rel="next" title="オブジェクト実装サポート (object implementation support)" href="objimpl.html" />
    <link rel="prev" title="初期化 (initialization)、終了処理 (finalization)、スレッド" href="init.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="オブジェクト実装サポート (object implementation support)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="init.html" title="初期化 (initialization)、終了処理 (finalization)、スレッド"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python/C API リファレンスマニュアル</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="memory-management">
<span id="memory"></span><h1>メモリ管理<a class="headerlink" href="#memory-management" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="overview">
<span id="memoryoverview"></span><h2>概要<a class="headerlink" href="#overview" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python におけるメモリ管理には、全ての Python オブジェクトとデータ構造が入ったプライベートヒープ (private heap) が必須です。プライベートヒープの管理は、内部的には <em>Python メモリマネージャ (Python memory manager)</em> が確実に行います。Python メモリマネージャには、共有 (sharing)、セグメント分割 (segmentation)、事前割り当て (preallocation)、キャッシュ化 (caching) といった、様々な動的記憶管理の側面を扱うために、個別のコンポーネントがあります。</p>
<p>最低水準層では、素のメモリ操作関数 (raw memory allocator) がオペレーティングシステムのメモリ管理機構とやりとりして、プライベートヒープ内にPython 関連の全てのデータを記憶するのに十分な空きがあるかどうか確認します。素のメモリ操作関数の上には、いくつかのオブジェクト固有のメモリ操作関数があります。これらは同じヒープを操作し、各オブジェクト型固有の事情に合ったメモリ管理ポリシを実装しています。例えば、整数オブジェクトは文字列やタプル、辞書とは違ったやり方でヒープ内で管理されます。というのも、整数には値を記憶する上で特別な要件があり、速度/容量のトレードオフが存在するからです。このように、Python メモリマネジャは作業のいくつかをオブジェクト固有のメモリ操作関数に委譲しますが、これらの関数がプライベートヒープからはみ出してメモリ管理を行わないようにしています。</p>
<p>重要なのは、たとえユーザがいつもヒープ内のメモリブロックを指すようなオブジェクトポインタを操作しているとしても、Python 用ヒープの管理はインタプリタ自体が行うもので、ユーザがそれを制御する余地はないと理解することです。Python オブジェクトや内部使用されるバッファを入れるためのヒープ空間のメモリ確保は、必要に応じて、Python メモリマネージャがこのドキュメント内で列挙しているPython/C API 関数群を介して行います。</p>
<p id="index-0">メモリ管理の崩壊を避けるため、拡張モジュールの作者は決して Python  オブジェクトを C ライブラリが公開している関数: <code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">calloc()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">realloc()</span></code> および <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> で操作しようとしてはなりません。こうした関数を使うと、C のメモリ操作関数と Python メモリマネージャとの間で関数呼び出しが交錯します。 C のメモリ操作関数とPython メモリマネージャは異なるアルゴリズムで実装されていて、異なるヒープを操作するため、呼び出しの交錯は致命的な結果を招きます。とはいえ、個別の目的のためなら、 C ライブラリのメモリ操作関数を使って安全にメモリを確保したり解放したりできます。例えば、以下がそのような例です:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="p">...</span><span class="n">Do</span> <span class="n">some</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="n">involving</span> <span class="n">buf</span><span class="p">...</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* malloc&#39;ed */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>この例では、I/O バッファに対するメモリ要求は C ライブラリのメモリ操作関数を使っています。Python メモリマネジャは戻り値として返される文字列オブジェクトを確保する時にだけ必要です。</p>
<p>とはいえ、ほとんどの状況では、メモリの操作は Python ヒープに固定して行うよう勧めます。なぜなら、Python ヒープは Python メモリマネジャの管理下にあるからです。例えば、インタプリタを C で書かれた新たなオブジェクト型で拡張する際には、ヒープでのメモリ管理が必要です。Python ヒープを使った方がよいもう一つの理由として、拡張モジュールが必要としているメモリについて Python メモリマネージャに <em>情報を提供</em> してほしいということがあります。たとえ必要なメモリが内部的かつ非常に特化した用途に対して排他的に用いられるものだとしても、全てのメモリ操作要求を Python メモリマネージャに委譲すれば、インタプリタはより正確なメモリフットプリント (memory footprint) の全体像を把握できます。その結果、特定の状況では、Python メモリマネージャがガベージコレクションやメモリのコンパクト化、その他何らかの予防措置といった、適切な動作をトリガできることがあります。上の例で示したように C ライブラリのメモリ操作関数を使うと、I/O バッファ用に確保したメモリは Python メモリマネージャの管理から完全に外れることに注意してください。</p>
</div>
<div class="section" id="raw-memory-interface">
<h2>Raw Memory Interface<a class="headerlink" href="#raw-memory-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The following function sets are wrappers to the system allocator. These
functions are thread-safe, the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> does not
need to be held.</p>
<p>The default raw memory block allocator uses the following functions:
<code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">realloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">free()</span></code>; call <code class="docutils literal"><span class="pre">malloc(1)</span></code> when
requesting zero bytes.</p>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<dl class="function">
<dt id="c.PyMem_RawMalloc">
void* <code class="descname">PyMem_RawMalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawMalloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Allocates <em>n</em> bytes and returns a pointer of type <code class="xref c c-type docutils literal"><span class="pre">void*</span></code> to the
allocated memory, or <em>NULL</em> if the request fails. Requesting zero bytes
returns a distinct non-<em>NULL</em> pointer if possible, as if
<code class="docutils literal"><span class="pre">PyMem_RawMalloc(1)</span></code> had been called instead. The memory will not have
been initialized in any way.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawRealloc">
void* <code class="descname">PyMem_RawRealloc</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawRealloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Resizes the memory block pointed to by <em>p</em> to <em>n</em> bytes. The contents will
be unchanged to the minimum of the old and the new sizes. If <em>p</em> is <em>NULL</em>,
the call is equivalent to <code class="docutils literal"><span class="pre">PyMem_RawMalloc(n)</span></code>; else if <em>n</em> is equal to
zero, the memory block is resized but is not freed, and the returned pointer
is non-<em>NULL</em>. Unless <em>p</em> is <em>NULL</em>, it must have been returned by a
previous call to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a> or <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a>. If
the request fails, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a> returns <em>NULL</em> and <em>p</em> remains
a valid pointer to the previous memory area.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawFree">
void <code class="descname">PyMem_RawFree</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawFree" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Frees the memory block pointed to by <em>p</em>, which must have been returned by a
previous call to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a> or <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a>.
Otherwise, or if <code class="docutils literal"><span class="pre">PyMem_Free(p)</span></code> has been called before, undefined
behavior occurs. If <em>p</em> is <em>NULL</em>, no operation is performed.</p>
</dd></dl>

</div>
<div class="section" id="memory-interface">
<span id="memoryinterface"></span><h2>メモリインタフェース<a class="headerlink" href="#memory-interface" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The following function sets, modeled after the ANSI C standard, but specifying
behavior when requesting zero bytes, are available for allocating and releasing
memory from the Python heap.</p>
<p>The default memory block allocator uses the following functions:
<code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">realloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">free()</span></code>; call <code class="docutils literal"><span class="pre">malloc(1)</span></code> when
requesting zero bytes.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">The <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> must be held when using these
functions.</p>
</div>
<dl class="function">
<dt id="c.PyMem_Malloc">
void* <code class="descname">PyMem_Malloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Malloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>n</em> バイトをメモリ確保し、確保されたメモリを指す <code class="xref c c-type docutils literal"><span class="pre">void*</span></code>  型のポインタを返します。確保要求に失敗した場合には <em>NULL</em> を 返します。 0 バイトをリクエストすると、可能ならば独立した非 <em>NULL</em> のポインタを返します。このポインタは <code class="docutils literal"><span class="pre">PyMem_Malloc(1)</span></code> を代わりに呼んだときのようなメモリ領域を指しています。確保されたメモリ領域はいかなる初期化も行われていません。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Realloc">
void* <code class="descname">PyMem_Realloc</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Realloc" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>p</em> が指しているメモリブロックを <em>n</em> バイトにサイズ変更します。メモリの内容のうち、新旧のサイズのうち小さい方までの領域は変更されません。 <em>p</em> が <em>NULL</em> ならば、この関数は <code class="docutils literal"><span class="pre">PyMem_Malloc(n)</span></code> と等価になります; <em>p</em> が <em>NULL</em> ではなく <em>n</em> がゼロに等しい場合は、メモリブロックはサイズ変更されますが、解放はされず、非 <em>NULL</em> のポインタを返します。 <em>p</em> の値が <em>NULL</em> でないならば、それは以前呼び出した <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a> や <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> の返した値でなければなりません。メモリ要求が失敗した場合は、 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> は <em>NULL</em> を返し、 <em>p</em> は以前のメモリ領域への正しいポインタのままとなります。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Free">
void <code class="descname">PyMem_Free</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Free" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><em>p</em> が指すメモリブロックを解放します。 <em>p</em> は以前呼び出した <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a> や <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> の返した値でなければなりません。それ以外の場合や、 <code class="docutils literal"><span class="pre">PyMem_Free(p)</span></code> を 呼び出した後だった場合、未定義の動作になります。 <em>p</em> が <em>NULL</em> なら、何も行いません。</p>
</dd></dl>

<p>以下に挙げる型対象のマクロは利便性のために提供されているものです。<em>TYPE</em> は任意の C の型を表します。</p>
<dl class="function">
<dt id="c.PyMem_New">
TYPE* <code class="descname">PyMem_New</code><span class="sig-paren">(</span>TYPE, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_New" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a> と同じですが、 <code class="docutils literal"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> バイトのメモリを確保します。 <code class="xref c c-type docutils literal"><span class="pre">TYPE*</span></code> に型キャストされたポインタを返します。メモリには何の初期化も行われていません。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Resize">
TYPE* <code class="descname">PyMem_Resize</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em>, TYPE, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Resize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> と同じですが、 <code class="docutils literal"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> バイトにサイズ変更されたメモリを確保します。 <code class="xref c c-type docutils literal"><span class="pre">TYPE*</span></code> に型キャストされたポインタを返します。関数が終わったとき、 <em>p</em> は新しいメモリ領域のポインタか、失敗した場合は <em>NULL</em> になります。これは C プリプロセッサのマクロで、 p は常に上書きされます。エラーを処理するときにメモリを失う事を避けるには、 p の元の値を保存しておいてください。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Del">
void <code class="descname">PyMem_Del</code><span class="sig-paren">(</span>void<em>&nbsp;*p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Del" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a> と同じです。</p>
</dd></dl>

<p>上記に加えて、C API 関数を介することなく Python メモリ操作関数を直接呼び出すための以下のマクロセットが提供されています。ただし、これらのマクロは Python バージョン間でのバイナリ互換性を保てず、それゆえに拡張モジュールでは撤廃されているので注意してください。</p>
<p><code class="xref c c-func docutils literal"><span class="pre">PyMem_MALLOC()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">PyMem_REALLOC()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">PyMem_FREE()</span></code> 。</p>
<p><code class="xref c c-func docutils literal"><span class="pre">PyMem_NEW()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">PyMem_RESIZE()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">PyMem_DEL()</span></code> 。</p>
</div>
<div class="section" id="customize-memory-allocators">
<h2>Customize Memory Allocators<a class="headerlink" href="#customize-memory-allocators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<dl class="type">
<dt id="c.PyMemAllocator">
<code class="descname">PyMemAllocator</code><a class="headerlink" href="#c.PyMemAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Structure used to describe a memory block allocator. The structure has
four fields:</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">フィールド</p>
</th>
<th class="head"><p class="first last">意味</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">*ctx</span></code></td>
<td>user context passed as first argument</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">void*</span> <span class="pre">malloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></td>
<td>allocate a memory block</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void*</span> <span class="pre">realloc(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">size_t</span> <span class="pre">new_size)</span></code></td>
<td>allocate or resize a memory block</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></td>
<td>free a memory block</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="type">
<dt id="c.PyMemAllocatorDomain">
<code class="descname">PyMemAllocatorDomain</code><a class="headerlink" href="#c.PyMemAllocatorDomain" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Enum used to identify an allocator domain. Domains:</p>
<ul class="simple">
<li><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_RAW</span></code>: functions <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a>,
<a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a> and <a class="reference internal" href="#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawFree()</span></code></a></li>
<li><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_MEM</span></code>: functions <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>,
<a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a> and <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a></li>
<li><code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_OBJ</span></code>: functions <code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">PyObject_Realloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">PyObject_Free()</span></code></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_GetAllocator">
void <code class="descname">PyMem_GetAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain">PyMemAllocatorDomain</a><em>&nbsp;domain</em>, <a class="reference internal" href="#c.PyMemAllocator" title="PyMemAllocator">PyMemAllocator</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_GetAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Get the memory block allocator of the specified domain.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_SetAllocator">
void <code class="descname">PyMem_SetAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain">PyMemAllocatorDomain</a><em>&nbsp;domain</em>, <a class="reference internal" href="#c.PyMemAllocator" title="PyMemAllocator">PyMemAllocator</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Set the memory block allocator of the specified domain.</p>
<p>The new allocator must return a distinct non-NULL pointer when requesting
zero bytes.</p>
<p>For the <code class="xref c c-data docutils literal"><span class="pre">PYMEM_DOMAIN_RAW</span></code> domain, the allocator must be
thread-safe: the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> is not held when the
allocator is called.</p>
<p>If the new allocator is not a hook (does not call the previous allocator),
the <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> function must be called to reinstall the
debug hooks on top on the new allocator.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_SetupDebugHooks">
void <code class="descname">PyMem_SetupDebugHooks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetupDebugHooks" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Setup hooks to detect bugs in the following Python memory allocator
functions:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a>,
<a class="reference internal" href="#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawFree()</span></code></a></li>
<li><a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Realloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></code></a></li>
<li><code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">PyObject_Realloc()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">PyObject_Free()</span></code></li>
</ul>
<p>Newly allocated memory is filled with the byte <code class="docutils literal"><span class="pre">0xCB</span></code>, freed memory is
filled with the byte <code class="docutils literal"><span class="pre">0xDB</span></code>. Additional checks:</p>
<ul class="simple">
<li>detect API violations, ex: <code class="xref c c-func docutils literal"><span class="pre">PyObject_Free()</span></code> called on a buffer
allocated by <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_Malloc()</span></code></a></li>
<li>detect write before the start of the buffer (buffer underflow)</li>
<li>detect write after the end of the buffer (buffer overflow)</li>
</ul>
<p>The function does nothing if Python is not compiled is debug mode.</p>
</dd></dl>

</div>
<div class="section" id="customize-pyobject-arena-allocator">
<h2>Customize PyObject Arena Allocator<a class="headerlink" href="#customize-pyobject-arena-allocator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python has a <em>pymalloc</em> allocator for allocations smaller than 512 bytes. This
allocator is optimized for small objects with a short lifetime. It uses memory
mappings called &#8220;arenas&#8221; with a fixed size of 256 KB. It falls back to
<a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawMalloc()</span></code></a> and <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal"><span class="pre">PyMem_RawRealloc()</span></code></a> for allocations larger
than 512 bytes.  <em>pymalloc</em> is the default allocator used by
<code class="xref c c-func docutils literal"><span class="pre">PyObject_Malloc()</span></code>.</p>
<p>The default arena allocator uses the following functions:</p>
<ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">VirtualAlloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">VirtualFree()</span></code> on Windows,</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">munmap()</span></code> if available,</li>
<li><code class="xref c c-func docutils literal"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> otherwise.</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified">バージョン 3.4 で追加.</span></p>
</div>
<dl class="type">
<dt id="c.PyObjectArenaAllocator">
<code class="descname">PyObjectArenaAllocator</code><a class="headerlink" href="#c.PyObjectArenaAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Structure used to describe an arena allocator. The structure has
three fields:</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">フィールド</p>
</th>
<th class="head"><p class="first last">意味</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">*ctx</span></code></td>
<td>user context passed as first argument</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">void*</span> <span class="pre">alloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></td>
<td>allocate an arena of size bytes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></td>
<td>free an arena</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GetArenaAllocator">
<code class="descname">PyObject_GetArenaAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator">PyObjectArenaAllocator</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GetArenaAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Get the arena allocator.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_SetArenaAllocator">
<code class="descname">PyObject_SetArenaAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator">PyObjectArenaAllocator</a><em>&nbsp;*allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_SetArenaAllocator" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Set the arena allocator.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="memoryexamples"></span><h2>例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>最初に述べた関数セットを使って、 <a class="reference internal" href="#memoryoverview"><span>概要</span></a> 節の例を Python ヒープに I/O バッファをメモリ確保するように書き換えたものを以下に示します:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* allocated with PyMem_Malloc */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>同じコードを型対象の関数セットで書いたものを以下に示します:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* allocated with PyMem_New */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>上の二つの例では、バッファを常に同じ関数セットに属する関数で操作していることに注意してください。実際、あるメモリブロックに対する操作は、異なるメモリ操作機構を混用する危険を減らすために、同じメモリ API ファミリを使って行うことが必要です。以下のコードには二つのエラーがあり、そのうちの一つには異なるヒープを操作する別のメモリ操作関数を混用しているので <em>致命的 (Fatal)</em> とラベルづけをしています。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">buf1</span> <span class="o">=</span> <span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf3</span><span class="p">);</span>  <span class="cm">/* Wrong -- should be PyMem_Free() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>       <span class="cm">/* Right -- allocated via malloc() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>       <span class="cm">/* Fatal -- should be PyMem_Del()  */</span>
</pre></div>
</div>
<p>素のメモリブロックを Python ヒープ上で操作する関数に加え、 <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_New()</span></code></a> 、 <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal"><span class="pre">PyObject_NewVar()</span></code></a> 、および <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal"><span class="pre">PyObject_Del()</span></code></a> を使うと、 Python におけるオブジェクトをメモリ確保したり解放したりできます。</p>
<p>これらの関数については、次章の C による新しいオブジェクト型の定義や実装に関する記述の中で説明します。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">メモリ管理</a><ul>
<li><a class="reference internal" href="#overview">概要</a></li>
<li><a class="reference internal" href="#raw-memory-interface">Raw Memory Interface</a></li>
<li><a class="reference internal" href="#memory-interface">メモリインタフェース</a></li>
<li><a class="reference internal" href="#customize-memory-allocators">Customize Memory Allocators</a></li>
<li><a class="reference internal" href="#customize-pyobject-arena-allocator">Customize PyObject Arena Allocator</a></li>
<li><a class="reference internal" href="#examples">例</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="init.html"
                        title="前の章へ">初期化 (initialization)、終了処理 (finalization)、スレッド</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="objimpl.html"
                        title="次の章へ">オブジェクト実装サポート (object implementation support)</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/c-api/memory.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="オブジェクト実装サポート (object implementation support)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="init.html" title="初期化 (initialization)、終了処理 (finalization)、スレッド"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API リファレンスマニュアル</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>