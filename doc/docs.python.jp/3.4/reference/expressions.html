<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. 式 (expression) &mdash; Python 3.4.3 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.4.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 ドキュメント" href="../contents.html" />
    <link rel="up" title="Python 言語リファレンス" href="index.html" />
    <link rel="next" title="7. 単純文 (simple statement)" href="simple_stmts.html" />
    <link rel="prev" title="5. インポートシステム" href="import.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python 言語リファレンス</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>6. 式 (expression)<a class="headerlink" href="#expressions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0">この章では、Python の式における個々の要素の意味について解説します。</p>
<p><strong>表記法に関する注意:</strong> この章と以降の章での拡張BNF  (extended BNF) 表記は、字句解析規則ではなく、構文規則を記述するために用いられています。ある構文規則 (のある表現方法) が、以下の形式</p>
<pre>
<strong id="grammar-token-name">name</strong> ::=  <code class="xref docutils literal"><span class="pre">othername</span></code>
</pre>
<p>で記述されていて、この構文特有の意味付け (semantics) が記述されていない場合、<code class="docutils literal"><span class="pre">name</span></code> の形式をとる構文の意味付けは <code class="docutils literal"><span class="pre">othername</span></code> の意味付けと同じになります。</p>
<div class="section" id="arithmetic-conversions">
<span id="conversions"></span><h2>6.1. 算術変換 (arithmetic conversion)<a class="headerlink" href="#arithmetic-conversions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-1">以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と書かれているとき、組み込み型に対する演算子の実装は以下の通りにはたらきます:</p>
<ul class="simple">
<li><p class="first">片方の引数が複素数型であれば、他方は複素数型に変換されます;</p>
</li>
<li><p class="first">それ以外の場合で、片方の引数が浮動小数点数であれば、他方は浮動小数点型に変換されます;</p>
</li>
<li><p class="first">それ以外場合は、両方の引数は整数でなければならず、変換の必要はありません。</p>
</li>
</ul>
<p>特定の演算子 (&#8216;%&#8217; 演算子の左引数としての文字列) には、さらに別の規則が適用されます。拡張は、それ自身の型変換のふるまいを定義していなければなりません。</p>
</div>
<div class="section" id="atoms">
<span id="id2"></span><h2>6.2. Atom (原始的要素)<a class="headerlink" href="#atoms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-2">atom は、式の一番基本的な要素です。もっとも単純な atom は、識別子またはリテラルです。丸括弧、角括弧、または波括弧で囲われた形式 (form) もまた、構文上アトムに分類されます。atom の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-atom">atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-literal"><code class="xref docutils literal"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-enclosure"><code class="xref docutils literal"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-enclosure">enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-parenth_form"><code class="xref docutils literal"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-list_display"><code class="xref docutils literal"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-dict_display"><code class="xref docutils literal"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-set_display"><code class="xref docutils literal"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-generator_expression"><code class="xref docutils literal"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-yield_atom"><code class="xref docutils literal"><span class="pre">yield_atom</span></code></a>
</pre>
<div class="section" id="atom-identifiers">
<span id="identifiers-names"></span><h3>6.2.1. 識別子 (identifier、または名前 (name))<a class="headerlink" href="#atom-identifiers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-3">アトムの形になっている識別子 (identifier) は名前 (name) です。字句定義については <a class="reference internal" href="lexical_analysis.html#identifiers"><span>識別子 (identifier) およびキーワード (keyword)</span></a> 節を、名前付けや束縛については <a class="reference internal" href="executionmodel.html#naming"><span>名前づけと束縛 (naming and binding)</span></a> 節を参照してください。</p>
<p id="index-4">名前があるオブジェクトに束縛されている場合、名前 atom を評価するとそのオブジェクトになります。名前が束縛されていない場合、 atom を評価しようとすると <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a> 例外を送出します。</p>
<p id="index-5"><strong>プライベートな名前の名前修飾:</strong> クラス定義内に書かれた識別子で、2つ以上のアンダースコアから始まり、末尾が2つ以上のアンダースコアで終わっていないものは、そのクラスの <em class="dfn">プライベートな名前</em> とみなされます。プライベートな名前は、コードが生成される前により長い形式に変換されます。この変換によって、クラス名の先頭にアンダースコアがあれば除去し、先頭にアンダースコアを1つ付加し、名前の前に挿入されます。例えば、クラス名 <code class="docutils literal"><span class="pre">Ham</span></code> の中の識別子 <code class="docutils literal"><span class="pre">__spam</span></code> は、<code class="docutils literal"><span class="pre">_Ham__spam</span></code> に変換されます。変換は識別子が使用されている構文のコンテキストからは独立しています。変換された名前が非常に長い (255文字を超える) 場合、実装によっては名前の切り詰めが行われるかもしれません。クラス名がアンダースコアのみから成る場合は変換は行われません。</p>
</div>
<div class="section" id="literals">
<span id="atom-literals"></span><h3>6.2.2. リテラル<a class="headerlink" href="#literals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-6">Python では、文字列やバイト列リテラルと、様々な数値リテラルをサポートしています:</p>
<pre>
<strong id="grammar-token-literal">literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-stringliteral"><code class="xref docutils literal"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-bytesliteral"><code class="xref docutils literal"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-integer"><code class="xref docutils literal"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-floatnumber"><code class="xref docutils literal"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-imagnumber"><code class="xref docutils literal"><span class="pre">imagnumber</span></code></a>
</pre>
<p>リテラルの評価は、与えられた型 (文字列、バイト列、整数、浮動小数点数、複素数) の与えられた値を持つオブジェクトを与えます。浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合があります。詳しくは <a class="reference internal" href="lexical_analysis.html#literals"><span>リテラル</span></a> を参照してください。</p>
<p id="index-7">リテラルは全て変更不能なデータ型に対応します。このため、オブジェクトの同一性はオブジェクトの値ほど重要ではありません。同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルがプログラムの同じ場所由来のものであっても、そうでなくても) 同じオブジェクトを指しているか、まったく同じ値を持つ別のオブジェクトになります。</p>
</div>
<div class="section" id="parenthesized-forms">
<span id="parenthesized"></span><h3>6.2.3. 丸括弧形式 (parenthesized form)<a class="headerlink" href="#parenthesized-forms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-8">丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:</p>
<pre>
<strong id="grammar-token-parenth_form">parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a>] &quot;)&quot;
</pre>
<p>丸括弧で囲われた式のリストは、個々の式が表現するものになります: リスト内に少なくとも一つのカンマが入っていた場合、タプルになります; そうでない場合、式のリストを構成している単一の式自体の値になります。</p>
<p id="index-9">中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、空のタプルが二箇所で使われると、それらは同じオブジェクトになることもあるし、ならないこともあります)。</p>
<p id="index-10">タプルは丸括弧で作成されるのではなく、カンマによって作成されることに注意してください。例外は空のタプルで、この場合には丸括弧が <em>必要です</em> &#8212; 丸括弧のつかない &#8220;何も記述しない式 (nothing)&#8221; を使えるようにしてしまうと、文法があいまいなものになってしまい、よくあるタイプミスが検出されなくなってしまいます。</p>
</div>
<div class="section" id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3>6.2.4. リスト、集合、辞書の表示<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python は、リスト、集合、または辞書を構成するために、&#8221;表示 (display)&#8221; と呼ばれる特殊な構文を、それぞれ二種類づつ提供していて、コンテナの内容は:</p>
<ul class="simple">
<li><p class="first">明示的に列挙される、または</p>
</li>
<li><p class="first"><em class="dfn">内包表記 (comprehension)</em> と呼ばれる、ループ処理とフィルター処理の命令の組み合わせを通じて計算されます。</p>
</li>
</ul>
<p>内包表記の共通の構文要素はこの通りです:</p>
<pre>
<strong id="grammar-token-comprehension">comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-comp_for">comp_for     </strong> ::=  &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-target_list"><code class="xref docutils literal"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-comp_iter">comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-comp_if"><code class="xref docutils literal"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-comp_if">comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-expression_nocond"><code class="xref docutils literal"><span class="pre">expression_nocond</span></code></a> [<a class="reference internal" href="#grammar-token-comp_iter"><code class="xref docutils literal"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>内包表記はまず単一の式、続いて <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節、さらに続いて 0 個以上の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節や <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節からなります。この場合、新たなコンテナの各要素は、各々の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> や <a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> 節を、左から右にネストしたブロックとみなして実行し、ネストの最内のブロックに到達する度に式を評価することで作成されたものになります。</p>
<p>なお、これらの内包表記は別のスコープで実行されるので、対象のリスト内で代入された名前が外側のスコープに &#8220;漏れる&#8221; ことはありません。</p>
</div>
<div class="section" id="list-displays">
<span id="lists"></span><h3>6.2.5. リスト表現<a class="headerlink" href="#list-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-11">リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-list_display">list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>リスト表示は、新しいリストオブジェクトを与えます。リストの内容は、式リストか、リスト内包表記 (list comprehension) で指定されます。カンマで区切られた一連の式が与えられたときは、それらの各要素は左から右へと順に評価され、その順にリスト内に配置されます。内包表記が与えられたときは、内包表記の結果の要素でリストが構成されます。</p>
</div>
<div class="section" id="set-displays">
<span id="set"></span><h3>6.2.6. 集合表現<a class="headerlink" href="#set-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-12">集合表現は波括弧で表され、キーと値を分けるコロンがないことで辞書表現と区別されます:</p>
<pre>
<strong id="grammar-token-set_display">set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>集合表示は、一連の式または内包表記によって指定された内容の、ミュータブルな集合オブジェクトを与えます。カンマ区切りの一連の式が与えられたときは、その要素は左から右へ順に評価され、集合オブジェクトに加えられます。内包表記が与えられたときは、内包表記の結果となる要素で集合が構成されます。</p>
<p>空集合は <code class="docutils literal"><span class="pre">{}</span></code> で構成できません。このリテラルは空の辞書を構成します。</p>
</div>
<div class="section" id="dictionary-displays">
<span id="dict"></span><h3>6.2.7. 辞書表現<a class="headerlink" href="#dictionary-displays" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-13">辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-dict_display">dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-key_datum_list"><code class="xref docutils literal"><span class="pre">key_datum_list</span></code></a> | <a class="reference internal" href="#grammar-token-dict_comprehension"><code class="xref docutils literal"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-key_datum_list">key_datum_list    </strong> ::=  <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal"><span class="pre">key_datum</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-key_datum"><code class="xref docutils literal"><span class="pre">key_datum</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-key_datum">key_datum         </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-dict_comprehension">dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a>
</pre>
<p>辞書表現は、新たな辞書オブジェクトを表します。</p>
<p>カンマ区切りの一連のキー/データの対が与えられたときは、その要素は左から右へ評価され、辞書の項目を定義します。すなわち、それぞれのキーオブジェクトが、辞書内で対応するデータを保存するキーとして使われます。これにより、キー/データリストの中で同じキーを複数回指定することができ、そのキーに対する最終的な辞書の値は、最後に与えられたものになります。</p>
<p>辞書内包表記は、リストや集合の内包表記とは対照的に、通常の &#8220;for&#8221; や &#8220;if&#8221; 節の前に、コロンで分けられた 2 つの式が必要です。内包表記が起動すると、結果のキーと値の要素が、作られた順に新しい辞書に挿入されます。</p>
<p id="index-14">キーの値として使える型に関する制限は <a class="reference internal" href="datamodel.html#types"><span>標準型の階層</span></a> 節ですでに列挙しています。(一言でいうと、キーは変更可能なオブジェクトを全て排除した <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> でなければなりません。) 重複するキー間で衝突が起きても、衝突が検出されることはありません; あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、辞書表記の最も右側値となるもの) が使われます。</p>
</div>
<div class="section" id="generator-expressions">
<span id="genexpr"></span><h3>6.2.8. ジェネレータ式<a class="headerlink" href="#generator-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-15">ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトなジェネレータ表記法です:</p>
<pre>
<strong id="grammar-token-generator_expression">generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-comp_for"><code class="xref docutils literal"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>ジェネレータ式は新たなジェネレータオブジェクトを与えます。この構文は内包表記とほぼ同じですが、角括弧や波括弧ではなく、丸括弧で囲まれます。</p>
<p>ジェネレータ式の中で使われている変数は、 (通常のジェネレータと同じように) そのジェネレータオブジェクトに対して <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドが呼ばれたときに遅延評価されます。ただし、最も左に位置する <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節は直ちに評価されるため、そこで生じたエラーは、 ジェネレータ式を扱うコードの中で起きる他のエラーよりも前に表示されます。前の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループに依存するかもしれないので、後の <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 節は即座に評価することができません。例えば: <code class="docutils literal"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">bar(x))</span></code> 。</p>
<p>関数の唯一の引数として渡す場合には、丸括弧を省略できます。詳しくは <a class="reference internal" href="#calls"><span>呼び出し (call)</span></a> 節を参照してください。</p>
</div>
<div class="section" id="yield-expressions">
<span id="yieldexpr"></span><h3>6.2.9. Yield 式<a class="headerlink" href="#yield-expressions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<pre id="index-16">
<strong id="grammar-token-yield_atom">yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-yield_expression"><code class="xref docutils literal"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-yield_expression">yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> | &quot;from&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
</pre>
<p>yield 式は <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">ジェネレータ</span></a> 関数の関数定義内でのみ使用されます。関数本体中で yield 式 を使用すると、その関数はジェネレータになります。</p>
<p>ジェネレータ関数が呼び出された時、ジェネレータとしてのイテレータを返します。ジェネレータはその後ジェネレータ関数の実行を制御します。ジェネレータのメソッドが呼び出されると実行が開始されます。開始されると、最初の yield 式まで処理して一時停止し、呼び出し元へ <a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> の値を返します。ここで言う一時停止とは、ローカル変数の束縛、命令ポインタや内部の評価スタック、そして例外処理のを含むすべてのローカル状態が保持されることを意味します。再度、ジェネレータのメソッドが呼び出されて実行を再開した時、ジェネレータは yield 式がただの外部呼び出しであったかのように処理を継続します。再開後の yield 式の値は実行を再開するメソッドに依存します。<a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> を使用した場合 (一般に <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> 文や組み込み関数 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a> など) の結果は <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> となり、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> を使用した場合はそのメソッドに渡された値が結果になります。</p>
<p id="index-17">これまで説明した内容から、ジェネレータ関数はコルーチンにとてもよく似ています。ジェネレータ関数は何度も生成し、1つ以上のエントリポイントを持ち、その実行は一時停止されます。ジェネレータ関数は yield した後で実行の継続を制御できないことが唯一の違いです。その制御は常にジェネレータの呼び出し元へ移されます。</p>
<p>yield 式は <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a> 構造内で使用できます。ジェネレータの (参照カウントがゼロに達するか、ガベージコレクションによる) 完了前に再開されない場合、ジェネレータ-イテレータの <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> メソッドが呼ばれ、<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal"><span class="pre">finally</span></code></a> 節が実行されます。</p>
<p><code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> を使用した場合、与えられた式はサブイテレータとして扱われます。サブイテレータによって生成されたすべての値は現在のジェネレータのメソッドの呼び出し元へ直接渡されます。<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> で渡されたあらゆる値と <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal"><span class="pre">throw()</span></code></a> で渡されたあらゆる例外は根底のイテレータに適切なメソッドがあれば渡されます。適切なメソッドがない場合、<a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> は <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> か <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を、<a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal"><span class="pre">throw()</span></code></a> は渡された例外を即座に送出します。</p>
<p>根底のイテレータの完了時、引き起こされた <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> インスタンスの <code class="xref py py-attr docutils literal"><span class="pre">value</span></code> 属性はその yield 式の値となります。 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を起こす際に明示的にセットされるか、サブイテレータがジェネレータであれば (サブイテレータからかえる値で) 自動的にセットされるかのどちらかです。</p>
<blockquote>
<div><div class="versionchanged">
<p><span class="versionmodified">バージョン 3.3 で変更: </span>サブイテレータに制御フローを委譲するために <code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> が追加されました。</p>
</div>
</div></blockquote>
<p>yield 式が代入文の単独の右辺式であるとき、括弧は省略できます。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-18"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0255"><strong>PEP 0255</strong></a> - Simple Generators</dt>
<dd><p class="first last">Python へのジェネレータと <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 文の導入提案。</p>
</dd>
<dt><span class="target" id="index-19"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 0342</strong></a> - Coroutines via Enhanced Generators</dt>
<dd><p class="first last">シンプルなコルーチンとして利用できるように、ジェネレータの構文と API を拡張する提案です。</p>
</dd>
<dt><span class="target" id="index-20"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0380"><strong>PEP 0380</strong></a> - Syntax for Delegating to a Subgenerator</dt>
<dd><p class="first last">サブジェネレータの委譲を簡単にするための、 <code class="xref std std-token docutils literal"><span class="pre">yield_from</span></code> 構文の導入提案。</p>
</dd>
</dl>
</div>
<div class="section" id="generator-iterator-methods">
<span id="index-21"></span><h4>6.2.9.1. ジェネレータ-イテレータメソッド<a class="headerlink" href="#generator-iterator-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>この説ではジェネレータイテレータのメソッドについて説明します。これらはジェネレータ関数の実行制御に使用できます。</p>
<p>以下のジェネレータメソッドの呼び出しは、ジェネレータが既に実行中の場合 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> 例外を送出する点に注意してください。</p>
<span class="target" id="index-22"></span><dl class="method">
<dt id="generator.__next__">
<code class="descclassname">generator.</code><code class="descname">__next__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の実行を開始するか、最後に yield 式が実行されたところから再開します。ジェネレータ関数が <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドによって再開された時、その時点の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式の値は常に <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> と評価されます。その後次の <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal"><span class="pre">yield</span></code></a> 式まで実行し、ジェネレータは一時停止し、<a class="reference internal" href="#grammar-token-expression_list"><code class="xref std std-token docutils literal"><span class="pre">expression_list</span></code></a> の値を <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal"><span class="pre">__next__()</span></code></a> メソッドの呼び出し元に返します。ジェネレータが次の値を yield せずに終了した場合、<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 例外が送出されます。</p>
<p>このメソッドは通常、例えば <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal"><span class="pre">for</span></code></a> ループや組み込みの <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal"><span class="pre">next()</span></code></a> 関数によって暗黙に呼び出されます。</p>
</dd></dl>

<dl class="method">
<dt id="generator.send">
<code class="descclassname">generator.</code><code class="descname">send</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数の内部へ値を &#8220;送り&#8221;、実行を再開します。引数の <em>value</em> はその時点の yield 式の結果になります。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> メソッドは次にジェネレータが生成した値を返し、ジェネレータが次の値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> を送出します。 <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal"><span class="pre">send()</span></code></a> が呼び出されてジェネレータが開始するときは、値を受け取る yield 式が存在しないので、 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal"><span class="pre">None</span></code></a> を引数として呼び出さなければなりません。</p>
</dd></dl>

<dl class="method">
<dt id="generator.throw">
<code class="descclassname">generator.</code><code class="descname">throw</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>value</em><span class="optional">[</span>, <em>traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータが中断した位置で <code class="docutils literal"><span class="pre">type</span></code> 型の例外を発生させて、そのジェネレータ関数が生成する次の値を返します。ジェネレータが値を生成することなく終了すると <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> が発生します。ジェネレータ関数が渡された例外を捕捉しない、もしくは違う例外を発生させるなら、その例外は呼び出し元へ伝搬されます。</p>
</dd></dl>

<span class="target" id="index-23"></span><dl class="method">
<dt id="generator.close">
<code class="descclassname">generator.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ジェネレータ関数が中断した位置で <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> を発生させます。ジェネレータ関数が (通常の終了または既にクローズされたことで) <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code></a> 、もしくは (例外を捕捉しないことで) <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal"><span class="pre">GeneratorExit</span></code></a> を発生させる場合 close() は呼び出し元へ返されます。ジェネレータが値を生成する場合 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> が発生します。 <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> はジェネレータが通常の終了または例外により既に終了している場合は何もしません。</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="index-24"></span><h4>6.2.9.2. 例<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>以下の簡単なサンプルはジェネレータとジェネレータ関数の振る舞いを実際に紹介します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></code> の使用例は、<a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span>PEP 380: サブジェネレータへの委譲構文</span></a> in &#8220;What&#8217;s New in Python.&#8221; を参照してください。</p>
</div>
</div>
</div>
<div class="section" id="primaries">
<span id="id3"></span><h2>6.3. プライマリ<a class="headerlink" href="#primaries" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-25">プライマリは、言語において最も結合の強い操作を表します。文法は以下のようになります:</p>
<pre>
<strong id="grammar-token-primary">primary</strong> ::=  <a class="reference internal" href="#grammar-token-atom"><code class="xref docutils literal"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-attributeref"><code class="xref docutils literal"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-subscription"><code class="xref docutils literal"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-slicing"><code class="xref docutils literal"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-call"><code class="xref docutils literal"><span class="pre">call</span></code></a>
</pre>
<div class="section" id="attribute-references">
<span id="id4"></span><h3>6.3.1. 属性参照<a class="headerlink" href="#attribute-references" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p id="index-26">属性参照は、プライマリの後ろにピリオドと名前を連ねたものです:</p>
<pre>
<strong id="grammar-token-attributeref">attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-27">プライマリの評価は、属性参照をサポートする型のオブジェクトでなければならず、これにはほとんどのオブジェクトが当てはまります。そしてこのオブジェクトは、名前が指定した識別子名であるような属性を生成しなければなりません。この生成は <a class="reference internal" href="datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal"><span class="pre">__getattr__()</span></code></a> メソッドをオーバーライドすることでカスタマイズできます。その属性が得られなければ、例外 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal"><span class="pre">AttributeError</span></code></a> が送出されます。そうでなければ、生成されるオブジェクトの型と値は、属性を生成したオブジェクトにより決まります。同じ属性参照を複数回評価すると、互いに異なる属性オブジェクトが得られることがあります。</p>
</div>
<div class="section" id="subscriptions">
<span id="id5"></span><h3>6.3.2. 添字表記 (subscription)<a class="headerlink" href="#subscriptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-28"></span><p id="index-29">添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書) オブジェクトから、要素を一つ選択します:</p>
<pre>
<strong id="grammar-token-subscription">subscription</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expression_list"><code class="xref docutils literal"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>プライマリの評価は、添字表記をサポートするオブジェクト (例えばリストや辞書) でなければなりません。ユーザ定義のオブジェクトは、 <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドを定義することで添字表記をサポートできます。</p>
<p>組み込みオブジェクトでは、添字表記をサポートするオブジェクトには 2 種類あります:</p>
<p>プライマリがマップであれば、式リストの値評価結果はマップ内のいずれかのキー値に相当するオブジェクトにならなければなりません。添字表記は、そのキーに対応するマップ内の値 (value) を選択します。(式リストの要素が単独である場合を除き、式リストはタプルでなければなりません。)</p>
<p>プライマリがシーケンスであれば、式 (リスト) の評価は整数またはスライス (以下の節で論じます) でなければなりません。</p>
<p>形式的な構文はシーケンスの負のインデックスにいかなる特例も与えません。しかし、すべての組み込みのシーケンスが与える <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドは、負のインデックスを、インデックスにシーケンスの長さを加えて解釈します (つまり、 <code class="docutils literal"><span class="pre">x[-1]</span></code> は <code class="docutils literal"><span class="pre">x</span></code> の最後の要素を選択します)。結果の値はシーケンスの要素数より小さな非負の整数でなければなりません。添字表記は、(0 から数えた) インデックスを持つ要素を選択します。負のインデックスのサポートは、オブジェクトの <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドに現れるので、このメソッドをオーバーライドするサブクラスは、明示的にこのサポートを追加する必要があります。</p>
<p id="index-30">文字列型の要素は文字 (character) です。文字は個別の型ではなく、1 文字だけからなる文字列です。</p>
</div>
<div class="section" id="slicings">
<span id="id6"></span><h3>6.3.3. スライス表記 (slicing)<a class="headerlink" href="#slicings" title="このヘッドラインへのパーマリンク">¶</a></h3>
<span class="target" id="index-31"></span><p id="index-32">スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト) におけるある範囲の要素を選択します。スライス表記は式として用いたり、代入や <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal"><span class="pre">del</span></code></a> 文の対象として用いたりできます。スライス表記の構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-slicing">slicing     </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-slice_list"><code class="xref docutils literal"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-slice_list">slice_list  </strong> ::=  <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-slice_item"><code class="xref docutils literal"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-slice_item">slice_item  </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-proper_slice"><code class="xref docutils literal"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-proper_slice">proper_slice</strong> ::=  [<a class="reference internal" href="#grammar-token-lower_bound"><code class="xref docutils literal"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-upper_bound"><code class="xref docutils literal"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-stride"><code class="xref docutils literal"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-lower_bound">lower_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-upper_bound">upper_bound </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-stride">stride      </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
</pre>
<p>上記の形式的な構文法にはあいまいなところがあります: 式リストに見えるものは、スライスリストにも見えるため、添字表記はスライス表記としても解釈されうるということです。(スライスリストが適切なスライスを含まない場合)、これ以上の構文の複雑化はせず、スライス表記としての解釈よりも添字表記としての解釈が優先されるように定義することで、あいまいさを取り除いています。</p>
<p id="index-33">スライス表記に対する意味付けは、以下のようになります。プライマリの値評価結果は、以下に述べるようにしてスライスリストから生成されたキーによって (通常の添字表記と同じ <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> メソッドを使って) インデクス指定できなければなりません。スライスリストに一つ以上のカンマが含まれている場合、キーは各スライス要素を値変換したものからなるタプルになります; それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。一個の式であるスライス要素は、その式に変換されます。適切なスライスは、スライスオブジェクト (<a class="reference internal" href="datamodel.html#types"><span>標準型の階層</span></a> 参照) に変換され、その <code class="xref py py-attr docutils literal"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal"><span class="pre">stop</span></code> および <code class="xref py py-attr docutils literal"><span class="pre">step</span></code>  属性は、それぞれ指定した下境界、上境界、およびとび幅 (stride) になります。式がない場所は <code class="docutils literal"><span class="pre">None</span></code> で置き換えられます。</p>
</div>
<div class="section" id="calls">
<span id="index-34"></span><span id="id7"></span><h3>6.3.4. 呼び出し (call)<a class="headerlink" href="#calls" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>呼び出しは、呼び出し可能オブジェクト (例えば <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">function</span></a>) を <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">arguments</span></a> の系列とともに呼び出します。系列は空の系列であってもかまいません:</p>
<pre>
<strong id="grammar-token-call">call                </strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-argument_list"><code class="xref docutils literal"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-comprehension"><code class="xref docutils literal"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-argument_list">argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-positional_arguments"><code class="xref docutils literal"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a>]
                            [&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>] [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a>]
                            [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a> [&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a>] [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                          | &quot;*&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_arguments"><code class="xref docutils literal"><span class="pre">keyword_arguments</span></code></a>] [&quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
                          | &quot;**&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-positional_arguments">positional_arguments</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-keyword_arguments">keyword_arguments   </strong> ::=  <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-keyword_item"><code class="xref docutils literal"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-keyword_item">keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-identifier"><code class="xref docutils literal"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
</pre>
<p>最後の固定引数やキーワード引数の後にカンマをつけてもかまいません。構文の意味付けに影響を及ぼすことはありません。</p>
<p id="index-35">プライマリの評価は呼び出し可能オブジェクトでなければなりません。 (ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、クラスオブジェクト、クラスインスタンスのメソッド、および <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドを持つ全てのオブジェクトが呼び出し可能です)。引数式は全て、呼び出しを試みる前に評価されます。仮引数 (formal <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a>) リストの構文については <a class="reference internal" href="compound_stmts.html#function"><span>関数定義</span></a> を参照してください。</p>
<p>キーワード引数が存在する場合、以下のようにして最初に固定引数 (positional argument) に変換されます。まず、値の入っていないスロットが仮引数に対して生成されます。N 個の固定引数がある場合、固定引数は先頭の N スロットに配置されます。次に、各キーワード引数について、識別子を使って対応するスロットを決定します (識別子が最初の仮引数パラメタ名と同じなら、最初のスロットを使う、といった具合です)。スロットがすでにすべて埋まっていたなら <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。それ以外の場合、引数値をスロットに埋めていきます。 (式が <code class="docutils literal"><span class="pre">None</span></code> であっても、その式でスロットを埋めます)。全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、関数が定義されたときに一度だけ計算されます; 従って、リストや辞書のような変更可能なオブジェクトがデフォルト値として使われると、対応するスロットに引数を指定しない限り、このオブジェクトが全ての呼び出しから共有されます; このような状況は通常避けるべきです。) デフォルト値が指定されていない、値の埋められていないスロットが残っている場合 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。そうでない場合、値の埋められたスロットからなるリストが呼び出しの引数として使われます。</p>
<div class="impl-detail compound">
<p>実装では、名前を持たない固定引数を受け取る組み込み関数を提供するかもしれません。そういった引数がドキュメント化のために &#8216;名付けられて&#8217; いたとしても、実際には名付けられていないのでキーワードによって提供されません。 CPython では、C 言語で実装された関数の、名前を持たない固定引数を解析するために <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></code></a> を使用します。</p>
</div>
<p>仮引数スロットの数よりも多くの固定引数がある場合、構文 <code class="docutils literal"><span class="pre">*identifier</span></code> を使って指定された仮引数がないかぎり、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal"><span class="pre">*identifier</span></code> がある場合、この仮引数は余分な固定引数が入ったタプル (もしくは、余分な固定引数がない場合には空のタプル) を受け取ります。</p>
<p>キーワード引数のいずれかが仮引数名に対応しない場合、構文 <code class="docutils literal"><span class="pre">**identifier</span></code> を使って指定された仮引数がない限り、 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます; 仮引数 <code class="docutils literal"><span class="pre">**identifier</span></code> がある場合、この仮引数は余分なキーワード引数が入った (キーワードをキーとし、引数値をキーに対応する値とした) 辞書を受け取ります。余分なキーワード引数がない場合には、空の (新たな) 辞書を受け取ります。</p>
<p id="index-36">関数呼び出しの際に構文 <code class="docutils literal"><span class="pre">*expression</span></code> が使われるなら、<code class="docutils literal"><span class="pre">expression</span></code> の評価はシーケンスでなくてはなりません。このシーケンスの要素は、追加の固定引数のように扱われます; すなわち、固定引数 <em>x1</em> ,..., <em>xN</em> があり、<code class="docutils literal"><span class="pre">expression</span></code> の評価がシーケンス <em>y1</em> ,..., <em>yM</em> であるなら、M+N 個の固定引数 <em>x1</em> ,..., <em>xN</em> , <em>y1</em> ,..., <em>yM</em> を使った呼び出しと同じになります。</p>
<p><code class="docutils literal"><span class="pre">*expression</span></code> 構文はキーワード引数の <em>後ろ</em> で指定しても良いですが、キーワード引数よりも <em>前</em> で指定されたものとして処理されます (<code class="docutils literal"><span class="pre">**expression</span></code> 引数を指定したときの振る舞いは以下を参照)。従って、このようになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span> <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>キーワード引数と <code class="docutils literal"><span class="pre">*expression</span></code> 構文を同じ呼び出しで一緒に使うことはあまりないので、実際に上記のような混乱が生じることはありません。</p>
<p id="index-37">関数呼び出しで <code class="docutils literal"><span class="pre">**expression</span></code> 構文が使われた場合、 <code class="docutils literal"><span class="pre">expression</span></code> の値評価結果はマップ型でなければなりません。辞書の内容は追加のキーワード引数として扱われます。明示的なキーワード引数が <code class="docutils literal"><span class="pre">expression</span></code> 内のキーワードと重複した場合には <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
<p><code class="docutils literal"><span class="pre">*identifier</span></code> や <code class="docutils literal"><span class="pre">**identifier</span></code> 構文を使った仮引数は、固定引数スロットやキーワード引数名にすることができません。</p>
<p>呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。<code class="docutils literal"><span class="pre">None</span></code> を返す場合もあります。戻り値がどのように算出されるかは、呼び出し可能オブジェクトの形態によって異なります。</p>
<p>これが&#8212;</p>
<dl class="docutils">
<dt>ユーザ定義関数:</dt>
<dd><p class="first last" id="index-38">関数のコードブロックに引数リストが渡され、実行されます。コードブロックは、まず仮引数を実引数に結合 (bind) します; この動作については <a class="reference internal" href="compound_stmts.html#function"><span>関数定義</span></a> で記述しています。コードブロックで <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal"><span class="pre">return</span></code></a> 文が実行される際に、関数呼び出しの戻り値 (return value) が決定されます。</p>
</dd>
<dt>組み込み関数またはメソッド:</dt>
<dd><p class="first last" id="index-39">結果はインタプリタに依存します; 組み込み関数やメソッドの詳細は <a class="reference internal" href="../library/functions.html#built-in-funcs"><span>組み込み関数</span></a> を参照してください。</p>
</dd>
<dt>クラスオブジェクト:</dt>
<dd><p class="first last" id="index-40">そのクラスの新しいインスタンスが返されます。</p>
</dd>
<dt>クラスインスタンスメソッド:</dt>
<dd><p class="first last" id="index-41">対応するユーザ定義の関数が呼び出されます。このとき、呼び出し時の引数リストより一つ長い引数リストで呼び出されます: インスタンスが引数リストの先頭に追加されます。</p>
</dd>
<dt>クラスインスタンス:</dt>
<dd><p class="first last" id="index-42">クラスで <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドが定義されていなければなりません; <a class="reference internal" href="datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> メソッドが呼び出された場合と同じ効果をもたらします。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="the-power-operator">
<span id="power"></span><h2>6.4. べき乗演算 (power operator)<a class="headerlink" href="#the-power-operator" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>べき乗演算は、左側にある単項演算子よりも強い結合優先順位があります; 一方、右側にある単項演算子よりは低い結合優先順位になっています。構文は以下のようになります:</p>
<pre>
<strong id="grammar-token-power">power</strong> ::=  <a class="reference internal" href="#grammar-token-primary"><code class="xref docutils literal"><span class="pre">primary</span></code></a> [&quot;**&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>]
</pre>
<p>従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われていない場合、演算子は右から左へと評価されます (この場合は演算子の評価順序を強制しません。つまり <code class="docutils literal"><span class="pre">-1**2</span></code> は <code class="docutils literal"><span class="pre">-1</span></code> になります)。</p>
<p>べき乗演算子の意味は、二つの引数で呼び出される組み込み関数 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal"><span class="pre">pow()</span></code></a> と同じで、左引数を右引数乗して与えます。数値引数はまず共通の型に変換され、結果はその型です。</p>
<p>整数の被演算子では、第二引数が負でない限り、結果は被演算子と同じ型になります; 第二引数が負の場合、全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。例えば <code class="docutils literal"><span class="pre">10**2</span></code> は <code class="docutils literal"><span class="pre">100</span></code> を返しますが、<code class="docutils literal"><span class="pre">10**-2</span></code> は <code class="docutils literal"><span class="pre">0.01</span></code> を返します。</p>
<p><code class="docutils literal"><span class="pre">0.0</span></code> を負の数でべき乗すると <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> を送出します。負の数を小数でべき乗した結果は複素数 (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal"><span class="pre">complex</span></code></a> number) になります。 (以前のバージョンでは <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> を送出していました)</p>
</div>
<div class="section" id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2>6.5. 単項算術演算とビット単位演算(unary arithmetic and bitwise operation)<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-43">全ての単項算術演算とビット単位演算は、同じ優先順位を持っています:</p>
<pre>
<strong id="grammar-token-u_expr">u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-power"><code class="xref docutils literal"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-44">単項演算子 <code class="docutils literal"><span class="pre">-</span></code> (マイナス) は、引数となる数値の符号を反転 (negation) します。</p>
<p id="index-45">単項演算子 <code class="docutils literal"><span class="pre">+</span></code> (プラス) は、数値引数を変更しません。</p>
<p id="index-46">単項演算子 <code class="docutils literal"><span class="pre">~</span></code> (反転) は、整数引数をビット単位反転 (bitwise invert) したものを与えます。<code class="docutils literal"><span class="pre">x</span></code> のビット単位反転は、<code class="docutils literal"><span class="pre">-(x+1)</span></code> として定義されています。この演算子は整数にのみ適用されます。</p>
<p id="index-47">上記の三つはいずれも、引数が正しい型でない場合には <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> 例外が送出されます。</p>
</div>
<div class="section" id="binary-arithmetic-operations">
<span id="binary"></span><h2>6.6. 二項算術演算 (binary arithmetic operation)<a class="headerlink" href="#binary-arithmetic-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-48">二項算術演算は、慣習的な優先順位を踏襲しています。演算子のいずれかは、特定の非数値型にも適用されるので注意してください。べき乗 (power) 演算子を除き、演算子には二つのレベル、すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子しかありません:</p>
<pre>
<strong id="grammar-token-m_expr">m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
            | <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-u_expr"><code class="xref docutils literal"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-a_expr">a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-m_expr"><code class="xref docutils literal"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-49"><code class="docutils literal"><span class="pre">*</span></code> (乗算: multiplication) 演算子は、引数同士の積を与えます。引数は、両方とも数値であるか、片方が整数で他方がシーケンスかのどちらかでなければなりません。前者の場合、数値は共通の型に変換された後乗算されます。後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負にすると、空のシーケンスを与えます。</p>
<p id="index-50"><code class="docutils literal"><span class="pre">/</span></code> (除算: division) および <code class="docutils literal"><span class="pre">//</span></code> (切り捨て除算: floor division) は、引数同士の商を与えます。数値引数はまず共通の型に変換されます。整数の除算結果は浮動小数点になりますが、整数の切り捨て除算結果は整数になります; この場合、結果は数学的な除算に &#8216;floor&#8217; 関数 を適用したものになります。ゼロによる除算を行うと <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> 例外を送出します。</p>
<p id="index-51"><code class="docutils literal"><span class="pre">%</span></code> (モジュロ: modulo) 演算は、第一引数を第二引数で除算したときの剰余になります。数値引数はまず共通の型に変換されます。右引数値がゼロの場合には <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal"><span class="pre">ZeroDivisionError</span></code></a> 例外が送出されます。引数値は浮動小数点でもよく。例えば <code class="docutils literal"><span class="pre">3.14%0.7</span></code> は <code class="docutils literal"><span class="pre">0.34</span></code> になります (<code class="docutils literal"><span class="pre">3.14</span></code> は <code class="docutils literal"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code>  だからです)。モジュロ演算子は常に第二引数と同じ符号 (またはゼロ) の結果になります; モジュロ演算の結果の絶対値は、常に第二引数の絶対値よりも小さくなります。 <a class="footnote-reference" href="#id16" id="id8">[1]</a> 。</p>
<p>切り捨て除算演算とモジュロ演算は、恒等式: <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code> の関係にあります。切り捨て除算やモジュロはまた、組み込み関数 <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a>: <code class="docutils literal"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code> とも関係しています。 <a class="footnote-reference" href="#id17" id="id9">[2]</a> 。</p>
<p><code class="docutils literal"><span class="pre">%</span></code> 演算子は、数値に対するモジュロ演算を行うのに加えて、文字列 (string) オブジェクトにオーバーロードされ、旧式の文字列の書式化 (いわゆる補間) を行います。文字列の書式化の構文は Python ライブラリリファレンス <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span>printf 形式の文字列書式化</span></a> 節を参照してください。</p>
<p>切り捨て除算演算子、モジュロ演算子、および <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal"><span class="pre">divmod()</span></code></a> 関数は、複素数に対しては定義されていません。目的に合うならば、代わりに <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a> を使って浮動小数点に変換してください。</p>
<p id="index-52"><code class="docutils literal"><span class="pre">+</span></code> (加算) 演算は、引数同士の和を与えます。引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。前者の場合、数値は共通の型に変換され、加算されます。後者の場合、シーケンスは結合 (concatenate) されます。</p>
<p id="index-53"><code class="docutils literal"><span class="pre">-</span></code> (減算) 演算は、引数間で減算を行った値を返します。数値引数はまず共通の型に変換されます。</p>
</div>
<div class="section" id="shifting-operations">
<span id="shifting"></span><h2>6.7. シフト演算 (shifting operation)<a class="headerlink" href="#shifting-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-54">シフト演算は、算術演算よりも低い優先順位を持っています:</p>
<pre>
<strong id="grammar-token-shift_expr">shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a> ( &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; ) <a class="reference internal" href="#grammar-token-a_expr"><code class="xref docutils literal"><span class="pre">a_expr</span></code></a>
</pre>
<p>これらは整数を引数にとります。引数は共通の型に変換されます。シフト演算は第一引数を、第二引数で与えられたビット数だけ、左または右にビットシフトします。</p>
<p id="index-55"><em>n</em> ビットの右シフトは <code class="docutils literal"><span class="pre">pow(2,n)</span></code> による除算として定義されます。<em>n</em> ビットの左シフトは <code class="docutils literal"><span class="pre">pow(2,n)</span></code> による乗算として定義されます。</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">現在の実装では、右辺被演算子は最大でも <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> でなければなりません。右辺被演算子が <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal"><span class="pre">sys.maxsize</span></code></a> よりも大きいと、 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal"><span class="pre">OverflowError</span></code></a> 例外が送出されます。</p>
</div>
</div>
<div class="section" id="binary-bitwise-operations">
<span id="bitwise"></span><h2>6.8. ビット単位演算の二項演算 (binary bitwise operation)<a class="headerlink" href="#binary-bitwise-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-56">以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:</p>
<pre>
<strong id="grammar-token-and_expr">and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-shift_expr"><code class="xref docutils literal"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-xor_expr">xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-and_expr"><code class="xref docutils literal"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-or_expr">or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-xor_expr"><code class="xref docutils literal"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-57"><code class="docutils literal"><span class="pre">&amp;</span></code> 演算子は、引数同士のビット単位の AND を与えます。引数は整数でなければなりません。</p>
<p id="index-58"><code class="docutils literal"><span class="pre">^</span></code> 演算子は、引数同士のビット単位の XOR (排他的 OR) を与えます。引数は整数でなければなりません。</p>
<p id="index-59"><code class="docutils literal"><span class="pre">|</span></code> 演算子は、引数同士のビット単位の (包含的) OR を与えます。引数は整数でなければなりません。</p>
</div>
<div class="section" id="not-in">
<span id="in"></span><span id="is-not"></span><span id="is"></span><span id="comparisons"></span><span id="id10"></span><h2>6.9. 比較<a class="headerlink" href="#not-in" title="このヘッドラインへのパーマリンク">¶</a></h2>
<span class="target" id="index-60"></span><p id="index-61">C 言語と違って、Python における比較演算子は同じ優先順位をもっており、全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。また <code class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> が数学で伝統的に用いられているのと同じ解釈になる点も C 言語と違います:</p>
<pre>
<strong id="grammar-token-comparison">comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> ( <a class="reference internal" href="#grammar-token-comp_operator"><code class="xref docutils literal"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-or_expr"><code class="xref docutils literal"><span class="pre">or_expr</span></code></a> )*
<strong id="grammar-token-comp_operator">comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>比較演算の結果はブール値: <code class="docutils literal"><span class="pre">True</span></code> または <code class="docutils literal"><span class="pre">False</span></code> になります。</p>
<p id="index-62">比較はいくらでも連鎖することができます。例えば <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> と等価になります。ただしこの場合、前者では <code class="docutils literal"><span class="pre">y</span></code> はただ一度だけ評価される点が異なります (どちらの場合でも、<code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> が偽になると <code class="docutils literal"><span class="pre">z</span></code> の値はまったく評価されません)。</p>
<p>形式的には、<em>a</em>, <em>b</em>, <em>c</em>, ..., <em>y</em>, <em>z</em> が式で <em>op1</em>, <em>op2</em>, ..., <em>opN</em> が比較演算子である場合、<code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> は <code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> と等価になります。ただし、前者では各式は多くても一度しか評価されません。</p>
<p><code class="docutils literal"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> と書いた場合、<em>a</em> から <em>c</em> までの範囲にあるかどうかのテストを指すのではないことに注意してください。例えば <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> は (きれいな書き方ではありませんが) 完全に正しい文法です。</p>
<p>演算子 <code class="docutils literal"><span class="pre">&lt;</span></code> 、 <code class="docutils literal"><span class="pre">&gt;</span></code> 、 <code class="docutils literal"><span class="pre">==</span></code> 、 <code class="docutils literal"><span class="pre">&gt;=</span></code> 、 <code class="docutils literal"><span class="pre">&lt;=</span></code> 、および <code class="docutils literal"><span class="pre">!=</span></code> は、二つのオブジェクトの値を比較します。オブジェクトは同じ型である必要はありません。双方が数値であれば、共通の型に変換されます。そうでなければ、 <code class="docutils literal"><span class="pre">==</span></code> および <code class="docutils literal"><span class="pre">!=</span></code> 演算子は、異なる型のオブジェクトを <em>常に</em> 等しくないとみなします。 <code class="docutils literal"><span class="pre">&lt;</span></code> 、 <code class="docutils literal"><span class="pre">&gt;</span></code> 、 <code class="docutils literal"><span class="pre">&gt;=</span></code> 、および <code class="docutils literal"><span class="pre">&lt;=</span></code> 演算子は、与えられた型の対に対して演算子を実装していないような異なる型のオブジェクトを比較するとき <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。組み込み型でないオブジェクトの比較は、 <a class="reference internal" href="datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a> などの拡張比較メソッドを定義することで振る舞いを制御できます。これは <a class="reference internal" href="datamodel.html#customization"><span>基本的なカスタマイズ</span></a> 節で説明されています。</p>
<p>同じ型のオブジェクト間における比較は、型によって異なります:</p>
<ul>
<li><p class="first">数値間の比較では、算術的な比較が行われます。</p>
</li>
<li><p class="first">値 <code class="xref py py-const docutils literal"><span class="pre">float('NaN')</span></code> および <code class="xref py py-const docutils literal"><span class="pre">Decimal('NaN')</span></code> は特別です。これらは自身と同一で <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">x</span></code> ですが、自身と等価ではなく <code class="docutils literal"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code> です。さらに、非数 (not-a-number) 値といかなる値の比較も <code class="docutils literal"><span class="pre">False</span></code> を返します。例えば、 <code class="docutils literal"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">float('NaN')</span></code> も <code class="docutils literal"><span class="pre">float('NaN')</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> も <code class="docutils literal"><span class="pre">False</span></code> を返します。</p>
</li>
<li><p class="first">バイト列オブジェクトは、要素の数値を使って辞書的に (lexicographically) 比較されます。</p>
</li>
<li><p class="first">文字列は、各文字に相当する数値 (組み込み関数 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal"><span class="pre">ord()</span></code></a> の結果) を使って辞書的に比較されます。<a class="footnote-reference" href="#id18" id="id11">[3]</a> 文字列とバイト列は比較できません！</p>
</li>
<li><p class="first">タプルやリスト間の比較では、対応する各要素の比較結果を使って辞書的な比較が行われます。このため、二つのシーケンスを等価にするためには、各要素が完全に等価でなくてはならず、シーケンスは同じ型で同じ長さをもっていなければなりません。</p>
<p>二つのシーケンスは、等価でなければ、最初の異なる要素間の比較に従って順序付けられます。例えば <code class="docutils literal"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> の値は <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> と等しいです。対応する要素がなければ、短い方のシーケンスが先に並びます (例えば、<code class="docutils literal"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> です)。</p>
</li>
<li><p class="first">マッピング (辞書) は、同じ <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> の対を持つときのみ等しくなります。順序比較 <code class="docutils literal"><span class="pre">('&lt;',</span> <span class="pre">'&lt;=',</span> <span class="pre">'&gt;=',</span> <span class="pre">'&gt;')</span></code> は <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> を送出します。</p>
</li>
<li><p class="first">集合や凍結集合は、比較演算子を部分集合検査や上位集合検査を意味するものとして定義します。この関係は全順序を定義しません (二つの集合 <code class="docutils literal"><span class="pre">{1,2}</span></code> と <code class="docutils literal"><span class="pre">{2,3}</span></code> は等しくなく、一方が他方の部分集合ではなく、一方が他方の上位集合でもありません)。従って、集合は、全順序に依存する関数の引数として適切ではありません。例えば、 <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a> 、 <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal"><span class="pre">sorted()</span></code></a> は、入力として与えられた集合のリストに対して、定義されていない結果を生みます。</p>
</li>
<li><p class="first">その他のほとんどの組み込み型のオブジェクト比較では、同じオブジェクトでないかぎり等価にはなりません; あるオブジェクトの他のオブジェクトに対する大小関係は任意に決定され、一つのプログラムの実行中は一貫したものとなります。</p>
</li>
</ul>
<p>異なる型のオブジェクトの比較はデータ型が明示的に比較をサポートしているかどうかに依存します。ほとんどの数値型はその他のデータ型と比較できます。データ型間比較がサポートされていない場合、比較メソッドは <code class="docutils literal"><span class="pre">NotImplemented</span></code> を返します。</p>
<p id="membership-test-details">演算子 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> および <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> は、帰属 (membership) を調べます。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の評価は、 <em>x</em> が <em>s</em> の要素であれば真となり、そうでなければ偽となります。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> の否定 (negation) を返します。すべての組み込みのシーケンスと集合型に加えて、辞書も、 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> を辞書が与えられたキーを持っているかを調べるものとしてサポートしています。リスト、タプル、集合、凍結集合、辞書、あるいは collection.deque のようなコンテナ型について、式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code> と等価です。</p>
<p>文字列やバイト列型については、<code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <em>x</em> が <em>y</em> の部分文字列であるとき、かつそのときに限り真になります。これは <code class="docutils literal"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code> と等価です。空文字列は、他の任意の文字列の部分文字列とみなされます。従って <code class="docutils literal"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> は <code class="docutils literal"><span class="pre">True</span></code> を返すことになります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> メソッドの定義されたユーザ定義クラスでは、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> が真となるのは <code class="docutils literal"><span class="pre">y.__contains__(x)</span></code> が真となるとき、かつそのときに限ります。</p>
<p><a class="reference internal" href="datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></code></a> を定義していないが <a class="reference internal" href="datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></code></a> は定義しているユーザ定義クラスでは、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> となるようなある値 <code class="docutils literal"><span class="pre">z</span></code> が <code class="docutils literal"><span class="pre">y</span></code> 内にわたる反復で生成された場合、 true となります。もし、反復の間に例外が発生すれば、 <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> が例外を発生させたようにみえます。</p>
<p>最終的には、旧式の反復プロトコルの実行が試みられます。クラスが <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> を定義していれば、 <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> は <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code> となるような非負の整数インデックス <em>i</em> が存在し、それより小さなインデックスが <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code></a> を送出しないとき、かつそのときにかぎり真です。 (別の何らかの例外が送出された場合、例外は <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> から送出されたかのようになります)。</p>
<p id="index-63">演算子 <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a> は <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a> の真値を反転した値として定義されています。</p>
<p id="index-64">演算子 <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> および <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a> は、オブジェクトの同一性に対するテストを行います: <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> は、 <em>x</em> と <em>y</em> が同じオブジェクトを指すとき、かつそのときに限り真になります。 <code class="docutils literal"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> は <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> の真値を反転したものになります。 <a class="footnote-reference" href="#id19" id="id12">[4]</a></p>
</div>
<div class="section" id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2>6.10. ブール演算 (boolean operation)<a class="headerlink" href="#boolean-operations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-65">
<strong id="grammar-token-or_test">or_test </strong> ::=  <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-and_test">and_test</strong> ::=  <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-and_test"><code class="xref docutils literal"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-not_test">not_test</strong> ::=  <a class="reference internal" href="#grammar-token-comparison"><code class="xref docutils literal"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-not_test"><code class="xref docutils literal"><span class="pre">not_test</span></code></a>
</pre>
<p>ブール演算のコンテキストや、式が制御フロー文中で使われる際には、以下の値: <code class="docutils literal"><span class="pre">False</span></code> 、 <code class="docutils literal"><span class="pre">None</span></code> すべての型における数値の 0、空の文字列、空のコンテナ (文字列、タプル、リスト、辞書、集合、凍結集合など) は偽 (false) であると解釈されます。それ以外の値は真 (true) であると解釈されます。ユーザ定義のメソッドは、 <a class="reference internal" href="datamodel.html#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal"><span class="pre">__bool__()</span></code></a> メソッドを与えることで、真理値をカスタマイズできます。</p>
<p id="index-66">演算子 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> は、引数が偽である場合には <code class="docutils literal"><span class="pre">True</span></code> を、それ以外の場合には <code class="docutils literal"><span class="pre">False</span></code> になります。</p>
<p id="index-67">式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が偽なら <em>x</em> の値を返します; それ以外の場合には、<em>y</em> の値を評価し、その結果を返します。</p>
<p id="index-68">式 <code class="docutils literal"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> は、まず <em>x</em> を評価します; <em>x</em> が真なら <em>x</em> の値を返します; それ以外の場合には、<em>y</em> の値を評価し、その結果を返します。</p>
<p>(なお、 <a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a> も <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a> も、返す値を <code class="docutils literal"><span class="pre">True</span></code> や <code class="docutils literal"><span class="pre">False</span></code> に制限せず、最後に評価した引数を返します。この仕様が便利なこともあり、例えば <code class="docutils literal"><span class="pre">s</span></code> が文字列で、空文字列ならデフォルトの値に置き換えたいとき、式 <code class="docutils literal"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> は望んだ値を与えます。 <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> は引数の型に関係なく、必ずブール値を返すからです。例えば、 <code class="docutils literal"><span class="pre">not</span> <span class="pre">'foo'</span></code> は、 <code class="docutils literal"><span class="pre">''</span></code> ではなく <code class="docutils literal"><span class="pre">False</span></code> を与えます。)</p>
</div>
<div class="section" id="conditional-expressions">
<h2>6.11. 条件演算 (Conditional Expressions)<a class="headerlink" href="#conditional-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-69">
<strong id="grammar-token-conditional_expression">conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-expression">expression            </strong> ::=  <a class="reference internal" href="#grammar-token-conditional_expression"><code class="xref docutils literal"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-lambda_expr"><code class="xref docutils literal"><span class="pre">lambda_expr</span></code></a>
<strong id="grammar-token-expression_nocond">expression_nocond     </strong> ::=  <a class="reference internal" href="#grammar-token-or_test"><code class="xref docutils literal"><span class="pre">or_test</span></code></a> | <a class="reference internal" href="#grammar-token-lambda_expr_nocond"><code class="xref docutils literal"><span class="pre">lambda_expr_nocond</span></code></a>
</pre>
<p>条件演算式 (しばしば、&#8221;三項演算子&#8221; と呼ばれます) は最も優先度が低いPython の操作です。</p>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> という式は最初に条件 <em>x</em> ではなく <em>C</em> を評価します; <em>C</em> が true の場合 <em>x</em> が評価され値が返されます; それ以外の場合には <em>y</em> が評価され返されます。</p>
<p>条件演算に関してより詳しくは <span class="target" id="index-78"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> を参照してください。</p>
</div>
<div class="section" id="lambda">
<span id="lambdas"></span><span id="id13"></span><h2>6.12. ラムダ (lambda)<a class="headerlink" href="#lambda" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-71">
<strong id="grammar-token-lambda_expr">lambda_expr       </strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a>
<strong id="grammar-token-lambda_expr_nocond">lambda_expr_nocond</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-parameter_list"><code class="xref docutils literal"><span class="pre">parameter_list</span></code></a>]: <a class="reference internal" href="#grammar-token-expression_nocond"><code class="xref docutils literal"><span class="pre">expression_nocond</span></code></a>
</pre>
<p>ラムダ式 (lambda expression または lambda forms) は無名関数を作成するのに使います; 式 <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">arguments:</span> <span class="pre">expression</span></code> は関数オブジェクトになります。ラムダで表される無名オブジェクトは以下の関数オブジェクト同様に動作します</p>
<div class="highlight-python3"><div class="highlight"><pre>def &lt;lambda&gt;(arguments):
    return expression
</pre></div>
</div>
<p>パラメータの構文の一覧は <a class="reference internal" href="compound_stmts.html#function"><span>関数定義</span></a> を参照してください。ラムダ式で作成された関数は命令文や注釈を含むことができない点に注意してください。</p>
</div>
<div class="section" id="expression-lists">
<span id="exprlists"></span><h2>6.13. 式のリスト<a class="headerlink" href="#expression-lists" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre id="index-72">
<strong id="grammar-token-expression_list">expression_list</strong> ::=  <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> ( &quot;,&quot; <a class="reference internal" href="#grammar-token-expression"><code class="xref docutils literal"><span class="pre">expression</span></code></a> )* [&quot;,&quot;]
</pre>
<p id="index-73">少なくとも一つのカンマを含む式のリストは、タプルになります。タプルの長さは、リスト中の式の数に等しくなります。</p>
<p id="index-74">リスト中の式は左から右へと順に評価されます。単一要素のタプル (別名 <em>単集合 (singleton)</em>) を作りたければ、末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合には、タプルではなくその式の値になります (空のタプルを作りたいなら、中身が空の丸括弧ペア: <code class="docutils literal"><span class="pre">()</span></code> を使います。)</p>
</div>
<div class="section" id="evaluation-order">
<span id="evalorder"></span><h2>6.14. 評価順序<a class="headerlink" href="#evaluation-order" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-75">Python は、式を左から右へと順に評価します。ただし、代入式を評価するときは、代入演算子の右側項が左側項よりも先に評価されます。</p>
<p>以下に示す実行文の各行での評価順序は、添え字の数字順序と同じになります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-precedence">
<span id="operator-summary"></span><h2>6.15. 演算子の優先順位<a class="headerlink" href="#operator-precedence" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-76">以下の表は、Python における演算子を、優先順位の最も低い (結合が最も弱い) ものから最も高い (結合が最も強い) ものへ順に並べたものです。同じボックス内の演算子の優先順位は同じです。構文が特に示されていない演算子は、二項演算子です。同じボックス内の演算子は、左から右へとグループ化されます (例外として、べき乗は右から左にグループ化されます)。</p>
<p><a class="reference internal" href="#comparisons"><span>比較</span></a> で述べられているように、比較、帰属、同一性のテストは全てが同じ優先順位を持っていて、左から右に連鎖する特徴を持っていることに注意してください。</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">演算子</p>
</th>
<th class="head"><p class="first last">説明</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a></td>
<td><p class="first last">ラムダ式</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="compound_stmts.html#if"><code class="xref std std-keyword docutils literal"><span class="pre">if</span></code></a> &#8211; <a class="reference internal" href="compound_stmts.html#else"><code class="xref std std-keyword docutils literal"><span class="pre">else</span></code></a></td>
<td><p class="first last">条件演算</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal"><span class="pre">or</span></code></a></td>
<td><p class="first last">ブール演算 OR</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal"><span class="pre">and</span></code></a></td>
<td><p class="first last">ブール演算 AND</p>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal"><span class="pre">not</span></code></a> <code class="docutils literal"><span class="pre">x</span></code></td>
<td><p class="first last">ブール演算 NOT</p>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal"><span class="pre">&lt;</span></code>,
<code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">==</span></code></td>
<td><p class="first last">帰属や同一性のテストを含む比較</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">|</span></code></td>
<td><p class="first last">ビット単位 OR</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">^</span></code></td>
<td><p class="first last">ビット単位 XOR</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&amp;</span></code></td>
<td><p class="first last">ビット単位 AND</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code></td>
<td><p class="first last">シフト演算</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code></td>
<td><p class="first last">加算および減算</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">//</span></code>, <code class="docutils literal"><span class="pre">%</span></code></td>
<td><p class="first last">乗算、除算、剰余 <a class="footnote-reference" href="#id20" id="id14">[5]</a></p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">+x</span></code>, <code class="docutils literal"><span class="pre">-x</span></code>, <code class="docutils literal"><span class="pre">~x</span></code></td>
<td><p class="first last">正符号、負符号、ビット単位 NOT</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">**</span></code></td>
<td><p class="first last">べき乗 <a class="footnote-reference" href="#id21" id="id15">[6]</a></p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">x[index]</span></code>, <code class="docutils literal"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal"><span class="pre">x.attribute</span></code></td>
<td><p class="first last">添字指定、スライス操作属性参照</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">(expressions...)</span></code>,
<code class="docutils literal"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal"><span class="pre">{expressions...}</span></code></td>
<td><p class="first last">式結合またはタプル表示、リスト表示、辞書表示、集合表示</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[1]</a></td><td><p class="first last"><code class="docutils literal"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> は数学的には真となりますが、浮動小数点に対する演算の場合には、値丸め (roundoff) のために数値計算的に真にならない場合があります。例えば、Python の浮動小数点型が IEEE754 倍精度数型になっているプラットフォームを仮定すると、 <code class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> は <code class="docutils literal"><span class="pre">1e100</span></code> と同じ符号になるはずなのに、計算結果は <code class="docutils literal"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code> となります。これは数値計算的には厳密に <code class="docutils literal"><span class="pre">1e100</span></code> と等価です。関数 <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal"><span class="pre">math.fmod()</span></code></a> は、最初の引数と符号が一致するような値を返すので、上記の場合には <code class="docutils literal"><span class="pre">-1e-100</span></code> を返します。どちらのアプローチが適切かは、アプリケーションに依存します。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[2]</a></td><td><p class="first last">x が y の正確な整数倍に非常に近いと、丸めのために <code class="docutils literal"><span class="pre">x//y</span></code> が <code class="docutils literal"><span class="pre">(x-x%y)//y</span></code> よりも 1 だけ大きくなる可能性があります。そのような場合、Python は <code class="docutils literal"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> が <code class="docutils literal"><span class="pre">x</span></code> に非常に近くなるという関係を保つために、後者の値を返します。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[3]</a></td><td><p class="first last">文字列間の比較はバイトレベルでは意味があるとはいえ、ユーザにとっては直感的ではないかもしれません。例えば、文字列 <code class="docutils literal"><span class="pre">&quot;\u00C7&quot;</span></code>  と <code class="docutils literal"><span class="pre">&quot;\u0043\u0327&quot;</span></code> は、両方の文字列が同じユニコード文字 (LATIN CAPITAL LETTER C WITH CEDILLA) で表されたとしても違うものとして比較されます。人間が分かり易い方法で文字列を比較するには <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal"><span class="pre">unicodedata.normalize()</span></code></a> を使用して比較してください。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[4]</a></td><td><p class="first last">自動的なガベージコレクション、フリーリスト、ディスクリプタの動的特性のために、インスタンスメソッドや定数の比較を行うようなときに <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal"><span class="pre">is</span></code></a> 演算子の利用は、一見すると普通ではない振る舞いだと気付くかもしれません。詳細はそれぞれのドキュメントを確認してください。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[5]</a></td><td><p class="first last"><code class="docutils literal"><span class="pre">%</span></code> 演算子は文字列フォーマットにも使われ、同じ優先順位が当てはまります。</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[6]</a></td><td><p class="first last">べき乗演算子 <code class="docutils literal"><span class="pre">**</span></code> はその右側にある単項演算子かビット単位演算子よりも優先して束縛されます。つまり <code class="docutils literal"><span class="pre">2**-1</span></code> は <code class="docutils literal"><span class="pre">0.5</span></code> になります。</p>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. 式 (expression)</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. 算術変換 (arithmetic conversion)</a></li>
<li><a class="reference internal" href="#atoms">6.2. Atom (原始的要素)</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. 識別子 (identifier、または名前 (name))</a></li>
<li><a class="reference internal" href="#literals">6.2.2. リテラル</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. 丸括弧形式 (parenthesized form)</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. リスト、集合、辞書の表示</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. リスト表現</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. 集合表現</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. 辞書表現</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. ジェネレータ式</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Yield 式</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. ジェネレータ-イテレータメソッド</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. 例</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. プライマリ</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. 属性参照</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. 添字表記 (subscription)</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. スライス表記 (slicing)</a></li>
<li><a class="reference internal" href="#calls">6.3.4. 呼び出し (call)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-power-operator">6.4. べき乗演算 (power operator)</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.5. 単項算術演算とビット単位演算(unary arithmetic and bitwise operation)</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.6. 二項算術演算 (binary arithmetic operation)</a></li>
<li><a class="reference internal" href="#shifting-operations">6.7. シフト演算 (shifting operation)</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.8. ビット単位演算の二項演算 (binary bitwise operation)</a></li>
<li><a class="reference internal" href="#not-in">6.9. 比較</a></li>
<li><a class="reference internal" href="#boolean-operations">6.10. ブール演算 (boolean operation)</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.11. 条件演算 (Conditional Expressions)</a></li>
<li><a class="reference internal" href="#lambda">6.12. ラムダ (lambda)</a></li>
<li><a class="reference internal" href="#expression-lists">6.13. 式のリスト</a></li>
<li><a class="reference internal" href="#evaluation-order">6.14. 評価順序</a></li>
<li><a class="reference internal" href="#operator-precedence">6.15. 演算子の優先順位</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="import.html"
                        title="前の章へ">5. インポートシステム</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="simple_stmts.html"
                        title="次の章へ">7. 単純文 (simple statement)</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/reference/expressions.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. 単純文 (simple statement)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. インポートシステム"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 言語リファレンス</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>