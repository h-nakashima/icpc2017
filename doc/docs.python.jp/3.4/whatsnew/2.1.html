<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>What’s New in Python 2.1 &mdash; Python 3.4.3 ドキュメント</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.4.3 ドキュメント 内を検索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="copyright" title="著作権" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 ドキュメント" href="../contents.html" />
    <link rel="up" title="What’s New in Python" href="index.html" />
    <link rel="next" title="What’s New in Python 2.0" href="2.0.html" />
    <link rel="prev" title="What’s New in Python 2.2" href="2.2.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/_jp.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-34175846-1', 'python.jp');
        ga('send', 'pageview');

      </script>
  <body role="document">  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="What’s New in Python 2.0"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="What’s New in Python 2.2"
             accesskey="P">前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">What&#8217;s New in Python</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-s-new-in-python-2-1">
<h1>What&#8217;s New in Python 2.1<a class="headerlink" href="#what-s-new-in-python-2-1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">A.M. Kuchling</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>はじめに<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この記事はPython 2.1の新機能について説明します。Python 2.1には Python 2.0ほど多くの変更点はありませんが、楽しい驚きがあります。2.1はPythonの拡張計画（PEP）を使い動かす最初のリリースであり、大きい変更点のほとんどは、より詳細なドキュメントや変更のための設計原理を提供するPEPに付随しています。この記事は新機能について網羅していませんが、Pythonプログラマのための新機能について概要を示します。特に興味のある任意の新機能の詳細については、Python 2.1ドキュメントか特定のPEPを参照してください。</p>
<p>Python開発チームの最近の目標の一つとして新しいリリースのペースを上げており、一つのリリースにつき6～9ヶ月ごとにリリースしています。2.1はこの速いペースになって出てきた最初のリリースで、初のアルファ版は、2.0の最終版がリリースされた3ヶ月後の1月に登場しました。</p>
<p>Python 2.1の最終版は2001年4月17日に作成されました。</p>
</div>
<div class="section" id="pep-227-nested-scopes">
<h2>PEP 227: 入れ子状のスコープ<a class="headerlink" href="#pep-227-nested-scopes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python2.1における最も大きな変更点はPythonのスコープルールです。Python2.0では、ある指定された時点である変数の名前を検索するために多くても3つの名前空間、つまりローカル、モジュールレベル、ビルトイン名前空間しか使われませんでした。このことは直感的な期待と一致せずしばしば人々を驚かせました。例えば、入れ子になった再帰関数の定義は動きません:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>名前 <code class="docutils literal"><span class="pre">g</span></code> はローカルの名前空間にもモジュールレベルの名前空間にも紐付かないので、関数 <code class="xref py py-func docutils literal"><span class="pre">g()</span></code> は常に <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal"><span class="pre">NameError</span></code></a> 例外を上げます。これは実際には大した問題ではありません (このような内部関数を再帰的に定義する頻度はそう多くありません)が、<a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> ステートメントをより使いにくくするのでこれについては問題です。<a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> を使うコードにおいて、デフォルトの引数としてこれらを渡してコピーされるローカル変数を頻繁に見かけます。:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>過度な関数型スタイルで書かれた Python コードの可読性は、結果的にはひどく苦痛を感じるものですね。</p>
<p>Python 2.1の最も重要な変更点は、この問題を解決するために静的なスコープが追加されたことです。最初の効果として、<code class="docutils literal"><span class="pre">name=name</span></code> という例ではデフォルトの引数は必要ありません。簡単に言えば、指定された引数名が関数内の値に割り当てられない場合(<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal"><span class="pre">def</span></code></a>、<a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal"><span class="pre">class</span></code></a> または <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ステートメントの割り当てによって)、変数の参照は外側のスコープのローカル名前空間で検索されます。ルールや実装の詳細はPEPで参照できます。</p>
<p>この変更は、同じ変数名がモジュールレベルと関数の定義が含まれている関数内のローカルの両方で変数名として使用されているコードで、互換性の問題を引き起こす可能性があります。ですがむしろ気にしなくてよいでしょう。そのようなコードはそもそも最初から相当こんがらかっているので。</p>
<p>この変更の副作用の一つは、 <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> と <code class="docutils literal"><span class="pre">exec</span></code> の両ステートメントが特定の条件下の関数スコープ内で不正となることです。 Python のリファレンスマニュアルははじめからずっと <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> はトップレベルモジュールでのみ合法であると言ってきましたが、以前の CPython インタプリタはこれを一度も強制していませんでした。入れ子になったスコープ実装の一環として、Python のソースをバイトコードに変換するコンパイラは、内包されたスコープ内の変数にアクセスするために別のコードを生成する必要があります。 <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>, <code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> はコンパイラにこれを理解することを不可能にしてしまいます。なぜならそれらはコンパイル時にはわからないローカル名前空間に名前を追加するからです。それゆえ、もし関数が関数定義を含んだり自由な変数に <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal"><span class="pre">lambda</span></code></a> の語句を含んだりする場合、コンパイラは <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal"><span class="pre">SyntaxError</span></code></a> 例外を上げて知らせます。</p>
<p>前述した説明を少し明確にするため、例を挙げます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c"># The next line is a syntax error</span>
    <span class="n">exec</span> <span class="s">&#39;x=2&#39;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p><code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> 文を含む 4 行目は文法エラーです。 <code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> としては新しいローカル変数 <code class="docutils literal"><span class="pre">x</span></code> を定義したいのですが、これは <code class="xref py py-func docutils literal"><span class="pre">g()</span></code> からアクセスされなければなりません。</p>
<p>これは実際には大した制約でもないはずです。 <code class="xref std std-keyword docutils literal"><span class="pre">exec</span></code> が Python コードで使われるのは稀です(使われているとしたら大抵どこか貧弱な設計であることの証)。</p>
<p>互換性の問題が考慮されて、入れ子のスコープは段階的導入につながりました; Python 2.1 ではそれらはデフォルトで有効になっていませんが、PEP 236 に記載されているように、future 文を使用してモジュール内でオンにすることができます。(PEP 236 の更なる議論について、続くセクションを参照してください。) Python 2.2では入れ子になったスコープがデフォルトになり、それをオフにする方法はありませんが、ユーザは 2.1 の全ライフタイムを通して、導入の結果起きるあらゆる破損を修正し続けるでしょう。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-25"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0227"><strong>PEP 227</strong></a> - 静的に入れ子になったスコープ</dt>
<dd><p class="first last">Jeremy Hylton著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-236-future-directives">
<h2>PEP 236: __future__ 指示文<a class="headerlink" href="#pep-236-future-directives" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ネストされたスコープへのこの対応は、リリース 2.1 ではコードを壊すことの危険性について広く懸念されており、  Pythoneer 達に保守的なアプローチを選ばせるには十分でした。このアプローチは、必須とするリリース N+1 に対する、 リリース N でのオプション機能として有効化という序奏、というものです。</p>
<p>この構文は <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a> という名の予約モジュールを使う <code class="docutils literal"><span class="pre">from...import</span></code> ステートメントを使用します。ネストしたスコープは以下のステートメントで有効にできます。</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">nested_scopes</span>
</pre></div>
</div>
<p>普通 の <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ステートメントに見えますが、実は違います; このような未来のステートメントが置かれる場所には厳格なルールがあります。これらはモジュールの冒頭にしか置けませんし、必ず何らかのPythonコードや正規の <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> ステートメントの前になければなりません。それと言うのもこのようなステートメントは、Pythonのバイトコードコンパイラがコードを解析し、バイトコードを生成する方法に影響しますので、生成されるバイトコードとなるステートメントの前になくてはならないのです。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-26"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0236"><strong>PEP 236</strong></a> - バック・トゥ・ザ・ <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal"><span class="pre">__future__</span></code></a></dt>
<dd><p class="first last">Tim Peter著、Jeremy Hylton主実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-207-rich-comparisons">
<h2>PEP 207: 拡張比較<a class="headerlink" href="#pep-207-rich-comparisons" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以前のバージョンでは、ユーザ定義クラスや拡張型の比較を実装するための Python のサポートはとても単純なものでした。クラスは 2 つのインスタンスを与えられる <code class="xref py py-meth docutils literal"><span class="pre">__cmp__()</span></code> メソッドを実装でき、実際の値がどうあれ、同値の場合には 0 、そうでないなら +1 か -1 を返せるだけでした; メソッドは例外を上げることも、ブール値以外のものを返すこともできませんでした。Numeric Python が使われるような複雑な計算プログラムでは、要素ごとに与えられた比較結果を含む行列を返し、2 つの行列を要素単位で比較できることがより便利なので、Numeric Python のユーザはこのモデルがとても脆弱で限定的であることにしばしば気付きました。もし 2 つの行列サイズが異なる場合、この比較はエラー通知の例外を上げられなければなりません。</p>
<p>Python2.1で、このニーズを満たすために拡張比較が追加されました。Pythonのクラスは、<code class="docutils literal"><span class="pre">&lt;</span></code>、<code class="docutils literal"><span class="pre">&lt;=</span></code>、<code class="docutils literal"><span class="pre">&gt;</span></code>、<code class="docutils literal"><span class="pre">&gt;=</span></code>、<code class="docutils literal"><span class="pre">==</span></code>、<code class="docutils literal"><span class="pre">!=</span></code> の各演算を個別にオーバーロードできます。この新しい特殊メソッドの名前は:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><p class="first last">演算</p>
</th>
<th class="head"><p class="first last">メソッド名</p>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&lt;</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&lt;=</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal"><span class="pre">__le__()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">&gt;</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">&gt;=</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal"><span class="pre">__ge__()</span></code></a></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">==</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></code></a></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">!=</span></code></td>
<td><a class="reference internal" href="../reference/datamodel.html#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></code></a></td>
</tr>
</tbody>
</table>
<p>(特殊メソッドはFortranの <code class="docutils literal"><span class="pre">.LT.</span></code> や <code class="docutils literal"><span class="pre">.LE.</span></code> 等々の演算子にちなんで命名されています。プログラマはほぼ確実にこれらの名前を熟知していますので、覚えやすいでしょう。)</p>
<p>これらの特殊メソッドは <code class="docutils literal"><span class="pre">method(self,</span> <span class="pre">other)</span></code> の形式になっており、<code class="docutils literal"><span class="pre">self</span></code> が演算子の左辺、<code class="docutils literal"><span class="pre">other</span></code> が右辺のオブジェクトになります。例えば、式 <code class="docutils literal"><span class="pre">A</span> <span class="pre">&lt;</span> <span class="pre">B</span></code> は <code class="docutils literal"><span class="pre">A.__lt__(B)</span></code> を呼び出します。</p>
<p>これらの特殊メソッドは何でも、つまり真偽値や行列、リストや他のPython オブジェクトを返せます。もし比較が不可能であったり、矛盾していたり、意味がない場合は、代わりに例外を上げることができます。</p>
<p>ビルトインの <code class="xref py py-func docutils literal"><span class="pre">cmp(A,B)()</span></code> 関数は拡張比較機構を利用出来、使用する比較演算を指定する省略可能引数を受け付けるようになっています。指定には文字列 <code class="docutils literal"><span class="pre">&quot;&lt;&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;&lt;=&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;&gt;&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;&gt;=&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;==&quot;</span></code>, or <code class="docutils literal"><span class="pre">&quot;!=&quot;</span></code> のいずれか一つを渡します。省略可能のその 3 番目引数が省略されて呼ばれれば、 <code class="xref py py-func docutils literal"><span class="pre">cmp()</span></code> は以前のバージョンの Python のように -1, 0, または +1 だけを返します; 指定されれば、それはその適切なメソッドを呼び出し、任意の Python オブジェクトを返せます。(訳注: 2015年の今となって、ここに書かれている cmp の仕様が実在したのか不明な状態になっている。ビルトインの cmp リファレンスにはこれに関係する履歴は書かれていない。What&#8217;s New を 2.7 まで追いかけても以後変更された記録はない。)</p>
<p>C プログラマにとって興味深い関連する変更があります。型オブジェクトに新しい <code class="docutils literal"><span class="pre">tp_richcmp</span></code> スロットと、この拡張された比較を行うAPIが追加されました。ここではC APIについて言及しませんが、あながた関連する関数のリストを見たければ、PEP 207かバージョン2.1のC APIドキュメントを参照してください。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-27"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0207"><strong>PEP 207</strong></a>: 拡張比較</dt>
<dd><p class="first last">David Ascher によるかつての仕事に大きく拠りますが  Guido van Rossum によって著され、実装されました。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-230-warning-framework">
<h2>PEP 230: 警告フレームワーク<a class="headerlink" href="#pep-230-warning-framework" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>10 年の間に、Python は途中で廃止されたモジュールと機能の特定の番号を蓄積してきました。どれだけのコードが活用されているか知る術はないので、機能を削除して問題ないか把握することは困難です。その機能に依存するプログラムは一つもないかもしれませんし、たくさんあるかもしれません。より構造化された方法で古い機能を削除できるようにするために、警告のフレームワークが追加されました。Python の開発者がある機能を取り除きたいときは、まずは Python の次のバージョンで警告を引き起こします。続く Python バージョンで開発者はその機能を削除出来、ユーザは古い機能の使用を取り除くために Python リリースサイクル一つ丸々使えます。</p>
<p>Python 2.1 はこのスキームで使われる警告フレームワークを追加します。また、警告の表示機能や表示させたくない警告を除外する機能を提供する、 <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> モジュールを追加します。サードパーティーのモジュールはまた、彼らがサポート対象外にしたい古い機能を非推奨と知らしめるのにこのフレームワークを利用できます。</p>
<p>例えば、Python2.1では <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code> モジュールは廃止されたので、これをインポートすると警告が表示されます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">regex</span>
<span class="go">__main__:1: DeprecationWarning: the regex module</span>
<span class="go">         is deprecated; please use the re module</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>警告は <a class="reference internal" href="../library/warnings.html#warnings.warn" title="warnings.warn"><code class="xref py py-func docutils literal"><span class="pre">warnings.warn()</span></code></a> 関数を呼び出すことで発行できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;feature X no longer supported&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>最初のパラメータは警告メッセージです。任意追加のパラメータは、特定の警告カテゴリを指定するために利用することができます。</p>
<p>特定の警告を無効にするためにフィルターを追加できます。また警告を抑止するためにメッセージまたはモジュール名に正規表現が適用できます。例えば <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code> モジュールを使ったプログラムで、今すぐには <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal"><span class="pre">re</span></code></a> モジュールに変換する時間をかけられないプログラムがあるとします。警告は以下呼び出しにより抑制できます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="n">action</span> <span class="o">=</span> <span class="s">&#39;ignore&#39;</span><span class="p">,</span>
                        <span class="n">message</span><span class="o">=</span><span class="s">&#39;.*regex module is deprecated&#39;</span><span class="p">,</span>
                        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                        <span class="n">module</span> <span class="o">=</span> <span class="s">&#39;__main__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>これは <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal"><span class="pre">__main__</span></code></a> モジュール内で引き起こされた <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-class docutils literal"><span class="pre">DeprecationWarning</span></code></a> 警告だけに適用され、 <code class="xref py py-mod docutils literal"><span class="pre">regex</span></code> モジュールが非推奨となったことについてのメッセージにマッチする正規表現を適用するフィルタを追加し、そして結果としてそのような警告は無視されることになります。警告を一回きりの表示にしたり、違反コードが実行されるたびに表示したり、警告ではなく例外に切り替えてプログラム停止することも出来ます(例外が普通の方法で捕捉されない限り、です、もちろん)。</p>
<p>関数は、警告を発行するための Python の C API にも追加されました。詳細については PEP 230 または Python の API ドキュメントを参照してください。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-28"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0005"><strong>PEP 5</strong></a> - 言語の進化のためのガイドライン</dt>
<dd><p class="first last">Python から古い機能を削除する時に従うべき手順を示すため、 Paul Prescod により書かれました。当 PEP に記載された方針は正式に採用されていませんが、最終的な方針も Prescod の提案とおそらくさほど違いはないでしょう。</p>
</dd>
<dt><span class="target" id="index-29"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0230"><strong>PEP 230</strong></a> - 警告フレームワーク</dt>
<dd><p class="first last">Guido van Rossum 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-229-new-build-system">
<h2>PEP 229: 新しいビルドシステム<a class="headerlink" href="#pep-229-new-build-system" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python のコンパイル時、ユーザはソースツリーの中に入って、様々な追加モジュールを有効にするために <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> ファイルを編集しなければなりませんでした; デフォルトのセットは比較的小さくて、ほとんどの Unix プラットフォームで、コンパイルするモジュールを制限しています。これは、特に Linux に顕著ですが、たくさんの追加機能を持った Unix プラットフォームでは、Python インストレーションはしばしば、そう出来るのに有用なモジュールを全く含まない、といったことが起こることを意味しています。</p>
<p>Python 2.0 は、配布と拡張のインストールをするためのモジュールのセットである Distutils を追加しました。Python 2.1 では Distutils を、たくさんの拡張モジュールの標準ライブラリを、サポートする機器かどうかを自動検出してコンパイルするのに使っています。これが Python インストレーションをより簡単に、より機能的とするものであることが期待されています。</p>
<p>モジュールを有効化するために <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> を編集する必要性の代わりに、Python ソースツリーのトップレベルディレクトリにある <code class="file docutils literal"><span class="pre">setup.py</span></code> スクリプトがビルド時に実行され、システムのモジュールとヘッダファイルを調べることによって、どのモジュールが有効に出来るのかを検出しようと試みます。モジュールが <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> 内でそう構成されていれば、 <code class="file docutils literal"><span class="pre">setup.py</span></code> スクリプトはそのモジュールをコンパイルしようとはせずに <code class="file docutils literal"><span class="pre">Modules/Setup</span></code> ファイル内容に従います。これは特定のプラットフォームで必要となるヘンチクリンなコマンドラインフラグやライブラリフラグを特定する手段も与えてくれます。</p>
<p>もう一つの大きなビルド機構の変更点は Neil Schemenauer による再構成で、今や Python は、トップディレクトリと <code class="file docutils literal"><span class="pre">Python/</span></code>, <code class="file docutils literal"><span class="pre">Parser/</span></code>, <code class="file docutils literal"><span class="pre">Objects/</span></code>, <code class="file docutils literal"><span class="pre">Modules/</span></code> サブディレクトリにあった別々の Makefile が再帰的にビルドする代わりに、再帰をしないトップレベルの単一 makefile を使うようになっています。このことで Python のビルドは速くなり、 Makefile をもてあそぶのが単純明快になっています。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-30"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0229"><strong>PEP 229</strong></a> - Distutils を使った Python のビルド</dt>
<dd><p class="first last">A.M. Kuchling 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-205-weak-references">
<h2>PEP 205: 弱参照<a class="headerlink" href="#pep-205-weak-references" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールを通して利用出来る弱参照(weak references)は、ささやかですが有用な、Python プログラマの道具箱に新たに加わったデータ型です。</p>
<p>オブジェクトへの参照(辞書内やリスト内を思い浮かべてください)を記憶しておくということは、オブジェクトを生き永らえさせるという副作用を持っています。少しばかりの、この振る舞いが望ましくない特殊なケースがあります。オブジェクトのキャッシュがその最もありがちな一つで、もう一つはツリーのようなデータ構造での循環参照です。</p>
<p>例えば、 ひとさまの関数 <code class="docutils literal"><span class="pre">f(x)</span></code> の結果をキャッシュしておくメモ化関数を考えてみましょう。関数 <code class="docutils literal"><span class="pre">f(x)</span></code> の引数ごとに辞書に記憶します:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c"># Cache the returned object</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">retval</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p>このバージョンは整数のような単純なものにはうまく働きますが、副作用を持っています; 辞書 <code class="docutils literal"><span class="pre">_cache</span></code> は戻り値への参照を保持するので、それらは Python プロセスが終了してクリーンアップされない限り、解放されません。整数であればそれは気にすることではありませんが、<code class="xref py py-func docutils literal"><span class="pre">f()</span></code> がオブジェクトや何かメモリをたくさん使うようなデータ構造を返すならば、これは問題になるかもしれません。</p>
<p>弱参照は、オブジェクトをその時間を超えて生き永らえさせたくないキャッシュの実装のための手段を提供します。オブジェクトがアクセス出来るのが弱参照からのみである場合、そのオブジェクトは解放されて、その弱参照は参照しているそのオブジェクトがもはや存在しないことを表明します。オブジェクト <em>obj</em> への弱参照を作るには、 <code class="docutils literal"><span class="pre">wr</span> <span class="pre">=</span> <span class="pre">weakref.ref(obj)</span></code> とします。参照されているオブジェクトは、それがあたかも関数であったかのように弱参照を「コール」することで得ます: <code class="docutils literal"><span class="pre">wr()</span></code> 。それは参照されたオブジェクトを返すか、もう存在していないのであれば <code class="docutils literal"><span class="pre">None</span></code> を返します。</p>
<p>これでオブジェクトを生き残らせないキャッシュを使う <code class="xref py py-func docutils literal"><span class="pre">memoize()</span></code> を、キャッシュ内に弱参照を記憶するというやり方で書けます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">_cache</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]()</span>
        <span class="c"># If weak reference object still exists,</span>
        <span class="c"># return it</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="k">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">obj</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c"># Cache a weak reference</span>
    <span class="n">_cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">retval</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal"><span class="pre">weakref</span></code></a> モジュールでは、弱参照のように振舞うプロキシオブジェクトも作れます &#8212; プロキシオブジェクトによってのみ参照されるオブジェクトが解放されます &#8211; オブジェクトを取り出すために明示的に「呼び出す」必要をなくすためにプロキシは、全てのオブジェクトへの操作を、オブジェクトが生きている限り透過的に転送します。オブジェクトが解放された場合、プロキシを使おうとすると <a class="reference internal" href="../library/weakref.html#weakref.ReferenceError" title="weakref.ReferenceError"><code class="xref py py-exc docutils literal"><span class="pre">weakref.ReferenceError</span></code></a> 例外が起こります:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">proxy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c"># Equivalent to obj.attr</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span> <span class="c"># Equivalent to obj.meth()</span>
<span class="k">del</span> <span class="n">obj</span>
<span class="n">proxy</span><span class="o">.</span><span class="n">attr</span>   <span class="c"># raises weakref.ReferenceError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-31"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0205"><strong>PEP 205</strong></a> - 弱参照</dt>
<dd><p class="first last">Fred L. Drake, Jr. 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-232-function-attributes">
<h2>PEP 232: 関数の属性<a class="headerlink" href="#pep-232-function-attributes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python 2.1 では、関数に任意の情報をアタッチさせる(付随させる)ことが出来るようになりました。人々はしばしば関数やメソッドについての情報を保持するのに docstring を使ってきました。というのも <code class="docutils literal"><span class="pre">__doc__</span></code> だけが唯一関数に任意の情報をアタッチ出来る方法だったからです。例えば、Zope ウェブアプリケーションでは、関数は docstring に情報を持つことによって公開アクセスのために安全かどうかマークされ、John Aycock の SPARK 解析フレームワークでは docstring は BNF 文法記述の部分を、解析のために保持していました。この「詰め込み」は嘆かわしいことです。docstring はまったくもって関数のドキュメンテーションを保持するのに意図されたものです。例えば Zope では自分のために行儀よく関数にドキュメント付け出来ないということです。</p>
<p>ついに関数に、任意の属性をセットし、取り出すことが出来るようになりました。普通の Python 構文で出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">():</span> <span class="k">pass</span>

<span class="n">f</span><span class="o">.</span><span class="n">publish</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">secure</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="s">&quot;A ::= B (C D)*&quot;</span>
</pre></div>
</div>
<p>属性を含んだ辞書に、関数の属性 <code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code> としてアクセス出来ます。クラスインスタンスの <code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code> 属性とは違って、関数では実際には、 <code class="xref py py-attr docutils literal"><span class="pre">__dict__</span></code> に別の辞書を代入出来ます。ですが、新しい値は普通の Python 辞書に制限されています; ズルは <em>出来ません</em> し、 <code class="xref py py-class docutils literal"><span class="pre">UserDict</span></code> インスタンスやなにかほかのマッピングのように振舞うデタラメなオブジェクトはセット出来ません。</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-32"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0232"><strong>PEP 232</strong></a> - 関数の属性</dt>
<dd><p class="first last">Barry Warsaw 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-235-importing-modules-on-case-insensitive-platforms">
<h2>PEP 235: 大文字小文字を区別しないプラットフォームでのモジュールの読み込み<a class="headerlink" href="#pep-235-importing-modules-on-case-insensitive-platforms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかのオペレーティングシステムは、大小文字区別に無関心なファイルシステムを持っています。MacOS と Windows がその代表例です。それらシステムにおいてはファイル名 <code class="docutils literal"><span class="pre">FILE.PY</span></code> と <code class="docutils literal"><span class="pre">file.py</span></code> の区別が出来ません。たとえそれが元のファイル名を尊重して格納出来たとしてもです(それらは大小文字維持、でもあります)。</p>
<p>Python 2.1 では <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal"><span class="pre">import</span></code></a> 文が、case-insensitive (大小文字に無関心)なプラットフォームで case-sensitivity (大小文字への繊細さ)をシミュレートして動作します。Python は今や、まずはデフォルトで case-sensitive なマッチによる検索をし、それで見つからなければ <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal"><span class="pre">ImportError</span></code></a> を投げます。ですから <code class="docutils literal"><span class="pre">import</span> <span class="pre">file</span></code> は <code class="docutils literal"><span class="pre">FILE.PY</span></code> をインポートしません。case-insensitive マッチングは Python インタプリタ開始前に環境変数 <span class="target" id="index-33"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONCASEOK"><code class="xref std std-envvar docutils literal"><span class="pre">PYTHONCASEOK</span></code></a> をセットすることで要求出来ます。</p>
</div>
<div class="section" id="pep-217-interactive-display-hook">
<h2>PEP 217: 対話モード用 Display Hook<a class="headerlink" href="#pep-217-interactive-display-hook" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Python インタプリタを対話的に使う際には、コマンドの出力結果表示にはビルトインの <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> 関数が使われます。Python 2.1 ではこの <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> の代わりに呼び出される呼び出し可能オブジェクトを、 <a class="reference internal" href="../library/sys.html#sys.displayhook" title="sys.displayhook"><code class="xref py py-func docutils literal"><span class="pre">sys.displayhook()</span></code></a> 変数にセット出来ます。たとえば特別な pretty- printing 関数をセット出来ます:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Create a recursive data structure</span>
<span class="gp">... </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="c"># Show Python&#39;s default output</span>
<span class="go">[1, 2, 3, [...]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Use pprint.pprint() as the display function</span>
<span class="gp">... </span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">displayhook</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[1, 2, 3,  &lt;Recursion on list with id=135143996&gt;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-34"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0217"><strong>PEP 217</strong></a> - Display Hook の対話的な使用</dt>
<dd><p class="first last">Moshe Zadka 著、実装</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="pep-208-new-coercion-model">
<h2>PEP 208: 新しい型強制モデル<a class="headerlink" href="#pep-208-new-coercion-model" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>How numeric coercion is done at the C level was significantly modified.  This
will only affect the authors of C extensions to Python, allowing them more
flexibility in writing extension types that support numeric operations.</p>
<p>Extension types can now set the type flag <code class="docutils literal"><span class="pre">Py_TPFLAGS_CHECKTYPES</span></code> in their
<code class="docutils literal"><span class="pre">PyTypeObject</span></code> structure to indicate that they support the new coercion model.
In such extension types, the numeric slot functions can no longer assume that
they&#8217;ll be passed two arguments of the same type; instead they may be passed two
arguments of differing types, and can then perform their own internal coercion.
If the slot function is passed a type it can&#8217;t handle, it can indicate the
failure by returning a reference to the <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code> singleton value.
The numeric functions of the other type will then be tried, and perhaps they can
handle the operation; if the other type also returns <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code>, then
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a> will be raised.  Numeric methods written in Python can also
return <code class="docutils literal"><span class="pre">Py_NotImplemented</span></code>, causing the interpreter to act as if the method
did not exist (perhaps raising a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code></a>, perhaps trying another
object&#8217;s numeric methods).</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0208"><strong>PEP 208</strong></a> - Reworking the Coercion Model</dt>
<dd>Written and implemented by Neil Schemenauer, heavily based upon earlier work by
Marc-André Lemburg.  Read this to understand the fine points of how numeric
operations will now be processed at the C level.</dd>
</dl>
</div>
</div>
<div class="section" id="pep-241-metadata-in-python-packages">
<h2>PEP 241: Metadata in Python Packages<a class="headerlink" href="#pep-241-metadata-in-python-packages" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A common complaint from Python users is that there&#8217;s no single catalog of all
the Python modules in existence.  T. Middleton&#8217;s Vaults of Parnassus at
<a class="reference external" href="http://www.vex.net/parnassus/">http://www.vex.net/parnassus/</a> are the largest catalog of Python modules, but
registering software at the Vaults is optional, and many people don&#8217;t bother.</p>
<p>As a first small step toward fixing the problem, Python software packaged using
the Distutils <strong class="command">sdist</strong> command will include a file named
<code class="file docutils literal"><span class="pre">PKG-INFO</span></code> containing information about the package such as its name,
version, and author (metadata, in cataloguing terminology).  PEP 241 contains
the full list of fields that can be present in the <code class="file docutils literal"><span class="pre">PKG-INFO</span></code> file.  As
people began to package their software using Python 2.1, more and more packages
will include metadata, making it possible to build automated cataloguing systems
and experiment with them.  With the result experience, perhaps it&#8217;ll be possible
to design a really good catalog and then build support for it into Python 2.2.
For example, the Distutils <strong class="command">sdist</strong> and <strong class="command">bdist_*</strong> commands
could support a <code class="docutils literal"><span class="pre">upload</span></code> option that would automatically upload your
package to a catalog server.</p>
<p>You can start creating packages containing <code class="file docutils literal"><span class="pre">PKG-INFO</span></code> even if you&#8217;re not
using Python 2.1, since a new release of the Distutils will be made for users of
earlier Python versions.  Version 1.0.2 of the Distutils includes the changes
described in PEP 241, as well as various bugfixes and enhancements.  It will be
available from  the Distutils SIG at <a class="reference external" href="https://www.python.org/sigs/distutils-sig/">https://www.python.org/sigs/distutils-sig/</a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<dl class="last docutils">
<dt><span class="target" id="index-35"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0241"><strong>PEP 241</strong></a> - Pythonソフトウェアパッケージのためのメタデータ</dt>
<dd><p class="first last">A.M. Kuchling 著、実装</p>
</dd>
<dt><span class="target" id="index-36"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0243"><strong>PEP 243</strong></a> - レポジトリアップロードモジュールのメカニズム</dt>
<dd>Written by Sean Reifschneider, this draft PEP describes a proposed mechanism for
uploading  Python packages to a central server.</dd>
</dl>
</div>
</div>
<div class="section" id="new-and-improved-modules">
<h2>新しいモジュールと改良されたモジュール<a class="headerlink" href="#new-and-improved-modules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<ul>
<li><p class="first">Ka-Ping Yee contributed two new modules: <code class="xref py py-mod docutils literal"><span class="pre">inspect.py</span></code>, a module for
getting information about live Python code, and <code class="xref py py-mod docutils literal"><span class="pre">pydoc.py</span></code>, a module for
interactively converting docstrings to HTML or text.  As a bonus,
<code class="file docutils literal"><span class="pre">Tools/scripts/pydoc</span></code>, which is now automatically installed, uses
<code class="xref py py-mod docutils literal"><span class="pre">pydoc.py</span></code> to display documentation given a Python module, package, or
class name.  For example, <code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">xml.dom</span></code> displays the following:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">Python</span> <span class="n">Library</span> <span class="n">Documentation</span><span class="p">:</span> <span class="n">package</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="ow">in</span> <span class="n">xml</span>

<span class="n">NAME</span>
    <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="o">-</span> <span class="n">W3C</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="n">implementation</span> <span class="k">for</span> <span class="n">Python</span><span class="o">.</span>

<span class="n">FILE</span>
    <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python2</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">xml</span><span class="o">/</span><span class="n">dom</span><span class="o">/</span><span class="n">__init__</span><span class="o">.</span><span class="n">pyc</span>

<span class="n">DESCRIPTION</span>
    <span class="n">The</span> <span class="n">Python</span> <span class="n">mapping</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Document</span> <span class="n">Object</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">documented</span> <span class="ow">in</span> <span class="n">the</span>
    <span class="n">Python</span> <span class="n">Library</span> <span class="n">Reference</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">section</span> <span class="n">on</span> <span class="n">the</span> <span class="n">xml</span><span class="o">.</span><span class="n">dom</span> <span class="n">package</span><span class="o">.</span>

    <span class="n">This</span> <span class="n">package</span> <span class="n">contains</span> <span class="n">the</span> <span class="n">following</span> <span class="n">modules</span><span class="p">:</span>
      <span class="o">...</span>
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">pydoc</span></code> also includes a Tk-based interactive help browser.   <code class="file docutils literal"><span class="pre">pydoc</span></code>
quickly becomes addictive; try it out!</p>
</li>
<li><p class="first">Two different modules for unit testing were added to the standard library.
The <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal"><span class="pre">doctest</span></code></a> module, contributed by Tim Peters, provides a testing
framework based on running embedded examples in docstrings and comparing the
results against the expected output.  PyUnit, contributed by Steve Purcell, is a
unit testing framework inspired by JUnit, which was in turn an adaptation of
Kent Beck&#8217;s Smalltalk testing framework.  See <a class="reference external" href="http://pyunit.sourceforge.net/">http://pyunit.sourceforge.net/</a> for
more information about PyUnit.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal"><span class="pre">difflib</span></code></a> module contains a class, <code class="xref py py-class docutils literal"><span class="pre">SequenceMatcher</span></code>, which
compares two sequences and computes the changes required to transform one
sequence into the other.  For example, this module can be used to write a tool
similar to the Unix <strong class="program">diff</strong> program, and in fact the sample program
<code class="file docutils literal"><span class="pre">Tools/scripts/ndiff.py</span></code> demonstrates how to write such a script.</p>
</li>
<li><p class="first"><a class="reference internal" href="../library/curses.panel.html#module-curses.panel" title="curses.panel: A panel stack extension that adds depth to  curses windows."><code class="xref py py-mod docutils literal"><span class="pre">curses.panel</span></code></a>, a wrapper for the panel library, part of ncurses and of
SYSV curses, was contributed by Thomas Gellekum.  The panel library provides
windows with the additional feature of depth. Windows can be moved higher or
lower in the depth ordering, and the panel library figures out where panels
overlap and which sections are visible.</p>
</li>
<li><p class="first">The PyXML package has gone through a few releases since Python 2.0, and Python
2.1 includes an updated version of the <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal"><span class="pre">xml</span></code></a> package.  Some of the
noteworthy changes include support for Expat 1.2 and later versions, the ability
for Expat parsers to handle files in any encoding supported by Python, and
various bugfixes for SAX, DOM, and the <code class="xref py py-mod docutils literal"><span class="pre">minidom</span></code> module.</p>
</li>
<li><p class="first">Ping also contributed another hook for handling uncaught exceptions.
<a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal"><span class="pre">sys.excepthook()</span></code></a> can be set to a callable object.  When an exception isn&#8217;t
caught by any <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal"><span class="pre">try</span></code></a>...<a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal"><span class="pre">except</span></code></a> blocks, the exception will be
passed to <a class="reference internal" href="../library/sys.html#sys.excepthook" title="sys.excepthook"><code class="xref py py-func docutils literal"><span class="pre">sys.excepthook()</span></code></a>, which can then do whatever it likes.  At the
Ninth Python Conference, Ping demonstrated an application for this hook:
printing an extended traceback that not only lists the stack frames, but also
lists the function arguments and the local variables for each frame.</p>
</li>
<li><p class="first">Various functions in the <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal"><span class="pre">time</span></code></a> module, such as <code class="xref py py-func docutils literal"><span class="pre">asctime()</span></code> and
<code class="xref py py-func docutils literal"><span class="pre">localtime()</span></code>, require a floating point argument containing the time in
seconds since the epoch.  The most common use of these functions is to work with
the current time, so the floating point argument has been made optional; when a
value isn&#8217;t provided, the current time will be used.  For example, log file
entries usually need a string containing the current time; in Python 2.1,
<code class="docutils literal"><span class="pre">time.asctime()</span></code> can be used, instead of the lengthier
<code class="docutils literal"><span class="pre">time.asctime(time.localtime(time.time()))</span></code> that was previously required.</p>
<p>This change was proposed and implemented by Thomas Wouters.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">ftplib</span></code></a> module now defaults to retrieving files in passive mode,
because passive mode is more likely to work from behind a firewall.  This
request came from the Debian bug tracking system, since other Debian packages
use <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal"><span class="pre">ftplib</span></code></a> to retrieve files and then don&#8217;t work from behind a firewall.
It&#8217;s deemed unlikely that this will cause problems for anyone, because Netscape
defaults to passive mode and few people complain, but if passive mode is
unsuitable for your application or network setup, call <code class="docutils literal"><span class="pre">set_pasv(0)</span></code> on
FTP objects to disable passive mode.</p>
</li>
<li><p class="first">Support for raw socket access has been added to the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal"><span class="pre">socket</span></code></a> module,
contributed by Grant Edwards.</p>
</li>
<li><p class="first">The <a class="reference internal" href="../library/profile.html#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal"><span class="pre">pstats</span></code></a> module now contains a simple interactive statistics browser
for displaying timing profiles for Python programs, invoked when the module is
run as a script.  Contributed by  Eric S. Raymond.</p>
</li>
<li><p class="first">A new implementation-dependent function, <code class="docutils literal"><span class="pre">sys._getframe([depth])</span></code>, has
been added to return a given frame object from the current call stack.
<a class="reference internal" href="../library/sys.html#sys._getframe" title="sys._getframe"><code class="xref py py-func docutils literal"><span class="pre">sys._getframe()</span></code></a> returns the frame at the top of the call stack;  if the
optional integer argument <em>depth</em> is supplied, the function returns the frame
that is <em>depth</em> calls below the top of the stack.  For example,
<code class="docutils literal"><span class="pre">sys._getframe(1)</span></code> returns the caller&#8217;s frame object.</p>
<p>This function is only present in CPython, not in Jython or the .NET
implementation.  Use it for debugging, and resist the temptation to put it into
production code.</p>
</li>
</ul>
</div>
<div class="section" id="other-changes-and-fixes">
<h2>その他の変更と修正<a class="headerlink" href="#other-changes-and-fixes" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>短めのリリースサイクルだったため Python 2.1 では比較的少ない変更でした。CVS 変更ログの検索では 117 のパッチ適用と 136 のバグフィックスが見つかります。ともに少なく見積もっています。いくつかの注目に値する変更を紹介します:</p>
<ul>
<li><p class="first">A specialized object allocator is now optionally available, that should be
faster than the system <code class="xref py py-func docutils literal"><span class="pre">malloc()</span></code> and have less memory overhead.  The
allocator uses C&#8217;s <code class="xref py py-func docutils literal"><span class="pre">malloc()</span></code> function to get large pools of memory, and
then fulfills smaller memory requests from these pools.  It can be enabled by
providing the <code class="xref std std-option docutils literal"><span class="pre">--with-pymalloc</span></code> option to the <strong class="program">configure</strong>
script; see <code class="file docutils literal"><span class="pre">Objects/obmalloc.c</span></code> for the implementation details.</p>
<p>Authors of C extension modules should test their code with the object allocator
enabled, because some incorrect code may break, causing core dumps at runtime.
There are a bunch of memory allocation functions in Python&#8217;s C API that have
previously been just aliases for the C library&#8217;s <code class="xref py py-func docutils literal"><span class="pre">malloc()</span></code> and
<code class="xref py py-func docutils literal"><span class="pre">free()</span></code>, meaning that if you accidentally called mismatched functions, the
error wouldn&#8217;t be noticeable.  When the object allocator is enabled, these
functions aren&#8217;t aliases of <code class="xref py py-func docutils literal"><span class="pre">malloc()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">free()</span></code> any more, and
calling the wrong function to free memory will get you a core dump.  For
example, if memory was allocated using <code class="xref py py-func docutils literal"><span class="pre">PyMem_New()</span></code>, it has to be freed
using <code class="xref py py-func docutils literal"><span class="pre">PyMem_Del()</span></code>, not <code class="xref py py-func docutils literal"><span class="pre">free()</span></code>.  A few modules included with Python
fell afoul of this and had to be fixed; doubtless there are more third-party
modules that will have the same problem.</p>
<p>The object allocator was contributed by Vladimir Marangozov.</p>
</li>
<li><p class="first">The speed of line-oriented file I/O has been improved because people often
complain about its lack of speed, and because it&#8217;s often been used as a naïve
benchmark.  The <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal"><span class="pre">readline()</span></code></a> method of file objects has therefore been
rewritten to be much faster.  The exact amount of the speedup will vary from
platform to platform depending on how slow the C library&#8217;s <code class="xref py py-func docutils literal"><span class="pre">getc()</span></code> was, but
is around 66%, and potentially much faster on some particular operating systems.
Tim Peters did much of the benchmarking and coding for this change, motivated by
a discussion in comp.lang.python.</p>
<p>A new module and method for file objects was also added, contributed by Jeff
Epler. The new method, <code class="xref py py-meth docutils literal"><span class="pre">xreadlines()</span></code>, is similar to the existing
<code class="xref py py-func docutils literal"><span class="pre">xrange()</span></code> built-in.  <code class="xref py py-func docutils literal"><span class="pre">xreadlines()</span></code> returns an opaque sequence object
that only supports being iterated over, reading a line on every iteration but
not reading the entire file into memory as the existing <code class="xref py py-meth docutils literal"><span class="pre">readlines()</span></code> method
does. You&#8217;d use it like this:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">xreadlines</span><span class="p">():</span>
    <span class="c"># ... do something for each line ...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>For a fuller discussion of the line I/O changes, see the python-dev summary for
January 1-15, 2001 at <a class="reference external" href="https://www.python.org/dev/summary/2001-01-1/">https://www.python.org/dev/summary/2001-01-1/</a>.</p>
</li>
<li><p class="first">A new method, <code class="xref py py-meth docutils literal"><span class="pre">popitem()</span></code>, was added to dictionaries to enable
destructively iterating through the contents of a dictionary; this can be faster
for large dictionaries because there&#8217;s no need to construct a list containing
all the keys or values. <code class="docutils literal"><span class="pre">D.popitem()</span></code> removes a random <code class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></code> pair
from the dictionary <code class="docutils literal"><span class="pre">D</span></code> and returns it as a 2-tuple.  This was implemented
mostly by Tim Peters and Guido van Rossum, after a suggestion and preliminary
patch by Moshe Zadka.</p>
</li>
<li><p class="first">Modules can now control which names are imported when <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code>
is used, by defining an <code class="docutils literal"><span class="pre">__all__</span></code> attribute containing a list of names that
will be imported.  One common complaint is that if the module imports other
modules such as <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal"><span class="pre">sys</span></code></a> or <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal"><span class="pre">string</span></code></a>, <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> will add
them to the importing module&#8217;s namespace.  To fix this, simply list the public
names in <code class="docutils literal"><span class="pre">__all__</span></code>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="c"># List public names</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Database&#39;</span><span class="p">,</span> <span class="s">&#39;open&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>A stricter version of this patch was first suggested and implemented by Ben
Wolfson, but after some python-dev discussion, a weaker final version was
checked in.</p>
</li>
<li><p class="first">Applying <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a> to strings previously used octal escapes for
non-printable characters; for example, a newline was <code class="docutils literal"><span class="pre">'\012'</span></code>.  This was a
vestigial trace of Python&#8217;s C ancestry, but today octal is of very little
practical use.  Ka-Ping Yee suggested using hex escapes instead of octal ones,
and using the <code class="docutils literal"><span class="pre">\n</span></code>, <code class="docutils literal"><span class="pre">\t</span></code>, <code class="docutils literal"><span class="pre">\r</span></code> escapes for the appropriate characters,
and implemented this new formatting.</p>
</li>
<li><p class="first">Syntax errors detected at compile-time can now raise exceptions containing the
filename and line number of the error, a pleasant side effect of the compiler
reorganization done by Jeremy Hylton.</p>
</li>
<li><p class="first">C extensions which import other modules have been changed to use
<code class="xref py py-func docutils literal"><span class="pre">PyImport_ImportModule()</span></code>, which means that they will use any import hooks
that have been installed.  This is also encouraged for third-party extensions
that need to import some other module from C code.</p>
</li>
<li><p class="first">The size of the Unicode character database was shrunk by another 340K thanks
to Fredrik Lundh.</p>
</li>
<li><p class="first">いくつかの新たなポートの寄与: MacOS X (by Steven Majewski), Cygwin (by Jason Tishler); RISCOS (by Dietmar Schwertberger); Unixware 7  (by Billy G. Allie).</p>
</li>
</ul>
<p>そしてよくあるマイナーなバグフィックス、マイナーなメモリリーク、ドキュメンテーション文字列の編集やほかの微調整があり、全てを列挙するには長過ぎます。もし見たいのであれば、CVS ログで完全な詳細を読んで下さい。</p>
</div>
<div class="section" id="acknowledgements">
<h2>謝辞<a class="headerlink" href="#acknowledgements" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>著者は提案の申し出や修正、様々なこの記事の草稿の助けをしてくれた以下の人々に感謝します:  Graeme Cross, David Goodger, Jay Graves, Michael Hudson, Marc-André Lemburg, Fredrik Lundh, Neil Schemenauer, Thomas Wouters.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">What&#8217;s New in Python 2.1</a><ul>
<li><a class="reference internal" href="#introduction">はじめに</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: 入れ子状のスコープ</a></li>
<li><a class="reference internal" href="#pep-236-future-directives">PEP 236: __future__ 指示文</a></li>
<li><a class="reference internal" href="#pep-207-rich-comparisons">PEP 207: 拡張比較</a></li>
<li><a class="reference internal" href="#pep-230-warning-framework">PEP 230: 警告フレームワーク</a></li>
<li><a class="reference internal" href="#pep-229-new-build-system">PEP 229: 新しいビルドシステム</a></li>
<li><a class="reference internal" href="#pep-205-weak-references">PEP 205: 弱参照</a></li>
<li><a class="reference internal" href="#pep-232-function-attributes">PEP 232: 関数の属性</a></li>
<li><a class="reference internal" href="#pep-235-importing-modules-on-case-insensitive-platforms">PEP 235: 大文字小文字を区別しないプラットフォームでのモジュールの読み込み</a></li>
<li><a class="reference internal" href="#pep-217-interactive-display-hook">PEP 217: 対話モード用 Display Hook</a></li>
<li><a class="reference internal" href="#pep-208-new-coercion-model">PEP 208: 新しい型強制モデル</a></li>
<li><a class="reference internal" href="#pep-241-metadata-in-python-packages">PEP 241: Metadata in Python Packages</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">新しいモジュールと改良されたモジュール</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">その他の変更と修正</a></li>
<li><a class="reference internal" href="#acknowledgements">謝辞</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="2.2.html"
                        title="前の章へ">What&#8217;s New in Python 2.2</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="2.0.html"
                        title="次の章へ">What&#8217;s New in Python 2.0</a></p>
<h3>このページ</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/whatsnew/2.1.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="検索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    モジュール、クラス、または関数名を入力してください
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Pythonモジュール索引"
             >モジュール</a> |</li>
        <li class="right" >
          <a href="2.0.html" title="What’s New in Python 2.0"
             >次へ</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="What’s New in Python 2.2"
             >前へ</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li class="nav-item nav-item-1"><a href="index.html" >What&#8217;s New in Python</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Dec 28, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    <br />
    <a href="https://github.com/python-doc-ja/python-doc-ja">Pythonドキュメント日本語翻訳プロジェクト</a>
    によって翻訳されました。
    <a href="https://github.com/python-doc-ja/python-doc-ja/issues">誤訳を報告する。</a>
    </div>

  </body>
</html>